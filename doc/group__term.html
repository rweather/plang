<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Native C API - Term Representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Native C API - Term Representation</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> )(void *data, const char *format,...)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga24a09ed7b83fb4cb50ab69d94eb9f30c">p_term_expand_dcg</a> (p_context *context, p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands the DCG rule in <em>term</em> to a full clause definition for <em>context</em>.  <a href="#ga24a09ed7b83fb4cb50ab69d94eb9f30c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab6d3f3332d1fae9b74d14d5b01052b27">p_term_sort</a> (p_context *context, p_term *list, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts <em>list</em> according to the <a class="el" href="group__term__comparison.html#term_precedes">term precedes</a> relationship.  <a href="#gab6d3f3332d1fae9b74d14d5b01052b27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7">p_term_create_functor</a> (p_context *context, p_term *name, int arg_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor term within <em>ontext</em> with the specified <em>name</em> and <em>arg_count</em>. Returns the new functor.  <a href="#gaa2369f8488b027efed7a0aa7e8da73a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a">p_term_bind_functor_arg</a> (p_term *term, int index, p_term *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds the argument at <em>index</em> within the specified functor <em>term</em> to <em>value</em>.  <a href="#gabb4aa77bf08b8bc3d0ef94442a017c2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga62097d28b6ff5e4d3532b83d5dcbae9c">p_term_create_functor_with_args</a> (p_context *context, p_term *name, p_term **args, int arg_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor term within <em>ontext</em> with the specified <em>name</em> and the <em>arg_count</em> members of <em>args</em> as arguments. Returns the new functor.  <a href="#ga62097d28b6ff5e4d3532b83d5dcbae9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga17481776d0fda576367bae90263f7fe5">p_term_create_list</a> (p_context *context, p_term *head, p_term *tail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a list term from <em>head</em> and <em>tail</em> within <em>context</em>. Returns the new list.  <a href="#ga17481776d0fda576367bae90263f7fe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga4fe9ffcf5da089493b43bfb0140670b0">p_term_set_tail</a> (p_term *list, p_term *tail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the tail of <em>list</em> to <em>tail</em>.  <a href="#ga4fe9ffcf5da089493b43bfb0140670b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8">p_term_create_atom</a> (p_context *context, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an atom within <em>context</em> with the specified <em>name</em>.  <a href="#ga45ca0be88d01bae8971186c2b048aff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067">p_term_create_atom_n</a> (p_context *context, const char *name, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an atom within <em>context</em> with the <em>len</em> bytes at <em>name</em> as its atom name.  <a href="#ga7cdf6cb2a37ac6bd1852f52019243067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925">p_term_create_string</a> (p_context *context, const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string within <em>context</em> with the specified <em>str</em> value.  <a href="#ga07c94636569314c0d219497aa61ab925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga8c7104a045903c1d9c5fa56881e9d9f1">p_term_create_string_n</a> (p_context *context, const char *str, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string within <em>context</em> with the <em>len</em> bytes from the specified <em>str</em> buffer.  <a href="#ga8c7104a045903c1d9c5fa56881e9d9f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96">p_term_create_variable</a> (p_context *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unbound variable within <em>context</em>.  <a href="#ga770a6d4e622f5e3c1487a7e151c11e96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga899f47e78554cdb98491716cc3c5072c">p_term_create_named_variable</a> (p_context *context, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unbound variable within <em>context</em> and associates it with <em>name</em>.  <a href="#ga899f47e78554cdb98491716cc3c5072c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga5b517baf3da998736bf7a07ab83004ea">p_term_create_member_variable</a> (p_context *context, p_term *object, p_term *name, int auto_create)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unbound member variable within <em>context</em> that refers to the member <em>name</em> within <em>object</em>.  <a href="#ga5b517baf3da998736bf7a07ab83004ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaf8aa094355a33451017b76a059771247">p_term_create_integer</a> (p_context *context, int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an integer within <em>context</em> with the specified <em>value</em>.  <a href="#gaf8aa094355a33451017b76a059771247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga739432392dc4edf3fa58afe559702697">p_term_create_real</a> (p_context *context, double value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a real within <em>context</em> with the specified <em>value</em>.  <a href="#ga739432392dc4edf3fa58afe559702697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gacdd67ab1558d9c6756170fc550bb873c">p_term_nil_atom</a> (p_context *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the special "nil" atom that represents the empty list within <em>context</em>.  <a href="#gacdd67ab1558d9c6756170fc550bb873c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaf9664345cc144da2c249a6d5c245e1e7">p_term_prototype_atom</a> (p_context *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the special "prototype" atom within <em>context</em> that names the prototype for an object.  <a href="#gaf9664345cc144da2c249a6d5c245e1e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab2b33e5072cb40115a6a23cb7a1eef9f">p_term_class_name_atom</a> (p_context *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the special "className" atom within <em>context</em> that names the class of an object.  <a href="#gab2b33e5072cb40115a6a23cb7a1eef9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga3632325e60de70357ababa97655195e0">p_term_deref</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferences <em>term</em> to resolve bound variables.  <a href="#ga3632325e60de70357ababa97655195e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174">p_term_deref_member</a> (p_context *context, p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferences <em>term</em> to resolve bound variables within <em>context</em>.  <a href="#gaa914c3fb08f1a03a5a8c3cc264273174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga068ea25e5f02b95da3b353dd2f6b647b">p_term_deref_own_member</a> (p_context *context, p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferences <em>term</em> to resolve bound variables within <em>context</em>.  <a href="#ga068ea25e5f02b95da3b353dd2f6b647b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495">p_term_type</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type of <em>term</em> after dereferencing it.  <a href="#ga412cae4cf75b595d8d8a64d9b06a0495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga85c7d733fc9801d98f35b3e103a18c27">p_term_arg_count</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of arguments for a functor or predicate <em>term</em>, or zero if <em>term</em> is not a functor or predicate.  <a href="#ga85c7d733fc9801d98f35b3e103a18c27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777">p_term_name</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the functor, predicate, atom, or variable contained in <em>term</em>, or null if <em>term</em> does not have a name.  <a href="#gacb7b346b3f8f4a9fa31c3285eb615777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb">p_term_name_length</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length of the name of the functor, predicate, atom, or variable contained in <em>term</em>, or zero if <em>term</em> does not have a name.  <a href="#ga55a861549e8b42db317a5acec3a7cefb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd">p_term_name_length_utf8</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the UTF-8 length of the name of the functor, predicate, atom, or variable contained in <em>term</em>, or zero if <em>term</em> does not have a name.  <a href="#gab6582e252c8a8333f4b03560f715e5fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48">p_term_functor</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the atom name of the functor or predicate <em>term</em>, or null if <em>term</em> is not a functor or predicate.  <a href="#gad0dd17e897bd22628da3f65d063fca48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gafa650631563b752242f2026cbf7bbffb">p_term_arg</a> (const p_term *term, int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the argument at position <em>index</em> within the functor <em>term</em>, or null if <em>term</em> is not a functor or <em>index</em> is out of range.  <a href="#gafa650631563b752242f2026cbf7bbffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c">p_term_integer_value</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the 32-bit signed integer value within <em>term</em>, or zero if <em>term</em> is not an integer term.  <a href="#ga78f1318137be1b1714f7c51f61fe139c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d">p_term_real_value</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the double-precision floating point value within <em>term</em>, or zero if <em>term</em> is not a real term.  <a href="#ga995e38a5ad30ed0cb8b0c4e30028d39d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga084f1904b152af8467ab2c7a4dfbb403">p_term_head</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the head of the specified list <em>term</em>, or null if <em>term</em> is not a list term.  <a href="#ga084f1904b152af8467ab2c7a4dfbb403"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0">p_term_tail</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the tail of the specified list <em>term</em>, or null if <em>term</em> is not a list term.  <a href="#gab2dd3010fa91261ac29d46a2b85974e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2">p_term_object</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object term associated with a member variable reference <em>term</em>, or null if <em>term</em> is not a member variable reference.  <a href="#gad3aaeba3a153845864e314ecd112a7f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d">p_term_create_object</a> (p_context *context, p_term *prototype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an object term within <em>context</em> with the specified class <em>prototype</em>.  <a href="#ga3fa6a6d2393a60166fde6df21f76f92d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gadd8c3bb381f75d082b9878a634e043ca">p_term_create_class_object</a> (p_context *context, p_term *class_name, p_term *prototype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a class object term within <em>context</em> for the class called <em>name</em> with the specified base class <em>prototype</em>.  <a href="#gadd8c3bb381f75d082b9878a634e043ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137">p_term_add_property</a> (p_context *context, p_term *term, p_term *name, p_term *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>name</em> and <em>value</em> as a property to <em>term</em> within <em>context</em>.  <a href="#gab29419821fb3f557f9afad4aa633a137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73">p_term_property</a> (p_context *context, const p_term *term, const p_term *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value associated with the property <em>name</em> on <em>term</em> within <em>context</em>, or null if <em>name</em> is not present.  <a href="#gad505c00c9f70ad0429f87fc58a189b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd">p_term_own_property</a> (p_context *context, const p_term *term, const p_term *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value associated with the property <em>name</em> on <em>term</em> within <em>context</em>, or null if <em>name</em> is not present.  <a href="#gadeef4b96990a43a3e397d6c27a07fefd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gacbfe67d6fa4e2295ae305f390f22a715">p_term_set_own_property</a> (p_context *context, p_term *term, p_term *name, p_term *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the <em>value</em> associated with the property <em>name</em> on <em>term</em> within <em>context</em>.  <a href="#gacbfe67d6fa4e2295ae305f390f22a715"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207">p_term_is_instance_object</a> (p_context *context, const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>term</em> is an object within <em>context</em> and <em>term</em> is not a class object, zero otherwise.  <a href="#gae5e5969d3f3b1b70e062436b89f7a207"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de">p_term_is_class_object</a> (p_context *context, const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>term</em> is a class object within <em>context</em>, zero otherwise.  <a href="#ga93b370531936bcd03ebb61cb17f884de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21">p_term_inherits</a> (p_context *context, const p_term *term1, const p_term *term2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>term1</em> inherits from <em>term2</em> within <em>context</em>, zero otherwise.  <a href="#gaac80dd2765e7ce6c8b1a209e9fa92a21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gabb40c835640fed369b9ce34375663aab">p_term_is_instance_of</a> (p_context *context, const p_term *term1, const p_term *term2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>term1</em> is an instance of <em>term2</em>, zero otherwise.  <a href="#gabb40c835640fed369b9ce34375663aab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb">p_term_create_predicate</a> (p_context *context, p_term *name, int arg_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new predicate instance within <em>context</em> with the specified <em>name</em> and <em>arg_count</em> arguments.  <a href="#gaa9d06aa5a8ea6c4a8009317ee107b8eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gac191f9077fea60ad8f19220301920b5b">p_term_create_dynamic_clause</a> (p_context *context, p_term *head, p_term *body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new clause within <em>context</em> with the specified <em>head</em> and <em>body</em>.  <a href="#gac191f9077fea60ad8f19220301920b5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada">p_term_add_clause_first</a> (p_context *context, p_term *predicate, p_term *clause)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>clause</em> to <em>predicate</em> within <em>context</em> at the front of the predicate's clause list.  <a href="#ga83bf2d0d46b0b4ce885efd5680b00ada"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa">p_term_add_clause_last</a> (p_context *context, p_term *predicate, p_term *clause)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>clause</em> to <em>predicate</em> within <em>context</em> at the end of the predicate's clause list.  <a href="#ga0e3ef6b55a045f1409bdb14a6e2bb4aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4">p_term_clauses_begin</a> (const p_term *predicate, const p_term *head, p_term_clause_iter *iter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts an iteration over the clauses of <em>predicate</em>, using <em>iter</em> as the iteration control information.  <a href="#ga9af92fee96e9b92ecca2f952667944b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a">p_term_clauses_next</a> (p_term_clause_iter *iter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next clause for the iteration control block <em>iter</em>.  <a href="#ga9f12d42eecc40407851784aa0c21db1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga96bedcc8fb7e25d93845faa4a78bcd77">p_term_clauses_has_more</a> (const p_term_clause_iter *iter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>iter</em> has more clauses yet to be iterated.  <a href="#ga96bedcc8fb7e25d93845faa4a78bcd77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaece9b6033996b5718a7e2f3d360e62ba">p_term_create_database</a> (p_context *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new database term within <em>context</em>.  <a href="#gaece9b6033996b5718a7e2f3d360e62ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga672972a8bcdd8790638276dc8db446f3">p_term_database_add_predicate</a> (p_term *database, p_term *predicate)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds <em>predicate</em> to <em>database</em>.  <a href="#ga672972a8bcdd8790638276dc8db446f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gac4f5d5ff89205c3c02945657616a5ea5">p_term_database_lookup_predicate</a> (p_term *database, p_term *name, int arity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the predicate in <em>database</em> that is associated with <em>name</em> and <em>arity</em>.  <a href="#gac4f5d5ff89205c3c02945657616a5ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gac26b67ff7d5f2ad9e55e92ba74d69179">p_term_create_member_name</a> (p_context *context, p_term *class_name, p_term *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an atom which is the concatenation of <em>class_name</em>, <code>::</code>, and <em>name</em>. The atom is created within <em>context</em>.  <a href="#gac26b67ff7d5f2ad9e55e92ba74d69179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gae57ac2b3a143aef55d00866eda241620">p_term_bind_variable</a> (p_context *context, p_term *var, p_term *value, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds the variable <em>var</em> to <em>value</em>.  <a href="#gae57ac2b3a143aef55d00866eda241620"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5">p_term_unify</a> (p_context *context, p_term *term1, p_term *term2, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unifies <em>term1</em> with <em>term2</em> within <em>context</em>.  <a href="#gab4b9c1afcd3a2f29d451535f72dd71e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga44efb541f67a79075fb81f92e41b0e51">p_term_stdio_print_func</a> (void *data, const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints formatted output according to <em>format</em> to the stdio FILE stream <em>data</em>.  <a href="#ga44efb541f67a79075fb81f92e41b0e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b">p_term_print</a> (p_context *context, const p_term *term, <a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, void *print_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>.  <a href="#gae99be6acb41d73b3193125d854dde48b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gab2dee2140281b77c3ef3d435ae8b4b49">p_term_print_unquoted</a> (p_context *context, const p_term *term, <a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, void *print_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>.  <a href="#gab2dee2140281b77c3ef3d435ae8b4b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga700e9de8d736a8e0c1db26cbdba86db5">p_term_print_with_vars</a> (p_context *context, const p_term *term, <a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, void *print_data, const p_term *vars)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>.  <a href="#ga700e9de8d736a8e0c1db26cbdba86db5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac">p_term_precedes</a> (p_context *context, const p_term *term1, const p_term *term2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns -1, 0, or 1 depending upon whether <em>term1</em> is less than, equal to, or greater than <em>term2</em> using the "precedes" relationship. The terms are compared within <em>context</em>.  <a href="#ga6e764c6ab93287ce3a163b2947ca7cac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga473a01257325779b7a0f33deea809325">p_term_is_ground</a> (const p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns non-zero if <em>term</em> is a ground term without any unbound variables; zero otherwise.  <a href="#ga473a01257325779b7a0f33deea809325"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga885481b7ff34aeb38b88c77aa7d96477">p_term_clone</a> (p_context *context, p_term *term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clones <em>term</em> within <em>context</em> to create a new term that has freshly renamed versions of the variables within <em>term</em>.  <a href="#ga885481b7ff34aeb38b88c77aa7d96477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485">p_term_unify_clause</a> (p_context *context, p_term *term, p_term *clause)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unifies <em>term</em> with the renamed head of <em>clause</em>.  <a href="#ga58aa1d3f87e8a158158cf7639d9f5485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gac5ab644da0bd5f5d69d73721e38a838a">p_term_strcmp</a> (const p_term *str1, const p_term *str2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares <em>str1</em> and <em>str2</em> and returns a comparison code.  <a href="#gac5ab644da0bd5f5d69d73721e38a838a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#gaefa85ee27db354f5e5f4d0b213fde9cf">p_term_concat_string</a> (p_context *context, p_term *str1, p_term *str2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenates <em>str1</em> and <em>str2</em> to create a new string.  <a href="#gaefa85ee27db354f5e5f4d0b213fde9cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">p_term *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__term.html#ga146e5df50fb750f07ae1a2c71e852086">p_term_witness</a> (p_context *context, p_term *term, p_term **subgoal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a list of the free variables in <em>term</em>, where each free variable occurs only once in the list.  <a href="#ga146e5df50fb750f07ae1a2c71e852086"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module provides functions for creating Plang terms and operating on them. Terms may have a number of special forms, described by their <a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type()</a>: functors, lists, atoms, strings, variables, integers, reals, objects, and predicates.</p>
<p>This module is concerned with creating and managing terms from native C applications and builtin predicates. See <a class="el" href="syntax_terms.html">Language Syntax - Terms</a> for information on how to create terms in the Plang language. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga83679468f179f7dfbaf22d781e855a7f"></a><!-- doxytag: member="term.h::p_term_print_func" ref="ga83679468f179f7dfbaf22d781e855a7f" args=")(void *data, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The p_term_print_func function pointer type is used by <a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a> to output printf-style formatted data to an output stream.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a>, <a class="el" href="group__term.html#ga44efb541f67a79075fb81f92e41b0e51" title="Prints formatted output according to format to the stdio FILE stream data.">p_term_stdio_print_func()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8h_source.html#l00132">132</a> of file <a class="el" href="term_8h_source.html">term.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga83bf2d0d46b0b4ce885efd5680b00ada"></a><!-- doxytag: member="term.c::p_term_add_clause_first" ref="ga83bf2d0d46b0b4ce885efd5680b00ada" args="(p_context *context, p_term *predicate, p_term *clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_add_clause_first </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>clause</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>clause</em> to <em>predicate</em> within <em>context</em> at the front of the predicate's clause list. </p>
<p>The <em>predicate</em> is assumed to be of type P_TERM_PREDICATE and already dereferenced.</p>
<p>The <em>clause</em> is assumed to be of type P_TERM_CLAUSE to have the same number of arguments as <em>predicate</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a>, <a class="el" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa" title="Adds clause to predicate within context at the end of the predicate&#39;s clause...">p_term_add_clause_last()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01675">1675</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e3ef6b55a045f1409bdb14a6e2bb4aa"></a><!-- doxytag: member="term.c::p_term_add_clause_last" ref="ga0e3ef6b55a045f1409bdb14a6e2bb4aa" args="(p_context *context, p_term *predicate, p_term *clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_add_clause_last </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>clause</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>clause</em> to <em>predicate</em> within <em>context</em> at the end of the predicate's clause list. </p>
<p>The <em>predicate</em> is assumed to be of type P_TERM_PREDICATE and already dereferenced.</p>
<p>The <em>clause</em> is assumed to be of type P_TERM_CLAUSE to have the same number of arguments as <em>predicate</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a>, <a class="el" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada" title="Adds clause to predicate within context at the front of the predicate&#39;s clause...">p_term_add_clause_first()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01712">1712</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab29419821fb3f557f9afad4aa633a137"></a><!-- doxytag: member="term.c::p_term_add_property" ref="gab29419821fb3f557f9afad4aa633a137" args="(p_context *context, p_term *term, p_term *name, p_term *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_add_property </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>name</em> and <em>value</em> as a property to <em>term</em> within <em>context</em>. </p>
<p>Returns non-zero if the property was added, or zero if the parameters are invalid. The <em>term</em> must be an object, and <em>name</em> must be an atom other than "prototype" or "className".</p>
<p>This function does not check if <em>name</em> is already a property on the <em>term</em>, so it should only be used to add new properties.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01192">1192</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafa650631563b752242f2026cbf7bbffb"></a><!-- doxytag: member="term.c::p_term_arg" ref="gafa650631563b752242f2026cbf7bbffb" args="(const p_term *term, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_arg </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the argument at position <em>index</em> within the functor <em>term</em>, or null if <em>term</em> is not a functor or <em>index</em> is out of range. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00963">963</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga85c7d733fc9801d98f35b3e103a18c27"></a><!-- doxytag: member="term.c::p_term_arg_count" ref="ga85c7d733fc9801d98f35b3e103a18c27" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_arg_count </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of arguments for a functor or predicate <em>term</em>, or zero if <em>term</em> is not a functor or predicate. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref()</a>, <a class="el" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00727">727</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabb4aa77bf08b8bc3d0ef94442a017c2a"></a><!-- doxytag: member="term.c::p_term_bind_functor_arg" ref="gabb4aa77bf08b8bc3d0ef94442a017c2a" args="(p_term *term, int index, p_term *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_bind_functor_arg </td>
          <td>(</td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds the argument at <em>index</em> within the specified functor <em>term</em> to <em>value</em>. </p>
<p>Returns non-zero if the bind was successful, or zero if <em>term</em> is not a functor, <em>index</em> is out of range, <em>value</em> is invalid, or the argument has already been bound.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00214">214</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae57ac2b3a143aef55d00866eda241620"></a><!-- doxytag: member="term.c::p_term_bind_variable" ref="gae57ac2b3a143aef55d00866eda241620" args="(p_context *context, p_term *var, p_term *value, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_bind_variable </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds the variable <em>var</em> to <em>value</em>. </p>
<p>Returns non-zero if the bind was successful, or zero if <em>var</em> is already bound, if <em>var</em> is not a variable, or if creating the binding would introduce a circularity into <em>value</em>.</p>
<p>If <em>flags</em> does not contain P_BIND_NO_OCCURS_CHECK, then the bind will fail if <em>var</em> occurs within <em>value</em> as performing the binding will create a circularity.</p>
<p>If <em>flags</em> does not contain P_BIND_NO_RECORD, then the binding will be recorded in <em>context</em> for back-tracking purposes.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable()</a>, <a class="el" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5" title="Unifies term1 with term2 within context.">p_term_unify()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02111">2111</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab2b33e5072cb40115a6a23cb7a1eef9f"></a><!-- doxytag: member="term.c::p_term_class_name_atom" ref="gab2b33e5072cb40115a6a23cb7a1eef9f" args="(p_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_class_name_atom </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the special "className" atom within <em>context</em> that names the class of an object. </p>
<p>Returns the atom with the name "className". This function is equivalent to calling <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> with "className" as the argument, but is more efficient.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, <a class="el" href="group__term.html#gaf9664345cc144da2c249a6d5c245e1e7" title="Returns the special &quot;prototype&quot; atom within context that names the prototype...">p_term_prototype_atom()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00589">589</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9af92fee96e9b92ecca2f952667944b4"></a><!-- doxytag: member="term.c::p_term_clauses_begin" ref="ga9af92fee96e9b92ecca2f952667944b4" args="(const p_term *predicate, const p_term *head, p_term_clause_iter *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_clauses_begin </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term_clause_iter *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts an iteration over the clauses of <em>predicate</em>, using <em>iter</em> as the iteration control information. </p>
<p>If <em>head</em> is not null and the <em>predicate</em> is indexed, then iterate over the best list of clauses that match <em>head</em> according to the index.</p>
<p>Use <a class="el" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a" title="Returns the next clause for the iteration control block iter.">p_term_clauses_next()</a> to iterate through the returned list.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a>, <a class="el" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a" title="Returns the next clause for the iteration control block iter.">p_term_clauses_next()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga96bedcc8fb7e25d93845faa4a78bcd77" title="Returns non-zero if iter has more clauses yet to be iterated.">p_term_clauses_has_more()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01821">1821</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga96bedcc8fb7e25d93845faa4a78bcd77"></a><!-- doxytag: member="term.c::p_term_clauses_has_more" ref="ga96bedcc8fb7e25d93845faa4a78bcd77" args="(const p_term_clause_iter *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_clauses_has_more </td>
          <td>(</td>
          <td class="paramtype">const p_term_clause_iter *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>iter</em> has more clauses yet to be iterated. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin()</a>, <a class="el" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a" title="Returns the next clause for the iteration control block iter.">p_term_clauses_next()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01888">1888</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f12d42eecc40407851784aa0c21db1a"></a><!-- doxytag: member="term.c::p_term_clauses_next" ref="ga9f12d42eecc40407851784aa0c21db1a" args="(p_term_clause_iter *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_clauses_next </td>
          <td>(</td>
          <td class="paramtype">p_term_clause_iter *&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next clause for the iteration control block <em>iter</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin()</a>, <a class="el" href="group__term.html#ga96bedcc8fb7e25d93845faa4a78bcd77" title="Returns non-zero if iter has more clauses yet to be iterated.">p_term_clauses_has_more()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01857">1857</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga885481b7ff34aeb38b88c77aa7d96477"></a><!-- doxytag: member="term.c::p_term_clone" ref="ga885481b7ff34aeb38b88c77aa7d96477" args="(p_context *context, p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_clone </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clones <em>term</em> within <em>context</em> to create a new term that has freshly renamed versions of the variables within <em>term</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5" title="Unifies term1 with term2 within context.">p_term_unify()</a>, <a class="el" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485" title="Unifies term with the renamed head of clause.">p_term_unify_clause()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l03048">3048</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaefa85ee27db354f5e5f4d0b213fde9cf"></a><!-- doxytag: member="term.c::p_term_concat_string" ref="gaefa85ee27db354f5e5f4d0b213fde9cf" args="(p_context *context, p_term *str1, p_term *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_concat_string </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concatenates <em>str1</em> and <em>str2</em> to create a new string. </p>
<p>Returns the concatenated string, or null if <em>str1</em> or <em>str2</em> is not a string.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l03176">3176</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga45ca0be88d01bae8971186c2b048aff8"></a><!-- doxytag: member="term.c::p_term_create_atom" ref="ga45ca0be88d01bae8971186c2b048aff8" args="(p_context *context, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_atom </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an atom within <em>context</em> with the specified <em>name</em>. </p>
<p>Returns the atom term. The same term will be returned every time this function is called for the same <em>name</em> on <em>context</em>. This allows atoms to be quickly compared for equality by comparing their pointers. By comparison, <a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a> creates a new term every time it is called.</p>
<p>Atoms and strings are not unifiable as they are different types of terms. Atoms typically represent identifiers in the program, whereas strings represent human-readable data for the program.</p>
<p>The <em>name</em> should be encoded in the UTF-8 character set. Use <a class="el" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067" title="Creates an atom within context with the len bytes at name as its atom name.">p_term_create_atom_n()</a> for names with embedded NUL's.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gacdd67ab1558d9c6756170fc550bb873c" title="Returns the special &quot;nil&quot; atom that represents the empty list within context...">p_term_nil_atom()</a>, <a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a>, <a class="el" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067" title="Creates an atom within context with the len bytes at name as its atom name.">p_term_create_atom_n()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00300">300</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cdf6cb2a37ac6bd1852f52019243067"></a><!-- doxytag: member="term.c::p_term_create_atom_n" ref="ga7cdf6cb2a37ac6bd1852f52019243067" args="(p_context *context, const char *name, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_atom_n </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an atom within <em>context</em> with the <em>len</em> bytes at <em>name</em> as its atom name. </p>
<p>Returns the atom term. The same term will be returned every time this function is called for the same <em>name</em> on <em>context</em>. This allows atoms to be quickly compared for equality by comparing their pointers. By comparison, <a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a> creates a new term every time it is called.</p>
<p>Atoms and strings are not unifiable as they are different types of terms. Atoms typically represent identifiers in the program, whereas strings represent human-readable data for the program.</p>
<p>The <em>name</em> should be encoded in the UTF-8 character.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00324">324</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadd8c3bb381f75d082b9878a634e043ca"></a><!-- doxytag: member="term.c::p_term_create_class_object" ref="gadd8c3bb381f75d082b9878a634e043ca" args="(p_context *context, p_term *class_name, p_term *prototype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_class_object </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>class_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>prototype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a class object term within <em>context</em> for the class called <em>name</em> with the specified base class <em>prototype</em>. </p>
<p>Returns the class object term. The <em>class_name</em> must be an atom, and the <em>prototype</em> must be an object or null.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01145">1145</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaece9b6033996b5718a7e2f3d360e62ba"></a><!-- doxytag: member="term.c::p_term_create_database" ref="gaece9b6033996b5718a7e2f3d360e62ba" args="(p_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_database </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new database term within <em>context</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga672972a8bcdd8790638276dc8db446f3" title="Adds predicate to database.">p_term_database_add_predicate()</a>, <a class="el" href="group__term.html#gac4f5d5ff89205c3c02945657616a5ea5" title="Returns the predicate in database that is associated with name and arity.">p_term_database_lookup_predicate()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01899">1899</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac191f9077fea60ad8f19220301920b5b"></a><!-- doxytag: member="term.c::p_term_create_dynamic_clause" ref="gac191f9077fea60ad8f19220301920b5b" args="(p_context *context, p_term *head, p_term *body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_dynamic_clause </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new clause within <em>context</em> with the specified <em>head</em> and <em>body</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a>, <a class="el" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada" title="Adds clause to predicate within context at the front of the predicate&#39;s clause...">p_term_add_clause_first()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01499">1499</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2369f8488b027efed7a0aa7e8da73a7"></a><!-- doxytag: member="term.c::p_term_create_functor" ref="gaa2369f8488b027efed7a0aa7e8da73a7" args="(p_context *context, p_term *name, int arg_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_functor </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor term within <em>ontext</em> with the specified <em>name</em> and <em>arg_count</em>. Returns the new functor. </p>
<p>The arguments will be initially unbound. This function should be followed to calls to lc_term_bind_functor_arg() to bind the arguments to specific terms.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga62097d28b6ff5e4d3532b83d5dcbae9c" title="Creates a functor term within ontext with the specified name and the arg_count members...">p_term_create_functor_with_args()</a>, <a class="el" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a" title="Binds the argument at index within the specified functor term to value.">p_term_bind_functor_arg()</a> </dd>
<dd>
<a class="el" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor()</a>, <a class="el" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00173">173</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga62097d28b6ff5e4d3532b83d5dcbae9c"></a><!-- doxytag: member="term.c::p_term_create_functor_with_args" ref="ga62097d28b6ff5e4d3532b83d5dcbae9c" args="(p_context *context, p_term *name, p_term **args, int arg_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_functor_with_args </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term **&nbsp;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor term within <em>ontext</em> with the specified <em>name</em> and the <em>arg_count</em> members of <em>args</em> as arguments. Returns the new functor. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a" title="Binds the argument at index within the specified functor term to value.">p_term_bind_functor_arg()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00234">234</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8aa094355a33451017b76a059771247"></a><!-- doxytag: member="term.c::p_term_create_integer" ref="gaf8aa094355a33451017b76a059771247" args="(p_context *context, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_integer </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an integer within <em>context</em> with the specified <em>value</em>. </p>
<p>Returns the integer term.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga739432392dc4edf3fa58afe559702697" title="Creates a real within context with the specified value.">p_term_create_real()</a>, <a class="el" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c" title="Returns the 32-bit signed integer value within term, or zero if term is not an integer...">p_term_integer_value()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00511">511</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga17481776d0fda576367bae90263f7fe5"></a><!-- doxytag: member="term.c::p_term_create_list" ref="ga17481776d0fda576367bae90263f7fe5" args="(p_context *context, p_term *head, p_term *tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_list </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>tail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a list term from <em>head</em> and <em>tail</em> within <em>context</em>. Returns the new list. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga084f1904b152af8467ab2c7a4dfbb403" title="Returns the head of the specified list term, or null if term is not a list term.">p_term_head()</a>, <a class="el" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0" title="Returns the tail of the specified list term, or null if term is not a list term.">p_term_tail()</a>, <a class="el" href="group__term.html#ga4fe9ffcf5da089493b43bfb0140670b0" title="Sets the tail of list to tail.">p_term_set_tail()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00252">252</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac26b67ff7d5f2ad9e55e92ba74d69179"></a><!-- doxytag: member="term.c::p_term_create_member_name" ref="gac26b67ff7d5f2ad9e55e92ba74d69179" args="(p_context *context, p_term *class_name, p_term *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_member_name </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>class_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an atom which is the concatenation of <em>class_name</em>, <code>::</code>, and <em>name</em>. The atom is created within <em>context</em>. </p>
<p>This function is typically used to create the name of a member predicate within a class.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a>, <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01977">1977</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b517baf3da998736bf7a07ab83004ea"></a><!-- doxytag: member="term.c::p_term_create_member_variable" ref="ga5b517baf3da998736bf7a07ab83004ea" args="(p_context *context, p_term *object, p_term *name, int auto_create)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_member_variable </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>auto_create</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unbound member variable within <em>context</em> that refers to the member <em>name</em> within <em>object</em>. </p>
<p>Returns the member variable term. The <em>name</em> must be an atom.</p>
<p>If <em>auto_create</em> is non-zero, then the member <em>name</em> will be added to the object during unification if it doesn't exist. If <em>auto_create</em> is zero, then unification will fail if the member <em>name</em> does not exist.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object()</a>, <a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00484">484</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga899f47e78554cdb98491716cc3c5072c"></a><!-- doxytag: member="term.c::p_term_create_named_variable" ref="ga899f47e78554cdb98491716cc3c5072c" args="(p_context *context, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_named_variable </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unbound variable within <em>context</em> and associates it with <em>name</em>. </p>
<p>Returns the variable term. The <em>name</em> is for primarily for debugging purposes.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable()</a>, <a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00454">454</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fa6a6d2393a60166fde6df21f76f92d"></a><!-- doxytag: member="term.c::p_term_create_object" ref="ga3fa6a6d2393a60166fde6df21f76f92d" args="(p_context *context, p_term *prototype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_object </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>prototype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an object term within <em>context</em> with the specified class <em>prototype</em>. </p>
<p>Returns the object term. The <em>prototype</em> must be an object.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gadd8c3bb381f75d082b9878a634e043ca" title="Creates a class object term within context for the class called name with the specified...">p_term_create_class_object()</a>, <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> </dd>
<dd>
<a class="el" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207" title="Returns non-zero if term is an object within context and term is not a class object...">p_term_is_instance_object()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01116">1116</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9d06aa5a8ea6c4a8009317ee107b8eb"></a><!-- doxytag: member="term.c::p_term_create_predicate" ref="gaa9d06aa5a8ea6c4a8009317ee107b8eb" args="(p_context *context, p_term *name, int arg_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_predicate </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new predicate instance within <em>context</em> with the specified <em>name</em> and <em>arg_count</em> arguments. </p>
<p>The predicate will initially have no clauses. Use <a class="el" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada" title="Adds clause to predicate within context at the front of the predicate&#39;s clause...">p_term_add_clause_first()</a> and <a class="el" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa" title="Adds clause to predicate within context at the end of the predicate&#39;s clause...">p_term_add_clause_last()</a> to add clauses to the predicate.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gadd8c3bb381f75d082b9878a634e043ca" title="Creates a class object term within context for the class called name with the specified...">p_term_create_class_object()</a>, <a class="el" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada" title="Adds clause to predicate within context at the front of the predicate&#39;s clause...">p_term_add_clause_first()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa" title="Adds clause to predicate within context at the end of the predicate&#39;s clause...">p_term_add_clause_last()</a>, <a class="el" href="group__term.html#gac191f9077fea60ad8f19220301920b5b" title="Creates a new clause within context with the specified head and body.">p_term_create_dynamic_clause()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01469">1469</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga739432392dc4edf3fa58afe559702697"></a><!-- doxytag: member="term.c::p_term_create_real" ref="ga739432392dc4edf3fa58afe559702697" args="(p_context *context, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_real </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a real within <em>context</em> with the specified <em>value</em>. </p>
<p>Returns the real term.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaf8aa094355a33451017b76a059771247" title="Creates an integer within context with the specified value.">p_term_create_integer()</a>, <a class="el" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d" title="Returns the double-precision floating point value within term, or zero if term is...">p_term_real_value()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00536">536</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga07c94636569314c0d219497aa61ab925"></a><!-- doxytag: member="term.c::p_term_create_string" ref="ga07c94636569314c0d219497aa61ab925" args="(p_context *context, const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_string </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string within <em>context</em> with the specified <em>str</em> value. </p>
<p>Returns the string term. Unlike <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, a new term is returned every time this function is called.</p>
<p>Atoms and strings are not unifiable as they are different types of terms. Atoms typically represent identifiers in the program, whereas strings represent human-readable data for the program.</p>
<p>The <em>str</em> should be encoded in the UTF-8 character set. Use <a class="el" href="group__term.html#ga8c7104a045903c1d9c5fa56881e9d9f1" title="Creates a string within context with the len bytes from the specified str buffer...">p_term_create_string_n()</a> for strings with embedded NUL characters.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, <a class="el" href="group__term.html#gaefa85ee27db354f5e5f4d0b213fde9cf" title="Concatenates str1 and str2 to create a new string.">p_term_concat_string()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga8c7104a045903c1d9c5fa56881e9d9f1" title="Creates a string within context with the len bytes from the specified str buffer...">p_term_create_string_n()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00382">382</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c7104a045903c1d9c5fa56881e9d9f1"></a><!-- doxytag: member="term.c::p_term_create_string_n" ref="ga8c7104a045903c1d9c5fa56881e9d9f1" args="(p_context *context, const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_string_n </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string within <em>context</em> with the <em>len</em> bytes from the specified <em>str</em> buffer. </p>
<p>Returns the string term. Unlike <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, a new term is returned every time this function is called.</p>
<p>Atoms and strings are not unifiable as they are different types of terms. Atoms typically represent identifiers in the program, whereas strings represent human-readable data for the program.</p>
<p>The <em>str</em> should be encoded in the UTF-8 character set.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a>, <a class="el" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00413">413</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga770a6d4e622f5e3c1487a7e151c11e96"></a><!-- doxytag: member="term.c::p_term_create_variable" ref="ga770a6d4e622f5e3c1487a7e151c11e96" args="(p_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_create_variable </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unbound variable within <em>context</em>. </p>
<p>Returns the variable term.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga899f47e78554cdb98491716cc3c5072c" title="Creates an unbound variable within context and associates it with name.">p_term_create_named_variable()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00435">435</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga672972a8bcdd8790638276dc8db446f3"></a><!-- doxytag: member="term.c::p_term_database_add_predicate" ref="ga672972a8bcdd8790638276dc8db446f3" args="(p_term *database, p_term *predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_database_add_predicate </td>
          <td>(</td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>predicate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds <em>predicate</em> to <em>database</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gac4f5d5ff89205c3c02945657616a5ea5" title="Returns the predicate in database that is associated with name and arity.">p_term_database_lookup_predicate()</a>, <a class="el" href="group__term.html#gaece9b6033996b5718a7e2f3d360e62ba" title="Returns a new database term within context.">p_term_create_database()</a> </dd>
<dd>
<a class="el" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01916">1916</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac4f5d5ff89205c3c02945657616a5ea5"></a><!-- doxytag: member="term.c::p_term_database_lookup_predicate" ref="gac4f5d5ff89205c3c02945657616a5ea5" args="(p_term *database, p_term *name, int arity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_database_lookup_predicate </td>
          <td>(</td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the predicate in <em>database</em> that is associated with <em>name</em> and <em>arity</em>. </p>
<p>Returns null if the predicate is not present in the local database.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga672972a8bcdd8790638276dc8db446f3" title="Adds predicate to database.">p_term_database_add_predicate()</a>, <a class="el" href="group__term.html#gaece9b6033996b5718a7e2f3d360e62ba" title="Returns a new database term within context.">p_term_create_database()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01945">1945</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3632325e60de70357ababa97655195e0"></a><!-- doxytag: member="term.c::p_term_deref" ref="ga3632325e60de70357ababa97655195e0" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_deref </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences <em>term</em> to resolve bound variables. </p>
<p>Returns the dereferenced version of <em>term</em>, or null if <em>term</em> is null. The result may be a variable if it is unbound.</p>
<p>Dereferencing is needed when terms of type P_TERM_VARIABLE or P_TERM_MEMBER_VARIABLE are bound to other terms during unification. Normally dereferencing is performed automatically by term query functions such as <a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type()</a>, <a class="el" href="group__term.html#ga85c7d733fc9801d98f35b3e103a18c27" title="Returns the number of arguments for a functor or predicate term, or zero if term...">p_term_arg_count()</a>, <a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a>, etc.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type()</a>, <a class="el" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00609">609</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa914c3fb08f1a03a5a8c3cc264273174"></a><!-- doxytag: member="term.c::p_term_deref_member" ref="gaa914c3fb08f1a03a5a8c3cc264273174" args="(p_context *context, p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_deref_member </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences <em>term</em> to resolve bound variables within <em>context</em>. </p>
<p>Returns the dereferenced version of <em>term</em>, or null if <em>term</em> is null. The result may be a variable if it is unbound.</p>
<p>This function differs from <a class="el" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref()</a> in that it will attempt to resolve P_TERM_MEMBER_VARIABLE references, recording their bindings in the trail of <em>context</em> for back-tracking.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type()</a>, <a class="el" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref()</a>, <a class="el" href="group__term.html#ga068ea25e5f02b95da3b353dd2f6b647b" title="Dereferences term to resolve bound variables within context.">p_term_deref_own_member()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00629">629</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga068ea25e5f02b95da3b353dd2f6b647b"></a><!-- doxytag: member="term.c::p_term_deref_own_member" ref="ga068ea25e5f02b95da3b353dd2f6b647b" args="(p_context *context, p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_deref_own_member </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences <em>term</em> to resolve bound variables within <em>context</em>. </p>
<p>Returns the dereferenced version of <em>term</em>, or null if <em>term</em> is null. The result may be a variable if it is unbound.</p>
<p>This function differs from <a class="el" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member()</a> in that it will only resolve member references on the object itself, not on class prototypes. This is typically used in the implementation of variable assignment predicates such as <a class="el" href="group__assignment.html#assign_2">(:=)/2</a> where the class prototype should be read-only with respect to an assignment to an object property.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00673">673</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga24a09ed7b83fb4cb50ab69d94eb9f30c"></a><!-- doxytag: member="dcg.c::p_term_expand_dcg" ref="ga24a09ed7b83fb4cb50ab69d94eb9f30c" args="(p_context *context, p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_expand_dcg </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands the DCG rule in <em>term</em> to a full clause definition for <em>context</em>. </p>
<p>The <em>term</em> must have the functor <a class="el" href="syntax_dcg.html">(--&gt;)/2</a>. The returned term will have the functor <a class="el" href="syntax_terms.html#clause_op_2">(:-)/2</a>. </p>

<p>Definition at line <a class="el" href="dcg_8c_source.html#l00212">212</a> of file <a class="el" href="dcg_8c_source.html">dcg.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad0dd17e897bd22628da3f65d063fca48"></a><!-- doxytag: member="term.c::p_term_functor" ref="gad0dd17e897bd22628da3f65d063fca48" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_functor </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the atom name of the functor or predicate <em>term</em>, or null if <em>term</em> is not a functor or predicate. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00936">936</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga084f1904b152af8467ab2c7a4dfbb403"></a><!-- doxytag: member="term.c::p_term_head" ref="ga084f1904b152af8467ab2c7a4dfbb403" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_head </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the head of the specified list <em>term</em>, or null if <em>term</em> is not a list term. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list()</a>, <a class="el" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0" title="Returns the tail of the specified list term, or null if term is not a list term.">p_term_tail()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01044">1044</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaac80dd2765e7ce6c8b1a209e9fa92a21"></a><!-- doxytag: member="term.c::p_term_inherits" ref="gaac80dd2765e7ce6c8b1a209e9fa92a21" args="(p_context *context, const p_term *term1, const p_term *term2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_inherits </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>term1</em> inherits from <em>term2</em> within <em>context</em>, zero otherwise. </p>
<p>The terms are automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object()</a>, <a class="el" href="group__term.html#gabb40c835640fed369b9ce34375663aab" title="Returns non-zero if term1 is an instance of term2, zero otherwise.">p_term_is_instance_of()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01416">1416</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga78f1318137be1b1714f7c51f61fe139c"></a><!-- doxytag: member="term.c::p_term_integer_value" ref="ga78f1318137be1b1714f7c51f61fe139c" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_integer_value </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the 32-bit signed integer value within <em>term</em>, or zero if <em>term</em> is not an integer term. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gaf8aa094355a33451017b76a059771247" title="Creates an integer within context with the specified value.">p_term_create_integer()</a>, <a class="el" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d" title="Returns the double-precision floating point value within term, or zero if term is...">p_term_real_value()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00988">988</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga93b370531936bcd03ebb61cb17f884de"></a><!-- doxytag: member="term.c::p_term_is_class_object" ref="ga93b370531936bcd03ebb61cb17f884de" args="(p_context *context, const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_is_class_object </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>term</em> is a class object within <em>context</em>, zero otherwise. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21" title="Returns non-zero if term1 inherits from term2 within context, zero otherwise.">p_term_inherits()</a> </dd>
<dd>
<a class="el" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207" title="Returns non-zero if term is an object within context and term is not a class object...">p_term_is_instance_object()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01392">1392</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga473a01257325779b7a0f33deea809325"></a><!-- doxytag: member="term.c::p_term_is_ground" ref="ga473a01257325779b7a0f33deea809325" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_is_ground </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>term</em> is a ground term without any unbound variables; zero otherwise. </p>
<p>Note: objects are considered ground terms, even if their properties contain unbound variables. </p>

<p>Definition at line <a class="el" href="term_8c_source.html#l02893">2893</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae5e5969d3f3b1b70e062436b89f7a207"></a><!-- doxytag: member="term.c::p_term_is_instance_object" ref="gae5e5969d3f3b1b70e062436b89f7a207" args="(p_context *context, const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_is_instance_object </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>term</em> is an object within <em>context</em> and <em>term</em> is not a class object, zero otherwise. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object()</a> </dd>
<dd>
<a class="el" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21" title="Returns non-zero if term1 inherits from term2 within context, zero otherwise.">p_term_inherits()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01367">1367</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabb40c835640fed369b9ce34375663aab"></a><!-- doxytag: member="term.c::p_term_is_instance_of" ref="gabb40c835640fed369b9ce34375663aab" args="(p_context *context, const p_term *term1, const p_term *term2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_is_instance_of </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns non-zero if <em>term1</em> is an instance of <em>term2</em>, zero otherwise. </p>
<p>The terms are automatically dereferenced. The <em>term1</em> must be an instance object, and <em>term2</em> must be a class object.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object()</a>, <a class="el" href="group__term.html#gabb40c835640fed369b9ce34375663aab" title="Returns non-zero if term1 is an instance of term2, zero otherwise.">p_term_is_instance_of()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01447">1447</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacb7b346b3f8f4a9fa31c3285eb615777"></a><!-- doxytag: member="term.c::p_term_name" ref="gacb7b346b3f8f4a9fa31c3285eb615777" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* p_term_name </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the name of the functor, predicate, atom, or variable contained in <em>term</em>, or null if <em>term</em> does not have a name. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type()</a>, <a class="el" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor()</a>, <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> </dd>
<dd>
<a class="el" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length()</a>, <a class="el" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00753">753</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga55a861549e8b42db317a5acec3a7cefb"></a><!-- doxytag: member="term.c::p_term_name_length" ref="ga55a861549e8b42db317a5acec3a7cefb" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t p_term_name_length </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of the name of the functor, predicate, atom, or variable contained in <em>term</em>, or zero if <em>term</em> does not have a name. </p>
<p>The <em>term</em> is automatically dereferenced. The returned length is in bytes. Use <a class="el" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8()</a> to get the length in logical characters.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a>, <a class="el" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00790">790</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab6582e252c8a8333f4b03560f715e5fd"></a><!-- doxytag: member="term.c::p_term_name_length_utf8" ref="gab6582e252c8a8333f4b03560f715e5fd" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t p_term_name_length_utf8 </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the UTF-8 length of the name of the functor, predicate, atom, or variable contained in <em>term</em>, or zero if <em>term</em> does not have a name. </p>
<p>The <em>term</em> is automatically dereferenced. The returned length is in logcial UTF-8 characters. Use <a class="el" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length()</a> to get the length in bytes.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a>, <a class="el" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00885">885</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacdd67ab1558d9c6756170fc550bb873c"></a><!-- doxytag: member="term.c::p_term_nil_atom" ref="gacdd67ab1558d9c6756170fc550bb873c" args="(p_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_nil_atom </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the special "nil" atom that represents the empty list within <em>context</em>. </p>
<p>Returns the atom with the name "[]". This function is equivalent to calling <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> with "[]" as the argument, but is more efficient.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, <a class="el" href="group__term.html#gaf9664345cc144da2c249a6d5c245e1e7" title="Returns the special &quot;prototype&quot; atom within context that names the prototype...">p_term_prototype_atom()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00557">557</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad3aaeba3a153845864e314ecd112a7f2"></a><!-- doxytag: member="term.c::p_term_object" ref="gad3aaeba3a153845864e314ecd112a7f2" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_object </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the object term associated with a member variable reference <em>term</em>, or null if <em>term</em> is not a member variable reference. </p>
<p>The <em>term</em> is automatically dereferenced. The <a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a> function can be used to retrive the name of the member variable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga5b517baf3da998736bf7a07ab83004ea" title="Creates an unbound member variable within context that refers to the member name...">p_term_create_member_variable()</a>, <a class="el" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01092">1092</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadeef4b96990a43a3e397d6c27a07fefd"></a><!-- doxytag: member="term.c::p_term_own_property" ref="gadeef4b96990a43a3e397d6c27a07fefd" args="(p_context *context, const p_term *term, const p_term *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_own_property </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value associated with the property <em>name</em> on <em>term</em> within <em>context</em>, or null if <em>name</em> is not present. </p>
<p>This function does not search prototype objects for <em>name</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> </dd>
<dd>
<a class="el" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property()</a>, <a class="el" href="group__term.html#gacbfe67d6fa4e2295ae305f390f22a715" title="Sets the value associated with the property name on term within context.">p_term_set_own_property()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01283">1283</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e764c6ab93287ce3a163b2947ca7cac"></a><!-- doxytag: member="term.c::p_term_precedes" ref="ga6e764c6ab93287ce3a163b2947ca7cac" args="(p_context *context, const p_term *term1, const p_term *term2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_precedes </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns -1, 0, or 1 depending upon whether <em>term1</em> is less than, equal to, or greater than <em>term2</em> using the "precedes" relationship. The terms are compared within <em>context</em>. </p>
<p>Variables precede all floating-point reals, which precede all integers, which precede all strings, which precede all atoms, which precede all functors (including lists), which precede all objects, which precede all predicates.</p>
<p>Variables, objects, and pedicates are compared by pointer. Reals, integers, strings, and atoms are compared by value. Functors order on arity, then name, and then the arguments from left-to-right. Lists are assumed to have arity 2 and "." as their functor name. </p>

<p>Definition at line <a class="el" href="term_8c_source.html#l02751">2751</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae99be6acb41d73b3193125d854dde48b"></a><!-- doxytag: member="term.c::p_term_print" ref="gae99be6acb41d73b3193125d854dde48b" args="(p_context *context, const p_term *term, p_term_print_func print_func, void *print_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_print </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a>&nbsp;</td>
          <td class="paramname"> <em>print_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>print_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>. </p>
<p>This function is intended for debugging purposes. It may refuse to print some parts of <em>term</em> if the recursion depth is too high.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga44efb541f67a79075fb81f92e41b0e51" title="Prints formatted output according to format to the stdio FILE stream data.">p_term_stdio_print_func()</a>, <a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> </dd>
<dd>
<a class="el" href="group__term.html#gab2dee2140281b77c3ef3d435ae8b4b49" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_unquoted()</a>, <a class="el" href="group__term.html#ga700e9de8d736a8e0c1db26cbdba86db5" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_with_vars()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02682">2682</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab2dee2140281b77c3ef3d435ae8b4b49"></a><!-- doxytag: member="term.c::p_term_print_unquoted" ref="gab2dee2140281b77c3ef3d435ae8b4b49" args="(p_context *context, const p_term *term, p_term_print_func print_func, void *print_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_print_unquoted </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a>&nbsp;</td>
          <td class="paramname"> <em>print_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>print_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>. </p>
<p>If <em>term</em> is an atom or string, then it will be printed without quoting. Otherwise, the behavior is the same as <a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a>.</p>
<p>This function is intended for debugging purposes. It may refuse to print some parts of <em>term</em> if the recursion depth is too high.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a>, <a class="el" href="group__term.html#ga700e9de8d736a8e0c1db26cbdba86db5" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_with_vars()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02701">2701</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga700e9de8d736a8e0c1db26cbdba86db5"></a><!-- doxytag: member="term.c::p_term_print_with_vars" ref="ga700e9de8d736a8e0c1db26cbdba86db5" args="(p_context *context, const p_term *term, p_term_print_func print_func, void *print_data, const p_term *vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_print_with_vars </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a>&nbsp;</td>
          <td class="paramname"> <em>print_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>print_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>vars</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints <em>term</em> within <em>context</em> to the output stream defined by <em>print_func</em> and <em>print_data</em>. </p>
<p>The <em>vars</em> parameters should be a list of <em>Name</em> = <em>Var</em> terms. Whenever <em>Var</em> is encountered in <em>term</em> as an unbound variable, it will be printed as <em>Name</em>. All other unbound variables are printed as "_N".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a>, <a class="el" href="group__term.html#gab2dee2140281b77c3ef3d435ae8b4b49" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_unquoted()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02726">2726</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad505c00c9f70ad0429f87fc58a189b73"></a><!-- doxytag: member="term.c::p_term_property" ref="gad505c00c9f70ad0429f87fc58a189b73" args="(p_context *context, const p_term *term, const p_term *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_property </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value associated with the property <em>name</em> on <em>term</em> within <em>context</em>, or null if <em>name</em> is not present. </p>
<p>If the property <em>name</em> is not present on <em>term</em>, then the prototype object of <em>term</em> will be consulted for the property.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> </dd>
<dd>
<a class="el" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd" title="Returns the value associated with the property name on term within context, or null...">p_term_own_property()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01239">1239</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9664345cc144da2c249a6d5c245e1e7"></a><!-- doxytag: member="term.c::p_term_prototype_atom" ref="gaf9664345cc144da2c249a6d5c245e1e7" args="(p_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_prototype_atom </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the special "prototype" atom within <em>context</em> that names the prototype for an object. </p>
<p>Returns the atom with the name "prototype". This function is equivalent to calling <a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a> with "prototype" as the argument, but is more efficient.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom()</a>, <a class="el" href="group__term.html#gab2b33e5072cb40115a6a23cb7a1eef9f" title="Returns the special &quot;className&quot; atom within context that names the class...">p_term_class_name_atom()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00573">573</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga995e38a5ad30ed0cb8b0c4e30028d39d"></a><!-- doxytag: member="term.c::p_term_real_value" ref="ga995e38a5ad30ed0cb8b0c4e30028d39d" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double p_term_real_value </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the double-precision floating point value within <em>term</em>, or zero if <em>term</em> is not a real term. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga739432392dc4edf3fa58afe559702697" title="Creates a real within context with the specified value.">p_term_create_real()</a>, <a class="el" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c" title="Returns the 32-bit signed integer value within term, or zero if term is not an integer...">p_term_integer_value()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01021">1021</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacbfe67d6fa4e2295ae305f390f22a715"></a><!-- doxytag: member="term.c::p_term_set_own_property" ref="gacbfe67d6fa4e2295ae305f390f22a715" args="(p_context *context, p_term *term, p_term *name, p_term *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_set_own_property </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the <em>value</em> associated with the property <em>name</em> on <em>term</em> within <em>context</em>. </p>
<p>This function does not search prototype objects for <em>name</em>. If <em>name</em> does not exist, then <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> will be used to add a new property.</p>
<p>Returns non-zero if the property was added, or zero if the parameters are invalid. The <em>term</em> must be an object, and <em>name</em> must be an atom other than "prototype" or "className".</p>
<p>This function should be used with care because the change to the property <em>name</em> is not back-trackable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object()</a>, <a class="el" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property()</a> </dd>
<dd>
<a class="el" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property()</a>, <a class="el" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd" title="Returns the value associated with the property name on term within context, or null...">p_term_own_property()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01328">1328</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fe9ffcf5da089493b43bfb0140670b0"></a><!-- doxytag: member="term.c::p_term_set_tail" ref="ga4fe9ffcf5da089493b43bfb0140670b0" args="(p_term *list, p_term *tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_set_tail </td>
          <td>(</td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>tail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the tail of <em>list</em> to <em>tail</em>. </p>
<p>This function is intended for use by parsers that build lists incrementally from the top down, where the tail of <em>list</em> had previously been set to null.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list()</a>, <a class="el" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0" title="Returns the tail of the specified list term, or null if term is not a list term.">p_term_tail()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00274">274</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab6d3f3332d1fae9b74d14d5b01052b27"></a><!-- doxytag: member="sort.c::p_term_sort" ref="gab6d3f3332d1fae9b74d14d5b01052b27" args="(p_context *context, p_term *list, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_sort </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts <em>list</em> according to the <a class="el" href="group__term__comparison.html#term_precedes">term precedes</a> relationship. </p>
<p>Returns the sorted version of the list, or null if some part of <em>list</em> is not a valid list. If <em>list</em> ends in a variable tail, then the list will be sorted and the returned list will end in nil.</p>
<p>The <em>flags</em> indicate how to compare keys within the <em>list</em>. The supported flags are P_SORT_ASCENDING, P_SORT_DESCENDING, P_SORT_KEYED, P_SORT_REVERSE_KEYED, and P_SORT_UNIQUE.</p>
<p>The sorting algorithm used is merge sort, which will preserve the original ordering of elements that have identical keys.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac" title="Returns -1, 0, or 1 depending upon whether term1 is less than, equal to, or greater...">p_term_precedes()</a> </dd></dl>

<p>Definition at line <a class="el" href="sort_8c_source.html#l00208">208</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga44efb541f67a79075fb81f92e41b0e51"></a><!-- doxytag: member="term.c::p_term_stdio_print_func" ref="ga44efb541f67a79075fb81f92e41b0e51" args="(void *data, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p_term_stdio_print_func </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints formatted output according to <em>format</em> to the stdio FILE stream <em>data</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print()</a>, <a class="el" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02330">2330</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac5ab644da0bd5f5d69d73721e38a838a"></a><!-- doxytag: member="term.c::p_term_strcmp" ref="gac5ab644da0bd5f5d69d73721e38a838a" args="(const p_term *str1, const p_term *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_strcmp </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares <em>str1</em> and <em>str2</em> and returns a comparison code. </p>
<p>The <em>str1</em> and <em>str2</em> terms are assumed to be either atoms or strings. The result is undefined if this assumption does not hold.</p>
<p>This comparison function is safe on strings that have embedded NUL characters as it uses memcmp() internally.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l03117">3117</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab2dd3010fa91261ac29d46a2b85974e0"></a><!-- doxytag: member="term.c::p_term_tail" ref="gab2dd3010fa91261ac29d46a2b85974e0" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_tail </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the tail of the specified list <em>term</em>, or null if <em>term</em> is not a list term. </p>
<p>The <em>term</em> is automatically dereferenced.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list()</a>, <a class="el" href="group__term.html#ga084f1904b152af8467ab2c7a4dfbb403" title="Returns the head of the specified list term, or null if term is not a list term.">p_term_head()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l01067">1067</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga412cae4cf75b595d8d8a64d9b06a0495"></a><!-- doxytag: member="term.c::p_term_type" ref="ga412cae4cf75b595d8d8a64d9b06a0495" args="(const p_term *term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_type </td>
          <td>(</td>
          <td class="paramtype">const p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the type of <em>term</em> after dereferencing it. </p>
<p>Returns one of P_TERM_FUNCTOR, P_TERM_VARIABLE, etc, or P_TERM_INVALID if <em>term</em> is null.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l00709">709</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab4b9c1afcd3a2f29d451535f72dd71e5"></a><!-- doxytag: member="term.c::p_term_unify" ref="gab4b9c1afcd3a2f29d451535f72dd71e5" args="(p_context *context, p_term *term1, p_term *term2, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int p_term_unify </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unifies <em>term1</em> with <em>term2</em> within <em>context</em>. </p>
<p>Returns non-zero if the unify was successful, or zero on failure. The <em>flags</em> control how variables are bound.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable()</a>, <a class="el" href="group__term.html#ga885481b7ff34aeb38b88c77aa7d96477" title="Clones term within context to create a new term that has freshly renamed versions...">p_term_clone()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l02303">2303</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga58aa1d3f87e8a158158cf7639d9f5485"></a><!-- doxytag: member="term.c::p_term_unify_clause" ref="ga58aa1d3f87e8a158158cf7639d9f5485" args="(p_context *context, p_term *term, p_term *clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_unify_clause </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>clause</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unifies <em>term</em> with the renamed head of <em>clause</em>. </p>
<p>If the unification succeeds, then this function returns the renamed body of <em>clause</em>. Returns null if the unification fails.</p>
<p>The return value will be the atom <code>true</code> if <em>clause</em> does not have a body and <em>clause</em> unifies with <em>term</em>.</p>
<p>The name of the functor in the head of <em>clause</em> is ignored when unifying against <em>term</em>, which makes this function suitable for matching against member predicates that have qualified names.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5" title="Unifies term1 with term2 within context.">p_term_unify()</a>, <a class="el" href="group__term.html#ga885481b7ff34aeb38b88c77aa7d96477" title="Clones term within context to create a new term that has freshly renamed versions...">p_term_clone()</a> </dd></dl>

<p>Definition at line <a class="el" href="term_8c_source.html#l03076">3076</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga146e5df50fb750f07ae1a2c71e852086"></a><!-- doxytag: member="term.c::p_term_witness" ref="ga146e5df50fb750f07ae1a2c71e852086" args="(p_context *context, p_term *term, p_term **subgoal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p_term* p_term_witness </td>
          <td>(</td>
          <td class="paramtype">p_context *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term *&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">p_term **&nbsp;</td>
          <td class="paramname"> <em>subgoal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of the free variables in <em>term</em>, where each free variable occurs only once in the list. </p>
<p>The argument <em>subgoal</em> will be set to the bagof-subgoal of <em>term</em>.</p>
<p>This function is used to help implement the <a class="el" href="group__module__findall.html#bagof_3">bagof/3</a> and <a class="el" href="group__module__findall.html#setof_3">setof/3</a> predicates. </p>

<p>Definition at line <a class="el" href="term_8c_source.html#l03260">3260</a> of file <a class="el" href="term_8c_source.html">term.c</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
