<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Language Syntax - Input-only arguments</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="syntax_input_only">Language Syntax - Input-only arguments </a></h1><p>Arguments to a predicate can be prefixed with the <b>in</b> keyword to declare them as "input-only". When a value is passed to an input-only argument, variables in the argument can be bound to sub-terms within the value, but variables within the value cannot be bound to sub-terms within the argument.</p>
<p>An example should help explain why input-only arguments are needed. The following predicate expands expressions in its first argument using the normal rules of arithmetic:</p>
<div class="fragment"><pre class="fragment">expand(A * (B + C), A * B + A * C).
expand((A + B) * C, A * C + B * C).
</pre></div><p>If we were to call <code>expand((X + Y) * Z, Solution)</code>, then the predicate will respond with the following solutions:</p>
<div class="fragment"><pre class="fragment">(X + Y) * B + (X + Y) * C   where Z = B + C
X * Z + Y * Z
</pre></div><p>Clearly, only the second of these is what we intended with the predicate. The issue is that we want variables in the clause arguments (A, B, and C) to be bound, but not variables in the value we passed in (X, Y, and Z). We can solve this problem using input-only arguments:</p>
<div class="fragment"><pre class="fragment">expand(in A * (B + C), A * B + A * C).
expand(in (A + B) * C, A * C + B * C).
</pre></div><p>By introducing the <b>in</b> keyword in the clause definitions, we can force the clause to fail if variables in the incoming value would need to be bound for the unification to succeed. A similar effect can be achieved in a clause body using <a class="el" href="group__unification.html#unify_one_way_2">unify_one_way/2</a>.</p>
<p>Traditional Prolog implementations often have a predicate that can freeze or lock a term to prevent unification of its variables. The drawback with that approach is that it requires the caller to know the internal details of the callee and then take steps to protect its terms from unexpected unification. This breaks encapsulation. With Plang's approach, the callee declares the input-only constraints, preserving encapsulation. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
