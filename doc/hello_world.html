<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Hello World</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="hello_world">Hello World </a></h1><h2><a class="anchor" id="hello_intro">
Introduction</a></h2>
<p>Plang uses a C-style syntax for statements, and a Prolog-style syntax for expressions (usually called "terms"). The simplest application is the traditional "Hello World". We will use the <a class="el" href="group__class__stdout.html">stdout</a> module to print strings:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).

main(Args)
{
    stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);
}
</pre></div><p>We can run this with the <code>plang</code> front-end to get the expected result (<code>$</code> indicates a command that is typed at the operating system's command-line):</p>
<div class="fragment"><pre class="fragment">$ plang hello1.lp
Hello World!
</pre></div><p>The ".lp" file extension is recommended for Plang source files. It stands for "Logic Program".</p>
<p>See the <a class="el" href="plang_manpage.html">manual page</a> for the <code>plang</code> front-end for more information on running applications with it.</p>
<h2><a class="anchor" id="hello_cmdline">
Processing command-line arguments</a></h2>
<p>A more complex example uses an <a class="el" href="group__logic__and__control.html#if_stmt">if</a> statement to perform different actions depending upon an argument:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).

main(Args)
{
    <span class="keywordflow">if</span> (<span class="stringliteral">&quot;--bye&quot;</span> in Args)
        stdout::writeln(<span class="stringliteral">&quot;Bye World!&quot;</span>);
    <span class="keywordflow">else</span>
        stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);
}
</pre></div><p>Running our second version, we get the following:</p>
<div class="fragment"><pre class="fragment">$ plang hello2.lp
Hello World!
$ plang hello2.lp --bye
Bye World!
</pre></div><p>As can be seen, the command-line arguments are passed to the Plang application. Let's dump them to see what we get:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).

main(Args)
{
    stdout::writeln(<span class="stringliteral">&quot;Args: &quot;</span> + Args);
    <span class="keywordflow">if</span> (<span class="stringliteral">&quot;--bye&quot;</span> in Args)
        stdout::writeln(<span class="stringliteral">&quot;Bye World!&quot;</span>);
    <span class="keywordflow">else</span>
        stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);
}
</pre></div><div class="fragment"><pre class="fragment">$ plang hello3.lp --bye
Args: [<span class="stringliteral">&quot;hello3.lp&quot;</span>, <span class="stringliteral">&quot;--bye&quot;</span>]
Bye World!
</pre></div><h2><a class="anchor" id="hello_search">
Searching for solutions</a></h2>
<p>The real power of a logic programming language comes with back-tracking, or the ability to search for multiple solutions amongst many alternatives. Let's start by establishing some simple facts about the people that exist in our world:</p>
 <div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).
:- <span class="keyword">import</span>(findall).

person(<span class="stringliteral">&quot;Frank&quot;</span>).
person(<span class="stringliteral">&quot;Mary&quot;</span>).
person(<span class="stringliteral">&quot;George&quot;</span>).
person(<span class="stringliteral">&quot;Amy&quot;</span>).
</pre></div></p>
<p>We can dump a list of all people by finding all solutions to the query "Is P a person?":</p>
<p><div class="fragment"><pre class="fragment">main(Args)
{
    findall(P, person(P), People);
    stdout::writeln(<span class="stringliteral">&quot;People: &quot;</span> + People);
}
</pre></div></p>
<div class="fragment"><pre class="fragment">$ plang hello4.lp
People: [<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>]
</pre></div><p>The <a class="el" href="group__module__findall.html#findall_3">findall/3</a> predicate finds all solutions to the query in the order in which they are listed in the fact database. Let's now add some more rules for the relationship "A is a parent
of B":</p>
 <div class="fragment"><pre class="fragment">parent(<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;Mary&quot;</span>).
parent(<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>).
parent(<span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>).
</pre></div></p>
<p>We can then ask for a list of all Frank's children as follows:</p>
<p><div class="fragment"><pre class="fragment">main(Args)
{
    findall(C, parent(<span class="stringliteral">&quot;Frank&quot;</span>, C), Children);
    stdout::writeln(<span class="stringliteral">&quot;Frank&apos;s children: &quot;</span> + Children);
}
</pre></div></p>
<div class="fragment"><pre class="fragment">$ plang hello5.lp
Frank<span class="stringliteral">&apos;s children: [&quot;Mary&quot;, &quot;George&quot;]</span>
</pre></div><p>So far all we have done is assert basic facts into the database. We now want to do some inferencing and ask "Is A a descendent of B?". This time we define a predicate that represents the rule:</p>
 <div class="fragment"><pre class="fragment">descendent(C, P)
{
    parent(P, C);
}
descendent(GC, P)
{
    parent(P, C);
    descendent(GC, C);
}
</pre></div></p>
<p>The first clause indicates that we can satisfy the <code>descendent</code> relation if the second person is a parent of the first. The second clause indicates that the relation is also satisfied if we can find an intermediate child of the second person that the first person is a descendent of. In Prolog we would have written this as:</p>
<div class="fragment"><pre class="fragment">descendent(C, P) :- parent(P, C).
descendent(GC, P) :- parent(P, C), descendent(GC, C).
</pre></div><p>In Plang, as in Prolog, variables are identifiers that start with an upper case letter. The engine will search for any variable binding that satisfies the rules. Any binding that does not satisfy the rules is discarded and another rule is tried.</p>
<p>To complete our example, we query for Frank's descendents:</p>
<p><div class="fragment"><pre class="fragment">main(Args)
{
    findall(D, descendent(D, <span class="stringliteral">&quot;Frank&quot;</span>), Descendents);
    stdout::writeln(<span class="stringliteral">&quot;Frank&apos;s descendents: &quot;</span> + Descendents);
}
</pre></div></p>
<div class="fragment"><pre class="fragment">$ plang hello6.lp
Frank<span class="stringliteral">&apos;s descendents: [&quot;Mary&quot;, &quot;George&quot;, &quot;Amy&quot;]</span>
</pre></div><p>The full source code for the example to date is:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).
:- <span class="keyword">import</span>(findall).

person(<span class="stringliteral">&quot;Frank&quot;</span>).
person(<span class="stringliteral">&quot;Mary&quot;</span>).
person(<span class="stringliteral">&quot;George&quot;</span>).
person(<span class="stringliteral">&quot;Amy&quot;</span>).

parent(<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;Mary&quot;</span>).
parent(<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>).
parent(<span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>).

descendent(C, P)
{
    parent(P, C);
}
descendent(GC, P)
{
    parent(P, C);
    descendent(GC, C);
}

main(Args)
{
    findall(P, person(P), People);
    stdout::writeln(<span class="stringliteral">&quot;People: &quot;</span> + People);

    findall(C, parent(<span class="stringliteral">&quot;Frank&quot;</span>, C), Children);
    stdout::writeln(<span class="stringliteral">&quot;Frank&apos;s children: &quot;</span> + Children);

    findall(D, descendent(D, <span class="stringliteral">&quot;Frank&quot;</span>), Descendents);
    stdout::writeln(<span class="stringliteral">&quot;Frank&apos;s descendents: &quot;</span> + Descendents);
}
</pre></div><div class="fragment"><pre class="fragment">$ plang hello7.lp
People: [<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>]
Frank<span class="stringliteral">&apos;s children: [&quot;Mary&quot;, &quot;George&quot;]</span>
<span class="stringliteral">Frank&apos;</span>s descendents: [<span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>]
</pre></div><h2><a class="anchor" id="hello_shell">
Using the Plang shell</a></h2>
<p>We can use the <code>plang</code> front-end in manual mode to directly query the database. First we will load our "hello7" example into the shell:</p>
<div class="fragment"><pre class="fragment">Plang version 0.0.1
Copyright (c) 2011 Southern Storm Software, Pty Ltd.
Type <span class="stringliteral">&apos;help.&apos;</span> <span class="keywordflow">for</span> help

| ?- consult(<span class="stringliteral">&quot;hello7.lp&quot;</span>).

yes
</pre></div><p>All of the predicates that we defined previously are now available. However, the <code>main</code> predicate is not run automatically. Let's query for members of the <code>parent</code> relationship:</p>
<div class="fragment"><pre class="fragment">| ?- parent(A, B).

A = <span class="stringliteral">&quot;Frank&quot;</span>
B = <span class="stringliteral">&quot;Mary&quot;</span> ?
</pre></div><p>The shell has returned the first solution that it found. The "?" prompt is asking us if we want to find another solution or stop. If we type ';', it will find another solution:</p>
<div class="fragment"><pre class="fragment">| ?- parent(A, B).

A = <span class="stringliteral">&quot;Frank&quot;</span>
B = <span class="stringliteral">&quot;Mary&quot;</span> ? ;

A = <span class="stringliteral">&quot;Frank&quot;</span>
B = <span class="stringliteral">&quot;George&quot;</span> ?
</pre></div><p>We can continue typing ';' until the shell says "no" (meaning that there are no more solutions), or hit Enter to abort the search. Let's ask a question that the database doesn't know the answer to:</p>
<div class="fragment"><pre class="fragment">| ?- descendent(D, <span class="stringliteral">&quot;Amy&quot;</span>).

no
</pre></div><p>We can even run the <code>main</code> predicate directly:</p>
<div class="fragment"><pre class="fragment">| ?- main(_).
People: [<span class="stringliteral">&quot;Frank&quot;</span>, <span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>]
Frank<span class="stringliteral">&apos;s children: [&quot;Mary&quot;, &quot;George&quot;]</span>
<span class="stringliteral">Frank&apos;</span>s descendents: [<span class="stringliteral">&quot;Mary&quot;</span>, <span class="stringliteral">&quot;George&quot;</span>, <span class="stringliteral">&quot;Amy&quot;</span>]

yes
</pre></div><p>The "_" variable is special - it indicates an anonymous variable with no specific name or value. Since our <code>main</code> predicate does not process arguments, "_" is good enough for our purposes.</p>
<p>Finally, we exit the shell:</p>
<div class="fragment"><pre class="fragment">| ?- exit.
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
