<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Language syntax - Terms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="syntax_terms">Language syntax - Terms </a></h1><p>Terms are the fundamental knowledge representation tool in Plang. Everything, including programs, are ultimately represented as tagged term structures. Terms have one of the following forms:</p>
<ul>
<li><a class="el" href="syntax_terms.html#syntax_atoms">Atoms</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_numbers">Numbers</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_strings">Strings</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_variables">Variables</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_functors">Functors</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_lists">Lists</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_operators">Operators</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_objects">Objects</a> </li>
<li><a class="el" href="syntax_terms.html#syntax_predicates">Predicates</a></li>
</ul>
<div class="fragment"><pre class="fragment">term --&gt; atom.
term --&gt; integer.
term --&gt; <span class="keywordtype">float</span>.
term --&gt; <span class="keywordtype">string</span>.
term --&gt; variable.
term --&gt; functor.
term --&gt; list.
term --&gt; <span class="keyword">operator</span>.
term --&gt; member_variable.
term --&gt; member_call.
term --&gt; <span class="stringliteral">&quot;(&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>.
</pre></div><h2><a class="anchor" id="syntax_atoms">
Atoms</a></h2>
<p>Atoms are alphanumeric identifiers in the program that represent unique constant values. Examples include:</p>
<ul>
<li><code>true</code>, <code>fail</code>, <code>foobar</code>, <code>fooBar</code>, <code>'Foo Bar'</code>, <code>'hi\nthere'</code>, <code>person::age</code>, <code>''</code></li>
</ul>
<p>Atoms have two forms syntactic forms: unquoted and quoted. Unquoted atoms start with a lower case letter, followed by any combination of lower or upper case letters, digits, underscores, and "::" scope markers. Quoted atoms start and end with a single quote and can contain any characters in between.</p>
<div class="fragment"><pre class="fragment">atom --&gt; lower_letter.
atom --&gt; lower_letter, identifier_tail.
atom --&gt; <span class="stringliteral">&quot;&apos;&quot;</span>, squote_string, <span class="stringliteral">&quot;&apos;&quot;</span>.

identifier_tail --&gt; identifier_char.
identifier_tail --&gt; identifier_tail, identifier_char.

identifier_char --&gt; lower_letter || upper_letter || dec_digit.
identifier_char --&gt; <span class="stringliteral">&quot;_&quot;</span> || <span class="stringliteral">&quot;::&quot;</span>.

lower_letter --&gt; <span class="stringliteral">&quot;a&quot;</span> || <span class="stringliteral">&quot;b&quot;</span> || ... || <span class="stringliteral">&quot;z&quot;</span>.
upper_letter --&gt; <span class="stringliteral">&quot;A&quot;</span> || <span class="stringliteral">&quot;B&quot;</span> || ... || <span class="stringliteral">&quot;Z&quot;</span>.
dec_digit --&gt; <span class="stringliteral">&quot;0&quot;</span> || <span class="stringliteral">&quot;1&quot;</span> || ... || <span class="stringliteral">&quot;9&quot;</span>.
</pre></div><p>The scope marker "::" is a convention only - it does not indicate namespacing in the same sense as C++. Plang uses it in its system library to prefix similar predicates with the module or class name. For example, "person::age" may be the name of a method called "age" within the "person" class, or the name of a global predicate within the "person" module. It is up to the user which interpretation (class or module) makes most sense in their application.</p>
<p>Atoms with the same name are considered identical when compared with <a class="el" href="group__term__comparison.html#term_eq_2">(==)/2</a> or unified with <a class="el" href="group__unification.html#unify_2">(=)/2.</a>Atoms are not comparable with <a class="el" href="syntax_terms.html#syntax_strings">Strings</a> without first converting them with <a class="el" href="group__arithmetic.html#atom_name_2">atom_name/2</a>.</p>
<h2><a class="anchor" id="syntax_numbers">
Numbers</a></h2>
<p>Integers may be represented in decimal, hexadecimal, or octal as in C, with or without a "-" prefix:</p>
<ul>
<li><code>42</code>, <code>0x2A</code>, <code>052</code>, <code>-42</code>, <code>-0x2A</code>, <code>-052</code>.</li>
</ul>
<p>Note: if a "-" prefix is present, then it must not be followed by whitespace before the digits. The sequence <code>- 42</code> is a unary functor application, equivalent to <code>'-'(42)</code>. See the description of <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a> for more information.</p>
<div class="fragment"><pre class="fragment">integer --&gt; dec_integer.
integer --&gt; hex_integer.
integer --&gt; oct_integer.
integer --&gt; <span class="stringliteral">&quot;-&quot;</span>, dec_integer.
integer --&gt; <span class="stringliteral">&quot;-&quot;</span>, hex_integer.
integer --&gt; <span class="stringliteral">&quot;-&quot;</span>, oct_integer.

dec_integer --&gt; dec_digit.
dec_integer --&gt; dec_integer, dec_digit.

hex_integer --&gt; <span class="stringliteral">&quot;0x&quot;</span>, hex_digit.
hex_integer --&gt; <span class="stringliteral">&quot;0X&quot;</span>, hex_digit.
hex_integer --&gt; hex_integer, hex_digit.

hex_digit --&gt; <span class="stringliteral">&quot;0&quot;</span> || <span class="stringliteral">&quot;1&quot;</span> || ... || <span class="stringliteral">&quot;9&quot;</span>.
hex_digit --&gt; <span class="stringliteral">&quot;A&quot;</span> || <span class="stringliteral">&quot;B&quot;</span> || ... || <span class="stringliteral">&quot;F&quot;</span>.
hex_digit --&gt; <span class="stringliteral">&quot;a&quot;</span> || <span class="stringliteral">&quot;b&quot;</span> || ... || <span class="stringliteral">&quot;f&quot;</span>.

oct_integer --&gt; <span class="stringliteral">&quot;0&quot;</span>, oct_digit.
oct_integer --&gt; oct_integer, oct_digit.

oct_digit --&gt; <span class="stringliteral">&quot;0&quot;</span> || <span class="stringliteral">&quot;1&quot;</span> || ... || <span class="stringliteral">&quot;7&quot;</span>.
</pre></div><p>Integers can also be expressed as character constants. The constant <code>0'A'</code> is equal to the integer 65.</p>
<div class="fragment"><pre class="fragment">integer --&gt; <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;&apos;&quot;</span>, squote_string, <span class="stringliteral">&quot;&apos;&quot;</span>. <span class="comment">// string must be 1 character</span>
</pre></div><p>Note: <a class="el" href="group__predicates.html#standard">Standard Prolog</a> expresses character constants as <code>0'A</code> without a trailing quote. This looks unbalanced and is less obvious as to where a multi-byte character ends.</p>
<p>Floating-point numbers are represented in the usual way:</p>
<ul>
<li>23.0, -42.5, 2e13</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">float</span> --&gt; float_value.
float --&gt; <span class="stringliteral">&quot;-&quot;</span> float_value.

float_value --&gt; dec_integer, <span class="stringliteral">&quot;.&quot;</span>, dec_integer.
float_value --&gt; dec_integer, <span class="stringliteral">&quot;.&quot;</span>, dec_integer, exponent.
float_value --&gt; dec_integer, exponent.

exponent --&gt; exponent_char, dec_integer.
exponent --&gt; exponent_char, <span class="stringliteral">&quot;-&quot;</span>, dec_integer.
exponent --&gt; exponent_char, <span class="stringliteral">&quot;+&quot;</span>, dec_integer.

exponent_char --&gt; <span class="stringliteral">&quot;e&quot;</span> || <span class="stringliteral">&quot;E&quot;</span>.
</pre></div><p>Plang only supports double-precision floating-point values as represented by the C <code>double</code> type on the underlying system.</p>
<p>Numbers with the same value are considered identical when compared with <a class="el" href="group__term__comparison.html#term_eq_2">(==)/2</a> or unified with <a class="el" href="group__unification.html#unify_2">(=)/2.</a>However, integers and floating-point values are not directly comparable this way; the comparison <code>3 == 3.0</code> will fail. Use <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a> for numeric comparison instead.</p>
<h2><a class="anchor" id="syntax_strings">
Strings</a></h2>
<p>Strings typically represent human-readable text for program input and ouput. They start and end with a double-quote character and can contain any other character in-between.</p>
<ul>
<li><code>"Hello World!"</code>, <code>"foobar"</code>, <code>"\n"</code>, <code>""</code></li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">string</span> --&gt; <span class="stringliteral">&quot;\&quot;&quot;</span>, dquote_string, <span class="stringliteral">&quot;\&quot;&quot;</span>.

dquote_string --&gt; dquote_char.
dquote_string --&gt; dquote_string, dquote_char.

squote_string --&gt; squote_char.
squote_string --&gt; squote_string, squote_char.

dquote_char --&gt; ordinary_char || escape_char || <span class="stringliteral">&quot;&apos;&quot;</span>.
squote_char --&gt; ordinary_char || escape_char || <span class="stringliteral">&quot;\&quot;&quot;</span>.

ordinary_char --&gt; any character except <span class="stringliteral">&quot;\&quot;&quot;</span>, <span class="stringliteral">&quot;&apos;&quot;</span>, <span class="stringliteral">&quot;\\&quot;</span>, or a newline.

escape_char --&gt; <span class="stringliteral">&quot;\\x&quot;</span>, hex_digit, hex_digit.    <span class="comment">// raw byte value</span>

<span class="comment">// Unicode characters, which will be converted into UTF-8.</span>
escape_char --&gt; <span class="stringliteral">&quot;\\u&quot;</span>, hex_digit, hex_digit, hex_digit, hex_digit.
escape_char --&gt; <span class="stringliteral">&quot;\\U&quot;</span>, hex_digit, hex_digit, hex_digit, hex_digit,
                       hex_digit, hex_digit, hex_digit, hex_digit.

escape_char --&gt; <span class="stringliteral">&quot;\\&quot;</span>, control_char.
escape_char --&gt; <span class="stringliteral">&quot;\\&quot;</span>, other_char.       <span class="comment">// same as other_char</span>

control_char --&gt; <span class="stringliteral">&quot;n&quot;</span> | <span class="stringliteral">&quot;r&quot;</span> | <span class="stringliteral">&quot;t&quot;</span> | <span class="stringliteral">&quot;f&quot;</span> | <span class="stringliteral">&quot;v&quot;</span> | <span class="stringliteral">&quot;0&quot;</span>.
other_char --&gt; any character except a control_char.
</pre></div><p>Strings and atoms are similar in that they both represent textual values. However, their storage is managed differently. When an atom is created, a unique storage area is assigned to the atom that will persist until the program stops executing. This allows atoms to be very quickly compared for equality by simply comparing their pointers. Strings on the other hand are temporary. When there are no further references to the string, the Plang garbage collector will discard the string's storage. The general rule is that program identifiers and constants should be represented as atoms, but program data and human-readable text should be represented as strings.</p>
<p>The <a class="el" href="group__arithmetic.html#atom_name_2">atom_name/2</a> predicate can be used to convert back and forth between atoms and strings.</p>
<h2><a class="anchor" id="syntax_variables">
Variables</a></h2>
<p>Variables are alphanumeric identifiers in the program that represent parameters and temporary values during the program's execution. Variable names must start with an upper-case letter or an underscore. Examples include:</p>
<ul>
<li><code>A</code>, <code>FooBar</code>, <code>_foo_bar</code>, <code>_</code> </li>
</ul>
<div class="fragment"><pre class="fragment">variable --&gt; upper_letter.
variable --&gt; upper_letter, identifier_tail.
variable --&gt; <span class="stringliteral">&quot;_&quot;</span>.
variable --&gt; <span class="stringliteral">&quot;_&quot;</span>, identifier_tail.
</pre></div><p>Variables with the same name that occur in a larger term refer to the same storage. For example, <code>f(X, g(X, Y))</code> contains two variables <code>X</code> and <code>Y</code>. If the variable X was to be bound to the atom <code>a</code>, then the term would transform into <code>f(a, g(a, Y))</code>.</p>
<p>The variable named "_" is special in that every occurrence in a term will create a new anonymous variable whose name is unknown. The term <code>f(_, g(_, _))</code> contains three variables, whereas <code>f(_A, g(_A, _A))</code> contains only one. The "_" variable is typically used to mark an unused parameter whose value is unimportant to a predicate.</p>
<p>Variable binding is a primary feature of Plang, as in Prolog. Variables are bound during unification to make terms equal. Consider the following code that is using the <a class="el" href="group__unification.html#unify_2">(=)/2</a> unification operator:</p>
<div class="fragment"><pre class="fragment">f(X, g(X, Y)) = f(a, g(Z, W))
</pre></div><p>When executed, unification attempts to make the two sides of the "=" operator identical. In this case, the following variable bindings will be performed:</p>
<div class="fragment"><pre class="fragment">X = a
Z = a
Y = W
</pre></div><p>If the two sides cannot be made identical then unification fails, the variables bindings are undone, and the program will backtrack to an alternative execution path to find a different solution. The following is an example of a unification that will fail because X cannot be bound to both <code>a</code> and <code>b:</code> </p>
<div class="fragment"><pre class="fragment">f(X, g(X, Y)) = f(a, g(b, W))
</pre></div><p>A variable will keep its bound value until a fail and backtrack occurs. Thus, <a class="el" href="group__unification.html#unify_2">(=)/2</a> is not the exactly the same as variable assignment in other programming languages. Subsequent attempts to change the variable to a different value with <a class="el" href="group__unification.html#unify_2">(=)/2</a> will fail.</p>
<p>Plang provides separate <a class="el" href="group__assignment.html#assign_2">(:=)/2</a> and <a class="el" href="group__assignment.html#bt_assign_2">(:==)/2</a> operators to perform destructive and back-trackable variable assignment in the traditional sense. However, these assignment operators should be used with care as they can break the logical consistency of a solution search.</p>
<h2><a class="anchor" id="syntax_functors">
Functors</a></h2>
<p>Functors collect up one or more argument terms and tag them with a functor name. The functor name itself must be an atom. In the following examples, <code>f</code> and <code>g</code> are functor names:</p>
<ul>
<li><code>f(a)</code> </li>
<li><code>f(X, g(X, Y))</code> </li>
<li><code>f(X, f(Y, f(Z, end)))</code></li>
</ul>
<p>As can be seen, a functor term is written as an atom, followed by a left-parenthesis, a comma-separated list of argument terms, and a right-parenthesis.</p>
<div class="fragment"><pre class="fragment">functor --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, arguments, <span class="stringliteral">&quot;)&quot;</span>.
arguments --&gt; term.
arguments --&gt; <span class="stringliteral">&quot;in&quot;</span>, term.
arguments --&gt; arguments, <span class="stringliteral">&quot;,&quot;</span>, term.
arguments --&gt; arguments, <span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;in&quot;</span>, term.
</pre></div><p>It is typical to refer to a functor by both its atom name and its <em>arity</em>, or number of arguments. The functor <b>f/2</b> names functor terms whose atom name is <code>f</code> and which have 2 arguments. The same functor name can have multiple arities, and each arity creates a distinct functor name.</p>
<p>Atoms can be referred to as having "arity 0", especially when they are used to name predicates that do not have any parameters. In Prolog, it is invalid to write a term as <code>name()</code>, but we allow it in Plang:</p>
<div class="fragment"><pre class="fragment">functor --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, <span class="stringliteral">&quot;)&quot;</span>.     <span class="comment">// same as the atom on its own</span>
</pre></div><p>By convention, the parentheses should only appear after the atom if the atom is being used as the name of a called predicate, such as in the call to <code>print_prompt</code> below:</p>
<div class="fragment"><pre class="fragment">mainloop()
{
    <span class="keywordflow">do</span> {
        print_prompt();
        read_command(Cmd);
        ...
    } <span class="keywordflow">while</span> (Cmd != quit);
}
</pre></div><p>Note that the atom <code>quit</code> was not followed by parentheses, even though it would technically be allowed. That is because the atom is being used as a constant, not a predicate call. Adding parentheses would make the code confusing - it would look like a function call.</p>
<h2><a class="anchor" id="syntax_lists">
Lists</a></h2>
<p>Lists are a special kind of functor term for representing organized collections of terms. The following are some examples of lists:</p>
<ul>
<li><code>[f(a, X), b, g(Y)]</code>, <code>[H|T]</code>, <code>[]</code></li>
</ul>
<p><code>[]</code> is an atom that represents an empty list.</p>
<div class="fragment"><pre class="fragment">list --&gt; <span class="stringliteral">&quot;[&quot;</span>, list_members, <span class="stringliteral">&quot;]&quot;</span>.
list --&gt; <span class="stringliteral">&quot;[&quot;</span>, list_members, <span class="stringliteral">&quot;|&quot;</span>, term, <span class="stringliteral">&quot;]&quot;</span>.

list_members --&gt; term.
list_members --&gt; list_members <span class="stringliteral">&quot;,&quot;</span> term.

atom --&gt; <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>.
</pre></div><p>Lists can also be represented with the <a class="el" href="group__create__and__decompose.html#list_cons_2">(.)/2</a> functor, although doing so is rare:</p>
<ul>
<li><code>'.'(f(a, X), '.'(b, '.'(g(Y), [])))</code></li>
</ul>
<p>The <a class="el" href="group__logic__and__control.html#for_stmt">for</a> statement can be used to iterate over all members of a list:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (X in List) {
    ...
}
</pre></div><h2><a class="anchor" id="syntax_operators">
Operators</a></h2>
<p>The prefix form of functors can be awkward when referring to mathematical operations. The form <code>A + B</code> is preferable to the prefixed equivalent of <code>'+'(A, B)</code>. Plang includes a large selection of operators. Unlike Prolog however, the list of operators is fixed by the Plang language. This choice was deliberate, to make it possible to write an efficient parser.</p>
<p>Operators have an associated priority and associativity. The higher the priority, the less tightly the operator binds to its arguments (+ has a higher priority than * for example). Associativity may be one of the following:</p>
<ul>
<li><code>xfx</code> - binary infix operator, non-associative. </li>
<li><code>yfx</code> - binary infix operator, left-associative. </li>
<li><code>xfy</code> - binary infix operator, right-associative. </li>
<li><code>fx</code> - unary prefix operator, non-associative. </li>
<li><code>fy</code> - unary prefix operator, right-associative.</li>
</ul>
<p>There are presently no unary postfix operators (<code>xf</code> and <code>yf</code> associativity) in Plang.</p>
<table cellspacing="0" cellpadding="3" border="1">
<tr>
<td><p>Operator </p>
</td><td><p>Priority </p>
</td><td><p>Associativity </p>
</td><td><p>Example  </p>
</td></tr>
<tr>
<td><p><a class="el" href="syntax_terms.html#clause_op_2">(:-)/2</a>, <b>(--&gt;)/2</b> </p>
</td><td><p>1200 </p>
</td><td><p><code>xfx</code> </p>
</td><td><p><code>noun_phrase --&gt; det, words::noun.</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__directives.html#initialization_1">(?-)/1</a> </p>
</td><td><p>1200 </p>
</td><td><p><code>fx</code> </p>
</td><td><p><code>:- import(stdout).</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a> </p>
</td><td><p>1130 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>A &lt;=&gt; B</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a> </p>
</td><td><p>1120 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>A =&gt; B</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a> </p>
</td><td><p>1100 </p>
</td><td><p><code>xfy</code> </p>
</td><td><p><code>if (f(X) || g(X)) { ... }</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#if_stmt">(-&gt;)/2</a> </p>
</td><td><p>1050 </p>
</td><td><p><code>xfy</code> </p>
</td><td><p><code>(A -&gt; B || C)</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#logical_and_2">(,)/2</a>, <a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a> </p>
</td><td><p>1000 </p>
</td><td><p><code>xfy</code> </p>
</td><td><p><code>if (f(X) &amp;&amp; g(X)) { ... }</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a> </p>
</td><td><p>900 </p>
</td><td><p><code>fy</code> </p>
</td><td><p><code>if (!f(X)) { ... }</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__unification.html#unify_2">(=)/2</a>, <a class="el" href="group__unification.html#not_unifiable_2">(!=)/2</a>, <a class="el" href="group__create__and__decompose.html#univ_2">(=..)/2</a>, <a class="el" href="group__logic__and__control.html#in_2">in/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>f(X, b) = f(a, Y)</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__term__comparison.html#term_eq_2">(==)/2</a>, <a class="el" href="group__term__comparison.html#term_ne_2">(!==)/2</a>, <a class="el" href="group__term__comparison.html#term_lt_2">(@&lt;)/2</a>, <a class="el" href="group__term__comparison.html#term_le_2">(@&lt;=)/2</a>, <a class="el" href="group__term__comparison.html#term_gt_2">(@&gt;)/2</a>, <a class="el" href="group__term__comparison.html#term_ge_2">(@&gt;=)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X !== Y</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a>, <a class="el" href="group__arithmetic.html#is_2">is/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X is Y + Z * W</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__assignment.html#assign_2">(:=)/2</a>, <a class="el" href="group__assignment.html#num_assign_2">(::=)/2</a>, <a class="el" href="group__assignment.html#bt_assign_2">(:==)/2</a>, <a class="el" href="group__assignment.html#bt_num_assign_2">(::==)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X ::= Y + Z * W</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a> </p>
</td><td><p>500 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X is Y + Z</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a>, <a class="el" href="group__arithmetic.html#func_rem_2">rem/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">mod/2</a> </p>
</td><td><p>400 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X is Y * Z</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a> </p>
</td><td><p>400 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><code>X is Y &gt;&gt; Z</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_pow_2">(**)/2</a> </p>
</td><td><p>200 </p>
</td><td><p><code>xfx</code> </p>
</td><td><p><code>X is Y ** Z</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a> </p>
</td><td><p>200 </p>
</td><td><p><code>xfy</code> </p>
</td><td><p><code>X is Y ^ Z</code>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a> </p>
</td><td><p>200 </p>
</td><td><p><code>fy</code> </p>
</td><td><p><code>X is - Z</code>  </p>
</td></tr>
</table>
<p>Plang also includes some legacy operator names for compatibility with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new operator names are the recommended spelling:</p>
<table cellspacing="0" cellpadding="3" border="1">
<tr>
<td><p>Legacy Operator </p>
</td><td><p>Priority </p>
</td><td><p>Associativity </p>
</td><td><p>New Operator </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__logic__and__control.html#not_provable_1">(\+)/1</a> </p>
</td><td><p>900 </p>
</td><td><p><code>fy</code> </p>
</td><td><p><a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__unification.html#not_unifiable_2">(\=)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><a class="el" href="group__unification.html#not_unifiable_2">(!=)/2</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__term__comparison.html#term_ne_2">(\==)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><a class="el" href="group__term__comparison.html#term_ne_2">(!==)/2</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__term__comparison.html#term_le_2">(@=&lt;)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><a class="el" href="group__term__comparison.html#term_le_2">(@&lt;=)/2</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#num_ne_2">(=\=)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#num_le_2">(=&lt;)/2</a> </p>
</td><td><p>700 </p>
</td><td><p><code>yfx</code> </p>
</td><td><p><a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="group__arithmetic.html#func_not_1">(\)/1</a> </p>
</td><td><p>200 </p>
</td><td><p><code>fy</code> </p>
</td><td><p><a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>  </p>
</td></tr>
</table>
<p>The <b>(;)/2</b> and <b>(//)/2</b> operators from Prolog are not supported in Plang because they clash with <code>;</code> used as a statement separator and <code>//</code> used to start comment blocks. Use <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a> and <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a> instead.</p>
<p>The term syntax is augmented as follows:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">operator</span> --&gt; prefix_operator, term.
operator --&gt; term, infix_operator, term.
</pre></div><p>If an operator with a higher priority is used as an argument to an operator with a lower priority, then the term must be bracketed:</p>
<div class="fragment"><pre class="fragment">X is (Y + Z) * W
</pre></div><h2><a class="anchor" id="syntax_objects">
Objects</a></h2>
<p>Plang borrows the concept of prototype-based inheritance from <a href="http://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> to create an object model. Objects are collections of properties with names and values. A distinguished property called <code>prototype</code> is used to establish inheritance relationships between objects.</p>
<p>Objects are further subdivided into class objects and instance objects. Class objects are declared using the <a class="el" href="group__classes__and__objects.html#decl_class">class</a> keyword:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>vehicle
{
    var wheels
}

<span class="keyword">class </span>passenger_car : vehicle
{
    var make, model

    <span class="keyword">new</span>(Make, Model)
    {
        Self.wheels = 4;
        Self.make = Make;
        Self.model = Model;
    }
}
</pre></div><p>In the above example, the <code>prototype</code> property on the <code>passenger_car</code> class object will be the <code>vehicle</code> class object. The <code>vehicle</code> class object will not have a <code>prototype</code> property because it is at the root of an inheritance hierarchy. Class objects also have a <code>className</code> property. At runtime, the relationships between the class objects can be established as follows:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class</span>(passenger_car, CarClass);
<span class="keyword">class</span>(vehicle, VehicleClass);

CarClass.prototype == VehicleClass;
CarClass.className == passenger_car;

VehicleClass.className == vehicle;
</pre></div><p>Instance objects are created with the <a class="el" href="group__classes__and__objects.html#new_object_3">new</a> keyword:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">new</span> passenger_car(Car, <span class="stringliteral">&quot;MegaCarz&quot;</span>, <span class="stringliteral">&quot;FastKar 2000&quot;</span>);

Car.make == <span class="stringliteral">&quot;MegaCarz&quot;</span>;
Car.prototype == CarClass;
Car.className == passenger_car;
</pre></div><p>As can be seen, the <code>Car</code> object instance has inherited the value of the <code>className</code> property from its class object. This becomes important when we introduce member predicates:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>vehicle
{
    var owner, wheels

    transferOwnership(NewOwner)
    {
        Self.owner := NewOwner;
    }
}

Car.transferOwnership(<span class="stringliteral">&quot;Fred&quot;</span>);
</pre></div><p>The <code>transferOwnership</code> property is like any other property on the <code>vehicle</code> class object. If <code>passenger_car</code> had its own implementation of the <code>transferOwnership</code> predicate, then it would override the one for <code>vehicle</code>.</p>
<p>All member predicates, including constructors, are passed a hidden first argument that contains the object that is being operated on. This argument will be available to the member predicate as the variable <code>Self</code>.</p>
<p>In the examples above we sometimes used <a class="el" href="group__unification.html#unify_2">(=)/2</a> to assign values to object properties and other times we used <a class="el" href="group__assignment.html#assign_2">(:=)/2</a>. Why the difference?</p>
<p>When an object is first constructed with <a class="el" href="group__classes__and__objects.html#new_object_3">new</a>, its <code>var</code> properties will be set to unbound variables. The constructor can then unify those variables on the <code>Self</code> object with their initial values.</p>
<p>Later, when we want to change the value of a property to something else we cannot unify it again. Instead, we need to assign a new value using <a class="el" href="group__assignment.html#assign_2">(:=)/2</a>. Because such assignment is destructive, the new value will persist across back-tracking. If you wish the property to automatically revert upon back-tracking, then use <a class="el" href="group__assignment.html#bt_assign_2">(:==)/2</a> instead.</p>
<p>The only new term syntax that is introduced is for member variable references and member calls:</p>
<div class="fragment"><pre class="fragment">member_variable --&gt; variable, <span class="stringliteral">&quot;.&quot;</span>, atom.
member_variable --&gt; member_variable, <span class="stringliteral">&quot;.&quot;</span>, atom.

member_call --&gt; member_variable, <span class="stringliteral">&quot;(&quot;</span>, arguments, <span class="stringliteral">&quot;)&quot;</span>.
member_call --&gt; member_variable, <span class="stringliteral">&quot;(&quot;</span>, <span class="stringliteral">&quot;)&quot;</span>.
</pre></div><p>Note: when "." is used for member variable references, it must not be followed by whitespace. A "." followed by whitespace is intepreted as an end of predicate marker.</p>
<p>See the documentation for the <a class="el" href="group__classes__and__objects.html#decl_class">class</a> and <a class="el" href="group__classes__and__objects.html#new_object_3">new</a> keywords for more information on declaring and creating objects.</p>
<h2><a class="anchor" id="syntax_predicates">
Predicates</a></h2>
<p><a class="anchor" id="clause_op_2"></a></p>
<p>Predicates are declared at the top level of a Plang source file, and consist of a head term and an optional predicate body. For example:</p>
<div class="fragment"><pre class="fragment">parent(fred, mary).
parent(mary, bob).

ancestor(A, B)
{
    parent(A, B);
}
ancestor(A, B)
{
    parent(A, C);
    ancestor(C, B);
}
</pre></div><p>The <b>(:-)/2</b> operator from <a class="el" href="group__predicates.html#standard">Standard Prolog</a> is not supported for predicate definition in Plang, except for dynamic predicates that are created with <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a> and <a class="el" href="group__clause__handling.html#assertz_1">assertz/1</a>:</p>
<div class="fragment"><pre class="fragment">create_rules()
{
    assertz((ancestor(A, B) :- parent(A, B)));
    assertz((ancestor(A, B) :- parent(A, C), ancestor(C, B)));
}
</pre></div><p>The formal syntax for predicates follows:</p>
<div class="fragment"><pre class="fragment">predicate --&gt; predicate_head, confidence, <span class="stringliteral">&quot;.&quot;</span>.
predicate --&gt; predicate_head, confidence, compound_statement.

predicate_head --&gt; atom.
predicate_head --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, arguments, <span class="stringliteral">&quot;)&quot;</span>.
predicate_head --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, <span class="stringliteral">&quot;)&quot;</span>.

confidence --&gt; [].
confidence --&gt; <span class="stringliteral">&quot;&lt;&lt;&quot;</span>, integer, <span class="stringliteral">&quot;&gt;&gt;&quot;</span>.
confidence --&gt; <span class="stringliteral">&quot;&lt;&lt;&quot;</span>, float, <span class="stringliteral">&quot;&gt;&gt;&quot;</span>.
</pre></div><p>Member predicates within a class can also be declared as <code>static</code>, <code>abstract</code>, or instance constructors:</p>
<div class="fragment"><pre class="fragment">member_predicate --&gt; predicate.
member_predicate --&gt; <span class="stringliteral">&quot;static&quot;</span>, predicate.
member_predicate --&gt; <span class="stringliteral">&quot;abstract&quot;</span>, predicate_head, <span class="stringliteral">&quot;.&quot;</span>.
member_predicate --&gt; constructor_head, confidence, <span class="stringliteral">&quot;.&quot;</span>.
member_predicate --&gt; constructor_head, confidence, compound_statement.

constructor_head --&gt; <span class="stringliteral">&quot;new&quot;</span>.
constructor_head --&gt; <span class="stringliteral">&quot;new&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, arguments, <span class="stringliteral">&quot;)&quot;</span>.
constructor_head --&gt; <span class="stringliteral">&quot;new&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, <span class="stringliteral">&quot;)&quot;</span>.
</pre></div><p>Abstract member predicates will throw <code>existence_error(member_predicate, <em>Pred</em>)</code> at runtime if called. This is the same as what will happen if the member predicate is not defined at all. Explicit declaration can be useful for documentation purposes and to override a member in the parent class to redefine it as abstract.</p>
<p>Predicates can be converted into first-class terms using <a class="el" href="group__type__testing.html#predicate_2">predicate/2</a>.</p>
<p>Constant confidence values, for reasoning with <a class="el" href="group__fuzzy__logic.html">fuzzy logic</a>, can be specified just after the head of a predicate:</p>
<div class="fragment"><pre class="fragment">cold(10) &lt;&lt;0.7&gt;&gt;.
</pre></div><p>See also: <a class="el" href="syntax_input_only.html">Input-only arguments</a>, <a class="el" href="group__fuzzy__logic.html">fuzzy_logic</a>. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
