<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Plang execution model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="execution_model">Plang execution model </a></h1><h2><a class="anchor" id="execution_model_goals">
Goal exectution</a></h2>
<p>Plang uses a continuation-based model for implementing <a class="el" href="group__context.html#gab12e40bc06e3affd8f064f8efdb9cc33" title="Executes goal against the current database state of context.">p_context_execute_goal()</a>. The mathematical foundations we adopted can be found in section 2 of the following paper:</p>
<dl class="user"><dt><b></b></dt><dd>E. Jahier, M. Ducasse, O. Ridoux, <a href="ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-00-6-1-jahier.ps.Z">"Specifying Prolog Trace Models with a Continuation Semantics"</a>, LOPSTR 2000, Tenth International Workshop on Logic-based Synthesis and Transformation, 2000.</dd></dl>
<p>Mathematically, a goal is a function that operates on three continuations: success, fail, and cut-fail. Evaluating the goal produces a new set of success, fail, and cut-fail continuations. In Plang, goals are represented as nodes in a graph, with the success and cut-fail continuations represented as outgoing links to other nodes. The fail continuation is a pointer to a node that is stored in the execution state with the pointer to the current node.</p>
<p>The execution state has two node pointers: the current node to execute, and the "fail point" node. A goal node operates on this state and outputs two new values for the current node and "fail point".</p>
<p>Some examples of goal execution:</p>
<ul>
<li>If the goal is atomic and deterministic (succeeds or fails but does not backtrack internally):<ul>
<li>If the goal succeeds, then the current node is set to "success", and the "fail point" is left unchanged.</li>
<li>If the goal fails, then a back-track occurs (see below).</li>
</ul>
</li>
<li>If the goal is (A , B), then new nodes are created for A and B. The "cut fail point" for the new nodes are set to the "cut fail
  point" of (A, B). The "success" link on the A node is set to point at the B node, and the "success" link on the B node is set to the "success" link of (A, B). The current node is replaced with the A node and the "fail point" is left unchanged.</li>
<li>If the goal is !, then the "fail point" is set to the "cut fail point" of the node, and then the current node is set to "success".</li>
<li>If the goal is (A || B), then two new nodes are created for A and B that have the same "success" link as (A || B). The current node is replaced with the A node. Both A and B's "cut fail point" links are set to the current "fail point". The "fail point" is set to B.</li>
<li>Alternative clauses for a predicate are handled in a similar fashion to (A || B), with the B node searching for a new clause amongst the remaining clauses.</li>
</ul>
<p>Upon back-tracking, the current node is set to the "fail point", and the "fail point" is set to the "cut fail point" of the new current node. If "fail point" is NULL when back-tracking is requested, then a top-level goal failure has occurred.</p>
<p>Top-level goals are prepared for execution by creating a new current node for the goal G. The "success" and "cut fail point" links on the goal node are set to NULL. The "fail point" is also set to NULL.</p>
<p>A top-level goal succeeds once the current node becomes NULL (because a "success" link was encountered that was NULL). The top-level goal is re-executed by setting the current node to "fail point", and "fail point" to the "cut fail point" of the new current node. All solutions are exhausted once "fail point" becomes NULL on a top-level goal.</p>
<h2><a class="anchor" id="execution_model_exceptions">
Exceptions</a></h2>
<p>The paper above does not describe the handling of <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a> and <a class="el" href="group__logic__and__control.html#throw_1">throw/1</a> in a Prolog environment. We extend the mechanism by adding a "catch point" continuation link to the execution state. When a catch/3 goal is executed, the "catch point" link is set to point at the catch/3 goal, with the previous "catch point" saved in the new catch point node.</p>
<p>When a throw/1 is executed, a backtrack is performed to the "cut fail point" of the catch node. Execution proceeds from the catch point with the recovery goal if the catch term matches. If the catch term does not match, the process repeats to find the next-outer "catch point" node. If the "catch point" is NULL, then the top-level goal has finished with a thrown error.</p>
<p>The current "catch point" is saved in fail nodes so that it can be restored upon backtracking. The "catch point" also needs to be restored when the body of the catch/3 succeeds. We handle this by inserting a special <code>$$pop_catch</code> goal as the success continuation for the body goal.</p>
<h2><a class="anchor" id="execution_model_indexing">
Clause indexing</a></h2>
<p>The standard semantics for predicate execution is to try each clause in turn until one succeeds. Upon backtracking, the next succeeding clause is chosen, until there are no more clauses. This can be very inefficient if there are lots of clauses associated with a predicate. For example, evaluating <code>X == Y</code> with the following predicate will involve trying a lot of irrelevant clauses first:</p>
<div class="fragment"><pre class="fragment">eval(A + B, Result)  { ... }    <span class="comment">// clause 1</span>
eval(A - B, Result)  { ... }    <span class="comment">// clause 2</span>
eval(A * B, Result)  { ... }    <span class="comment">// clause 3</span>
eval(A / B, Result)  { ... }    <span class="comment">// clause 4</span>
eval(-A, Result)     { ... }    <span class="comment">// clause 5</span>
eval(A &amp;&amp; B, Result) { ... }    <span class="comment">// clause 6</span>
eval(A || B, Result) { ... }    <span class="comment">// clause 7</span>
eval(!A, Result)     { ... }    <span class="comment">// clause 8</span>
eval(A == B, Result) { ... }    <span class="comment">// clause 9</span>
...
eval(A, Result)      { ... }    <span class="comment">// clause N</span>
</pre></div><p>The usual solution to this performance problem is <em>indexing</em>. One of the arguments is used to create an index that maps an incoming value to a list of clauses that are most likely to match that kind of value. In the case of <b>(==)/2</b>, the index will list clauses 9 and N (a variable matches any incoming value). Now only those two clauses need to be tried when we evaluate <code>X == Y</code>; we can safely assume that all other clauses will fail without trying them explicitly.</p>
<p>Plang indexes predicates with more than four clauses. When the fifth clause is added, Plang inspects the current clauses to determine the best argument for indexing. The best argument is that which changes the most from clause to clause; usually the first, but could be the second for class member predicates (the first argument to class member predicates is the <code>Self</code> variable).</p>
<p>After the index argument has been chosen all of the clauses are inserted into a red-black tree. The tree maps the top-level functor, atom, string, or number in the index argument to a list of clauses that matches that top-level type. Clauses without a top-level type (usually those that have a variable in the index argument) are added to a separate list.</p>
<p>When a predicate is called, the top-level type of the incoming argument value is used to look up the relevant clause list in the red-black tree. This list is merged with the separate variable clause list to produce the list of clauses to be tried in order. If the incoming argument value is a variable, then all clauses in the predicate are tried in order.</p>
<h2><a class="anchor" id="execution_model_compile">
Compilation of clauses</a></h2>
<p>Plang compiles clauses into a modified form of the <a href="http://en.wikipedia.org/wiki/Warren_abstract_machine">Warren Abstract Machine</a> (or "WAM"). We will only skim over the details in this page. The best reference on the WAM is the following book:</p>
<dl class="user"><dt><b></b></dt><dd>Hassan AÃ¯t-Kaci, <a href="http://wambook.sourceforge.net/">"Warren's
Abstract Machine: A Tutorial Reconstruction"</a>, 1999.</dd></dl>
<p>The following modifications to the traditional WAM are noteworthy:</p>
<ul>
<li>Plang's term representation uses structure sharing instead of structure copying, which requires some modifications to how the read/write mode flag is implemented. </li>
<li>Clause Indexing is performed with red-black trees as described in the previous section; WAM instructions such as <code>switch_on_term</code> and <code>switch_on_constant</code> are not used. </li>
<li>Both static and dynamic predicates are compiled, with slight differences in the compiled forms.</li>
</ul>
<p>To illustrate the differences between static and dynamic compiled forms, consider the following example clause:</p>
<div class="fragment"><pre class="fragment">a(5, f(Y, b))
{
    c(X);
    d(X, Y);
}
</pre></div><p>The dynamic version of the clause is compiled into the following code, which performs <code>get</code> instructions on each of the arguments, and a <code>put</code> instruction for the clause body:</p>
<div class="fragment"><pre class="fragment">get_constant 5, X0
get_functor f/2, X1
unify_variable X2
unify_atom b
put_functor <span class="charliteral">&apos;,&apos;</span>/2, X3
set_functor c/1, X4
set_variable X5
reset_argument X3, 1
set_functor d/2, X4
set_value X5
set_value X2
<span class="keywordflow">return</span> X3
</pre></div><p>Dynamic clauses are executed by <a class="el" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485" title="Unifies term with the renamed head of clause.">p_term_unify_clause()</a> and return the body as a callable term to be executed by the engine. Dynamic clauses complete deterministically with either success or failure. Non-determinism is provided by the caller when it executes the body term. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
