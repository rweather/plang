<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Builtin predicates - Directives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Builtin predicates - Directives</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Directives are executed while a source file is being loaded to modify environmental parameters, adjust language flags, etc. Two kinds of directives are provided: immediate and deferred. Immediate directives are immediately executed when the source file is parsed, but before predicates in the source file are defined into the database. The following are examples:</p>
<div class="fragment"><pre class="fragment"> :- <span class="keyword">import</span>(stdout).
 :- dynamic(person/1).
</pre></div><p>Deferred directives are executed after the source file has been parsed and the predicates have been defined into the database. The following is an example:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>fridge {
     ...
     open()
     {
         ...
     }
 }

 ?- {
     <span class="keyword">new</span> fridge(F);
     F.open();
 }
</pre></div><p>After the directive is executed, the Plang engine will execute a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> and <a class="el" href="group__logic__and__control.html#fail_0">fail/0</a> to backtrack to the original system state. The only permanent modifications to the system state will be in the form of side-effects.</p>
<p>Directives may also be called as regular builtin predicates during normal program execution.</p>
<p><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__directives.html#initialization_1">(?-)/1</a>, <a class="el" href="group__directives.html#consult_1">consult/1</a>, <a class="el" href="group__directives.html#dynamic_1">dynamic/1</a>, <a class="el" href="group__directives.html#import_1">import/1</a>, <a class="el" href="group__directives.html#initialization_1">initialization/1</a>, <a class="el" href="group__directives.html#load_library_1">load_library/1</a></p>
<hr/>
 <a class="anchor" id="directive_1"></a> <b>(:-)/1</b> - execute a directive immediately while a source file is being loaded.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>:-</b> <em>Directive</em>.</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Directive</em> immediately when it is encountered in the source file during loading. After execution of the <em>Directive</em>, an implicit <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> and <a class="el" href="group__logic__and__control.html#fail_0">fail/0</a> are performed to return the system to its original state before the call. The only permanent modifications to the system state will be in the form of side-effects in <em>Directive</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <em>Directive</em> is limited to an atom or a functor call by the Plang parser. More complex terms are not permitted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <b>(:-)/1</b> is called during normal program execution instead of within a directive, it will have the same effect as <a class="el" href="group__logic__and__control.html#call_1">call/1</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> :- <span class="keyword">import</span>(stdout).
 :- dynamic(person/1).
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__directives.html#initialization_1">(?-)/1</a>, <a class="el" href="group__logic__and__control.html#call_1">call/1</a>, <a class="el" href="group__directives.html#import_1">import/1</a></dd></dl>
<hr/>
 <a class="anchor" id="consult_1"></a> <b>consult/1</b> - consults the contents of a source file.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>:-</b> <b>consult</b>(<em>Filename</em>).</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <em>Filename</em> must be an atom or string, whose name refers to a Plang source file. If the file exists, it will be parsed and loaded into the current execution context. Fails if <em>Filename</em> could be loaded due to an error. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>consult/1</b> directive differs from <a class="el" href="group__directives.html#import_1">import/1</a> in that it will load the file again even if it has been loaded previously. It also does not search the import search path for <em>Filename</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Filename</em> is a variable. </li>
<li><code>type_error(atom_or_string, <em>Filename</em>)</code> - <em>Filename</em> is not an atom or string. </li>
<li><code>existence_error(file, <em>Filename</em>)</code> - <em>Filename</em> could not be opened.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> :- consult(<span class="stringliteral">&quot;myapp.lp&quot;</span>).
 :- consult(X).               instantiation_error
 :- consult(1.5).             type_error(atom_or_string, 1.5)
 :- consult(<span class="stringliteral">&quot;not_found.lp&quot;</span>).  existence_error(file, <span class="stringliteral">&quot;not_found.lp&quot;</span>)
 :- consult(<span class="stringliteral">&quot;../dir/file.lp&quot;</span>).
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a> has a directive called <b>include/1</b> that performs a similar function to <b>consult/1</b>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__directives.html#import_1">import/1</a></dd></dl>
<hr/>
 <a class="anchor" id="dynamic_1"></a> <b>dynamic/1</b> - marks a user-defined predicate as dynamic.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>:-</b> <b>dynamic</b>(<em>Pred</em>).</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Marks the predicate associated with the predicate indicator <em>Pred</em> as dynamic. The indicator should have the form <em>Name</em> / <em>Arity</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clauses of a dynamic predicate will not be compiled. This is intended for predicates that are created dynamically in the database at runtime with <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a> and friends.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - one of <em>Pred</em>, <em>Name</em>, or <em>Arity</em>, is a variable. </li>
<li><code>type_error(predicate_indicator, <em>Pred</em>)</code> - <em>Pred</em> does not have the form <em>Name</em> / <em>Arity</em>. </li>
<li><code>type_error(integer, <em>Arity</em>)</code> - <em>Arity</em> is not an integer. </li>
<li><code>type_error(atom, <em>Name</em>)</code> - <em>Name</em> is not an atom. </li>
<li><code>domain_error(not_less_than_zero, <em>Arity</em>)</code> - <em>Arity</em> is less than zero. </li>
<li><code>permission_error(modify, static_procedure, <em>Pred</em>)</code> - <em>Pred</em> is a builtin or compiled predicate.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> dynamic(userdef/3)       succeeds
 dynamic(Pred)            instantiation_error
 dynamic(Name/3)          instantiation_error
 dynamic(userdef/Arity)   instantiation_error
 dynamic(1.5)             type_error(predicate_indicator, 1.5)
 dynamic(userdef/a)       type_error(integer, a)
 dynamic(1/a)             type_error(integer, a)
 dynamic(1/3)             type_error(atom, 1)
 dynamic(userdef/-3)      domain_error(not_less_than_zero, -3)
 dynamic(dynamic/1)       permission_error(modify, static_procedure, dynamic/1)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a></dd></dl>
<hr/>
 <a class="anchor" id="import_1"></a> <b>import/1</b> - imports another source file's definitions.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>:-</b> <b>import</b>(<em>Name</em>).</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <em>Name</em> must be an atom or string, whose name refers to a Plang source file along the import search path. If the referred to source file has not been loaded yet, it will be parsed and loaded into the current execution context. If the referred to source file has already been loaded, then <b>import/1</b> does nothing and succeeds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Name</em> does not have a file extension, then <code>.lp</code> is added to <em>Name</em>. Plang then searches in the same directory as the including source file for <em>Name</em>. If not found, Plang will search the system-specific import search path looking for <em>Name</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Name</em> includes system-specific directory separator characters (e.g. /), then the specified file will be loaded directly without searching the import search path. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The behavior of <b>import/1</b> is slightly different when used in a <a class="el" href="group__directives.html#directive_1">(:-)/1</a> directive than when used in other contexts. Within a directive, the search starts in the same directory as the including source file. Elsewhere, the search starts with the current directory. This is because the name of the including source file is not available outside of a directive context. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Fails if <em>Name</em> could be loaded due to an error.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Name</em> is a variable. </li>
<li><code>type_error(atom_or_string, <em>Name</em>)</code> - <em>Name</em> is not an atom or string. </li>
<li><code>existence_error(import, <em>Name</em>)</code> - <em>Name</em> could not be located on the import search path.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> :- <span class="keyword">import</span>(stdout).
 :- <span class="keyword">import</span>(<span class="stringliteral">&quot;stdout.lp&quot;</span>).
 :- <span class="keyword">import</span>(X).                instantiation_error
 :- <span class="keyword">import</span>(1.5).              type_error(atom_or_string, 1.5)
 :- import(<span class="stringliteral">&quot;not_found.lp&quot;</span>).   existence_error(import, <span class="stringliteral">&quot;not_found.lp&quot;</span>)
 :- import(<span class="stringliteral">&quot;../dir/file.lp&quot;</span>).
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a> has directives called <b>ensure_loaded/1</b> and <b>include/1</b> that perform a similar function to <b>import/1</b>. Those Standard Prolog directives are not supported by Plang. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The modules extension to Standard Prolog does have an <b>import/1</b> directive. Plang's version is not compatible.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__directives.html#consult_1">consult/1</a>, <a class="el" href="group__directives.html#load_library_1">load_library/1</a></dd></dl>
<hr/>
 <a class="anchor" id="initialization_1"></a> <b>(?-)/1</b>, <b>initialization/1</b> - execute a goal after a source file has been loaded.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>?-</b> <em>Goal</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>?-</b> { <em>Goal</em> } </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>:-</b> <b>initialization</b>(<em>Goal</em>).</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Goal</em> after the current source file has been completely loaded. After execution of the <em>Goal</em>, an implicit <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> and <a class="el" href="group__logic__and__control.html#fail_0">fail/0</a> are performed to return the system to its original state before the call. The only permanent modifications to the system state will be in the form of side-effects in <em>Goal</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <b>(?-)/1</b> or <b>initialization/1</b> is called during normal program execution instead of within a directive, it will have the same effect as <a class="el" href="group__logic__and__control.html#call_1">call/1</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> ?- stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>).
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>initialization/1</b> directive is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The <b>(?-)/1</b> form is the recommended syntax.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__logic__and__control.html#call_1">call/1</a></dd></dl>
<hr/>
 <a class="anchor" id="load_library_1"></a> <b>load_library/1</b> - loads a native C library that implements Plang predicates.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>:-</b> <b>load_library</b>(<em>Name</em>).</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <em>Name</em> must be an atom or string. The <em>Name</em> is used as a base name to search for a .so or .dll library. If found, the library is loaded and any native predicates implemented in C are registered with the Plang execution engine. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the library associated with <em>Name</em> can be loaded, then <b>load_library</b>(<em>Name</em>) succeeds. Otherwise an error is thrown describing the reason why the library could not be loaded.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Name</em> is a variable. </li>
<li><code>type_error(atom_or_string, <em>Name</em>)</code> - <em>Name</em> is not an atom or string. </li>
<li><code>type_error(library_name, <em>Name</em>)</code> - <em>Name</em> is not a valid library name. </li>
<li><code>existence_error(library, <em>Name</em>)</code> - <em>Name</em> could not be located on the library search path. </li>
<li><code>load_library_error(<em>Name</em>, <em>Reason</em>)</code> - the library identified by <em>Name</em> exists, but it could not be loaded by the system because of <em>Reason</em> (a string).</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> :- load_library(plang_wordnet).
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__directives.html#directive_1">(:-)/1</a>, <a class="el" href="group__directives.html#import_1">import/1</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
