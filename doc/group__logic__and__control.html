<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Builtin predicates - Logic and control</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Builtin predicates - Logic and control</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Predicates in this group are used to structure the flow of execution through a Plang program.</p>
<p><a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#call_1">call/1</a>, <a class="el" href="group__logic__and__control.html#call_2">call/2</a>, <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a>, <a class="el" href="group__logic__and__control.html#logical_and_2">(,)/2</a>, <a class="el" href="group__logic__and__control.html#cut_0">(!)/0</a>, <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a>, <a class="el" href="group__logic__and__control.html#do_stmt">do</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(\+)/1</a>, <a class="el" href="group__logic__and__control.html#fail_0">fail/0</a>, <a class="el" href="group__logic__and__control.html#false_0">false/0</a>, <a class="el" href="group__logic__and__control.html#for_stmt">for</a>, <a class="el" href="group__logic__and__control.html#halt_0">halt/0</a>, <a class="el" href="group__logic__and__control.html#halt_1">halt/1</a>, <a class="el" href="group__logic__and__control.html#if_stmt">(-&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#if_stmt">if</a>, <a class="el" href="group__logic__and__control.html#in_2">in/2</a>, <a class="el" href="group__logic__and__control.html#once_1">once/1</a>, <a class="el" href="group__logic__and__control.html#repeat_0">repeat/0</a>, <a class="el" href="group__logic__and__control.html#switch_stmt">switch</a>, <a class="el" href="group__logic__and__control.html#throw_1">throw/1</a>, <a class="el" href="group__logic__and__control.html#true_0">true/0</a>, <a class="el" href="group__logic__and__control.html#catch_3">try</a>, <a class="el" href="group__logic__and__control.html#while_stmt">while</a></p>
<hr/>
 <a class="anchor" id="logical_and_2"></a> <b>(&amp;&amp;)/2</b>, <b>(,)/2</b> - sequential execution of two goals.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Goal1</em> <b>&amp;&amp;</b> <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em></em>(Goal1, <em>Goal2</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Goal1</em> and then executes <em>Goal2</em> if <em>Goal1</em> was successful. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>(&amp;&amp;)/2</b> form is recommended for use within boolean conditions for <b>if</b>, <b>while</b>, and similar statements. The <b>(,)/2</b> form usually occurs as a result of parsing the statement sequence { <em>Goal1</em> ; <em>Goal2</em> }. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This predicate is equivalent to <a class="el" href="group__fuzzy__logic.html#fuzzy_and_2">fuzzy_and/2</a> when reasoning about terms that involve <a class="el" href="group__fuzzy__logic.html">fuzzy logic</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> nonvar(X); integer(X)
 (nonvar(X), integer(X))
 <span class="keywordflow">if</span> (nonvar(X) &amp;&amp; integer(X)) { ... }
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(,)/2</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The <b>(&amp;&amp;)/2</b> predicate is an alias for <b>(,)/2</b>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a>, <a class="el" href="group__fuzzy__logic.html#fuzzy_and_2">fuzzy_and/2</a></dd></dl>
<hr/>
 <a class="anchor" id="logical_or_2"></a> <b>(||)/2</b> - alternative execution of two goals.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Goal1</em> <b>||</b> <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Goal1</em> and succeeds if <em>Goal1</em> succeeds. Otherwise executes <em>Goal2</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Goal1</em> or <em>Goal2</em> involves terms that use <a class="el" href="group__fuzzy__logic.html">fuzzy logic</a>, then the fuzzy confidence value of <em>Goal1</em> <b>||</b> <em>Goal2</em> is the same as <em>Goal1</em> while it succeeds, and then the same as <em>Goal2</em> once <em>Goal1</em> fails. Use the <a class="el" href="group__fuzzy__logic.html#fuzzy_or_2">fuzzy_or/2</a> operator instead for calculating the logical fuzzy OR of <em>Goal1</em> and <em>Goal2</em>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> nonvar(X) || integer(X)
 if (atom(X) || integer(X)) { ... }
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a> has a <b>(;)/2</b> predicate that is used for disjunction. That predicate has been omitted from Plang because it conflicts with ";" used as a conjunction operator in statement lists.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a>, <a class="el" href="group__fuzzy__logic.html#fuzzy_or_2">fuzzy_or/2</a>, <a class="el" href="group__logic__and__control.html#if_stmt">if</a></dd></dl>
<hr/>
 <a class="anchor" id="logical_implies_2"></a> <b>(=&gt;)/2</b> - logical implication.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Goal1</em> <b>=&gt;</b> <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Goal1</em>. If it succeeds, then execute <em>Goal2</em>. If <em>Goal1</em> fails, then <em>Goal1</em> <b>=&gt;</b> <em>Goal2</em> succeeds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Implication differs from <a class="el" href="group__logic__and__control.html#if_stmt">(-&gt;)/2</a> in that <b>(-&gt;)/2</b> will <em>fail</em> if <em>Goal1</em> fails, whereas <b>(=&gt;)/2</b> will succeed. The implication operator is intended for use in applications that involve propositional logic. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Essentially, <em>Goal1</em> <b>=&gt;</b> <em>Goal2</em> is the same as (<em>Goal1</em> <b>-&gt;</b> <em>Goal2</em> <b>||</b> <b>true</b>).</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> A =&gt; B
 <span class="keyword">true</span> =&gt; <span class="keyword">true</span>             succeeds
 <span class="keyword">true</span> =&gt; <span class="keyword">false</span>            fails
 <span class="keyword">false</span> =&gt; <span class="keyword">true</span>            succeeds
 <span class="keyword">false</span> =&gt; <span class="keyword">false</span>           succeeds
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a>, <a class="el" href="group__logic__and__control.html#if_stmt">(-&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="logical_equiv_2"></a> <b>(&lt;=&gt;)/2</b> - logical equivalence.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Goal1</em> <b>&lt;=&gt;</b> <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <em>Goal1</em> and <em>Goal2</em>. Succeeds if they both succeed or if they both fail. Fails if one succeeds and the other fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Essentially, <em>Goal1</em> <b>&lt;=&gt;</b> <em>Goal2</em> is the same as (<em>Goal1</em> <b>-&gt;</b> <b>once</b>(<em>Goal2</em>) <b>||</b> <b>!</b> <em>Goal2</em>).</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> A &lt;=&gt; B
 true &lt;=&gt; <span class="keyword">true</span>            succeeds
 true &lt;=&gt; <span class="keyword">false</span>           fails
 false &lt;=&gt; <span class="keyword">true</span>           fails
 false &lt;=&gt; <span class="keyword">false</span>          succeeds
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#not_provable_1">(!)/1</a></dd></dl>
<hr/>
 <a class="anchor" id="call_1"></a> <b>call/1</b> - meta-execution of a goal.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>call</b>(<em>Goal</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Goal</em> is a callable term, then execute it as though it had been compiled normally. If <em>Goal</em> is not a callable term, then throw an error as described below.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The effect of a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> inside <em>Goal</em> is limited to the goal itself and does not affect control flow outside the <b>call/1</b> term.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - if <em>Goal</em> is a variable. </li>
<li><code>type_error(callable, </code><em>Goal<code></em>)</code> - if <em>Goal</em> is not a variable and not callable.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> call(fail)           fails
 X = atom(a); call(X) calls atom(a) and then succeeds
 call(X)              instantiation_error
 call(1.5)            type_error(callable, 1.5)
 call((atom(a), 1.5)) atom(a) succeeds and then type_error(callable, 1.5)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>call/1</b> predicate is mostly compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The main departure is that Standard Prolog will scan the entire structure of <em>Goal</em> and throw a <code>type_error</code> if some part of it is not callable. The last example above would throw <code>type_error(callable, (atom(a), 1.5))</code> and not execute <code>atom(a)</code> in Standard Prolog. Plang implements lazy evaluation of <b>call/1</b> subgoals, so only the outermost layer of <em>Goal</em> is checked before execution begins.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#call_2">call/2</a>, <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a>, <a class="el" href="group__logic__and__control.html#once_1">once/1</a></dd></dl>
<hr/>
 <a class="anchor" id="call_2"></a> <b>call/2</b> - meta-execution of a goal within the scope of a local database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>call</b>(<em>Goal</em>, <em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Goal</em> is a callable term, then execute it as though it had been compiled normally. If <em>Goal</em> is not a callable term, then throw an error as described below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Goal</em> is executed within a context where <em>Database</em> is set as the current database. Predicates that are called by <em>Goal</em> will be looked up in <em>Database</em> before the global database. Builtin predicates implemented in C will always override the local database; for example, it isn't possible to redefine <b>call/2</b> within a local database. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The effect of a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> inside <em>Goal</em> is limited to the goal itself and does not affect control flow outside the <b>call/2</b> term.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database. </li>
<li><code>instantiation_error</code> - if <em>Goal</em> is a variable. </li>
<li><code>type_error(callable, </code><em>Goal<code></em>)</code> - if <em>Goal</em> is not a variable and not callable.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
 assertz(userdef(a, b, c), DB);
 call(userdef(A, B, C), DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#assertz_2">assertz/2</a>, <a class="el" href="group__logic__and__control.html#call_1">call/1</a>, <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a></dd></dl>
<hr/>
 <a class="anchor" id="catch_3"></a> <b>catch/3</b>, <b>try</b> - catches an error that was thrown during execution of a goal.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>catch</b>(<em>Goal</em>, <em>Pattern</em>, <em>Recovery</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>try</b> { <em>Goal</em> } <b>catch</b> (<em>Pattern1</em>) { <em>Recovery1</em> } <b>catch</b> (<em>Pattern2</em>) { <em>Recovery2</em> } ...</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <b>call</b>(<em>Goal</em>) and succeeds or fails accordingly. If <em>Goal</em> throws an error with <a class="el" href="group__logic__and__control.html#throw_1">throw/1</a>, and the error can be unified with <em>Pattern</em>, then <b>call</b>(<em>Recovery</em>) will be executed. If the error does not unify with <em>Pattern</em>, then the error will continue to be thrown further up the call chain. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the case of the <b>try</b> statement, each <em>PatternN</em> is tried in turn until a match is found. The <em>RecoveryN</em> goal for that pattern is then executed. Note that this is not the same as <b>catch</b>(catch(<em>Goal</em>, <em>Pattern1</em>, <em>Recovery1</em>), <em>Pattern2</em>, <em>Recovery2</em>). The <b>catch/3</b> form may execute <em>Recovery2</em> if an error is thrown during <em>Recovery1</em>. The <b>try</b> statement form will not.</dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>catch/3</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The <b>try ... catch ...</b> statement is the recommended equivalent in Plang because of its better support for multiple catch blocks.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#throw_1">throw/1</a>, <a class="el" href="group__logic__and__control.html#call_1">call/1</a>, <a class="el" href="syntax_statements.html#syntax_try_stmt">Formal syntax of try statements</a></dd></dl>
<hr/>
 <a class="anchor" id="cut_0"></a> <a class="anchor" id="commit_0"></a> <b>commit/0</b>, <b>(!)/0</b> - commits the program to the current choice.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>commit</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>!</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>commit/0</b> predicate always succeeds but also prunes alternative solutions at the next higher goal level. It is most often used in predicates with multiple clauses that match the arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example implements a list membership testing predicate: <div class="fragment"><pre class="fragment"> is_member(X, [X|_]).
 is_member(X, [_|T]) { is_member(X, T); }
</pre></div> An issue with this predicate is that it will keep searching for further instances of <code>X</code> after finding the first. This may not be what was intended. We can solve this problem by committing to the solution once <code>X</code> is found: <div class="fragment"><pre class="fragment"> is_member(X, [X|_]) { commit; }
 is_member(X, [_|T]) { is_member(X, T); }
</pre></div> Another problem with the original version of the predicate is that if the tail of the list is a variable, it may loop indefinitely. We can solve this by adding another clause that commits and fails if the list is a variable: <div class="fragment"><pre class="fragment"> is_member(X, L) { var(L); commit; fail; }
 is_member(X, [X|_]) { commit; }
 is_member(X, [_|T]) { is_member(X, T); }
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> commit           succeeds
 !                succeeds
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(!)/0</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>commit</b> is recommended because it is more obvious as to its function.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#call_1">call/1</a></dd></dl>
<hr/>
 <a class="anchor" id="do_stmt"></a> <b>do</b> - repeatedly execute a statement until a condition is false.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>do</b> { <em>Statements</em> } (<em>Condition</em>); </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>do</b> [<em>UnbindVars</em>] { <em>Statements</em> } (<em>Condition</em>);</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>do</b> loop evaluates <em>Statements</em>, and then evaluates <em>Condition</em>. If <em>Condition</em> is true, then the loop repeats. If <em>Statements</em> fails, then the loop will fail. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>UnbindVars</em> is specified, then it contains a list of local variables that will be unbound at the beginning of each loop iteration before <em>Statements</em> is evaluated.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X = 1; <span class="keywordflow">do</span> { stdout::writeln(X); X ::= X + 1; } <span class="keywordflow">while</span> (X &lt;= 10);
 X = 1; <span class="keywordflow">do</span> [Y] { Y is X * 2; stdout::writeln(Y); X ::= X + 1; } <span class="keywordflow">while</span> (X &lt;= 10);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#for_stmt">for</a>, <a class="el" href="group__logic__and__control.html#while_stmt">while</a>, <a class="el" href="syntax_statements.html#syntax_do_stmt">Formal syntax of do statements</a></dd></dl>
<hr/>
 <a class="anchor" id="not_provable_1"></a> <b>(!)/1</b>, <b>(\+)/1</b> - negation by failure.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>!</b> <em>Term</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>\+</b> <em>Term</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <b>call</b>(<em>Term</em>) succeeds, then fail; otherwise succeed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note: <b>(!)/1</b> does not take the current fuzzy confidence value into account, so it is not suitable for use in applications that involve <a class="el" href="group__fuzzy__logic.html">fuzzy logic</a>. Use the <a class="el" href="group__fuzzy__logic.html#fuzzy_not_1">fuzzy_not/1</a> predicate instead.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X = a; !(X = b)      succeeds with X = a
 X = a; !(X = a)      fails
 \+ fail              succeeds
 ! <span class="keyword">true</span>               fails
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(\+)/1</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>(!)/1</b> is the recommended spelling.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_and_2">(&amp;&amp;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#logical_equiv_2">(&lt;=&gt;)/2</a>, <a class="el" href="group__fuzzy__logic.html#fuzzy_not_1">fuzzy_not/1</a></dd></dl>
<hr/>
 <a class="anchor" id="fail_0"></a> <a class="anchor" id="false_0"></a> <b>fail/0</b>, <b>false/0</b> - always fail.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>fail</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>false</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>fail</b> predicate always fails execution of the current goal.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> fail                 fails
 <span class="keyword">false</span>                fails
 repeat; f(a); fail   executes f(a) an infinite number of times
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>fail/0</b> predicate is part of <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The <b>false/0</b> predicate exists as an alias in Plang because it is a more natural opposite to <a class="el" href="group__logic__and__control.html#true_0">true/0</a>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#true_0">true/0</a></dd></dl>
<hr/>
 <a class="anchor" id="for_stmt"></a> <b>for</b> - loop over the members of a list.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>for</b> (<em>Variable</em> <b>in</b> <em>List</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>for</b> [<em>UnbindVars</em>] (<em>Variable</em> <b>in</b> <em>List</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>for</b> loop iterates over the members of <em>List</em>, binding <em>Variable</em> to each member in turn and performing <em>Statement</em>. The <em>Variable</em> must have a new name that does not occur previously in the clause. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Statement</em> fails for a member of <em>List</em>, then the loop will fail. If <em>Statement</em> succeeds for all members of <em>List</em>, then the loop will succeed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>UnbindVars</em> is specified, then it contains a list of local variables that will be unbound at the beginning of each loop iteration. The <em>Variable</em> must not appear in <em>UnbindVars</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - if <em>List</em> is a variable, or the tail of <em>List</em> is a variable. </li>
<li><code>type_error(list, </code><em>List<code></em>)</code> - if <em>List</em> is not a variable or a list, or the tail of <em>List</em> is not a variable or <b>[]</b>.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> (X in List) { stdout::writeln(X); }
 <span class="keywordflow">for</span> [Y] (X in List) { Y is X * 2; stdout::writeln(Y); }
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#do_stmt">do</a>, <a class="el" href="group__logic__and__control.html#in_2">in/2</a>, <a class="el" href="group__logic__and__control.html#while_stmt">while</a>, <a class="el" href="syntax_statements.html#syntax_for_stmt">Formal syntax of for statements</a></dd></dl>
<hr/>
 <a class="anchor" id="halt_0"></a> <b>halt/0</b> - stops execution of the top-level goal.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>halt</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Exits from execution of the top-level goal, returning control back to the system with an exit value of 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is not possible to trap the halt state with <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> halt
 <span class="keywordflow">catch</span>(halt, X, stdout::writeln(<span class="stringliteral">&apos;not reached&apos;</span>))
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#halt_1">halt/1</a></dd></dl>
<hr/>
 <a class="anchor" id="halt_1"></a> <b>halt/1</b> - stops execution of the top-level goal with a specific exit value.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>halt</b>(<em>ExitValue</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Exits from execution of the top-level goal, returning control back to the system with the specified integer <em>ExitValue</em>. The <em>ExitValue</em> may be clamped to a system-specific range to make it suitable for passing back to the host operating system. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is not possible to trap the halt state with <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a> if <em>ExitValue</em> is a valid integer.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>ExitValue</em> is a variable. </li>
<li><code>type_error(integer, <em>ExitValue</em>)</code> - <em>ExitValue</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> halt(3)
 catch(halt(3), X, stdout::writeln(&apos;not reached&apos;))
 halt(X)              instantiation_error
 halt(1.0)            type_error(integer, 1.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#halt_0">halt/0</a></dd></dl>
<hr/>
 <a class="anchor" id="if_stmt"></a> <b>(-&gt;)/2</b>, <b>if</b> - if-then statement.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>if</b> (<em>Goal1</em>) <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>if</b> (<em>Goal1</em>) <em>Goal2</em> <b>else</b> <em>Goal3</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(<em>Goal1</em> -&gt; <em>Goal2</em> || <b>true</b>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(<em>Goal1</em> -&gt; <em>Goal2</em> || <em>Goal3</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Goal1</em> is executed, and if it succeeds then <em>Goal2</em> is executed. If <em>Goal1</em> fails, then <em>Goal3</em> is executed. If <em>Goal3</em> is omitted, then the statement succeeds if <em>Goal1</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the goal has the form (<em>Goal1</em> -&gt; <em>Goal2</em>) without a <em>Goal3</em> else goal, then the goal will fail if <em>Goal1</em> fails. By contrast, <b>if</b> (<em>Goal1</em>) <em>Goal2</em> will succeed if <em>Goal1</em> fails.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (A) B; <span class="keywordflow">else</span> C;
 (A -&gt; B || C)
 <span class="keywordflow">if</span> (A) B;
 (A -&gt; B || <span class="keyword">true</span>)         succeeds <span class="keywordflow">if</span> A fails
 (A -&gt; B)                 fails <span class="keywordflow">if</span> A fails
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(-&gt;)/2</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. Standard prolog expresses if-then-else as <code>(A -&gt; B ; C)</code> which is not supported in Plang. The <b>if</b> statement form is the recommended method to express conditionals in Plang.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a>, <a class="el" href="group__logic__and__control.html#logical_implies_2">(=&gt;)/2</a>, <a class="el" href="group__logic__and__control.html#switch_stmt">switch</a>, <a class="el" href="syntax_statements.html#syntax_if_stmt">Formal syntax of if statements</a></dd></dl>
<hr/>
 <a class="anchor" id="in_2"></a> <b>in/2</b> - list membership testing.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Term</em> <b>in</b> <em>List</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Term</em> <b>in</b> <em>List</em> succeeds multiple times whenever <em>Term</em> unifies with an element of <em>List</em>. Fails at the end of the <em>List</em>, if <em>Term</em> does not unify with any of the elements, or the tail of <em>List</em> is not a list or <code>[]</code>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>List</em> or the tail of <em>List</em> is a variable. This prevents an infinite loop if <em>List</em> is partial.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X in [a, b, c]       succeeds 3 times <span class="keywordflow">for</span> X = a/b/c, then fails
 f(X) in [a]          fails
 X in Y               instantiation_error
 X in [a|Y]           succeeds with X = a, then instantiation_error
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note: if the <b>in/2</b> predicate is used within a condition for a <a class="el" href="group__logic__and__control.html#do_stmt">do</a>, <a class="el" href="group__logic__and__control.html#if_stmt">if</a>, or <a class="el" href="group__logic__and__control.html#while_stmt">while</a> statement, then it will succeed only once for the first match. This is because the statement conditions perform a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> after success is detected. This is useful for detecting simple list membership only: <div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (f(a) in List) {
     ...
 }
</pre></div> The recommended procedural loop construct for lists is <a class="el" href="group__logic__and__control.html#for_stmt">for</a>: <div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> (X in [a, b, c])
     stdout::writeln(X);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#for_stmt">for</a></dd></dl>
<hr/>
 <a class="anchor" id="once_1"></a> <b>once/1</b> - executes a goal only once, ignoring subsequent solutions.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>once</b>(<em>Goal</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Executes <b>call</b>(<em>Goal</em>) and then executes a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> to prune searches for further solutions. In essence, <b>once</b>(<em>Goal</em>) behaves like <b>call</b>(<em>Goal</em>, <b>commit</b>).</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> once((X = a || Y = b))   succeeds with X = a, never performs Y = b
 once(fail)               fails
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#call_1">call/1</a></dd></dl>
<hr/>
 <a class="anchor" id="repeat_0"></a> <b>repeat/0</b> - succeeds repeatedly and indefinitely.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>repeat</b>; ...; <b>fail</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Repeats the sequence of statements between <b>repeat</b> and <b>fail</b> indefinitely until a <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> is encountered.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> repeat; stdout::writeln(<span class="stringliteral">&quot;hello&quot;</span>); fail
                      outputs <span class="stringliteral">&quot;hello&quot;</span> indefinitely
 repeat; !            succeeds
 repeat; !; fail      fails
 repeat; fail         loops indefinitely
 repeat; a = b        loops indefinitely due to unification failure
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#fail_0">fail/0</a></dd></dl>
<hr/>
 <a class="anchor" id="switch_stmt"></a> <b>switch</b> - switch on a term and choose a matching statement to handle the term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>switch</b> (<em>Term</em>) { <b>case</b> <em>Label1:</em> <em>Statement1</em>; ...; <b>case</b> <em>LabelN:</em> <em>StatementN</em>; <b>default:</b> <em>DefaultStatement</em>; }</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Finds the first <em>LabelM</em> term in the <b>case</b> list that unifies with <em>Term</em>, and executes the associated <em>StatementM</em>. If none of the <b>case</b> labels match, then executes the <em>DefaultStatement</em> associated with the <b>default</b> label. If there is no <b>default</b> label, then the <b>switch</b> statement fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Multiple case labels can be specified for the same statement with <b>case</b> <em>Label1:</em> <b>case</b> <em>Label2:</em> ... <b>case</b> <em>LabelN:</em> <em>Statement</em>. The <b>default</b> label can be mixed with regular <b>case</b> labels. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike C/C++, execution does not fall through from <em>StatementM</em> to the following <em>StatementM+1</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once a <em>LabelM</em> is found that unifies with <em>Term</em>, the <b>switch</b> statement does an implicit <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> to commit the clause to that choice. Backtracking does not select later <b>case</b> labels even if they may have otherwise unified with <em>Term</em>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> eval(Term, Answer) {
     <span class="keywordflow">switch</span> (Term) {
         <span class="keywordflow">case</span> X + Y: {
             eval(X, XAnswer);
             eval(Y, YAnswer);
             Answer is XAnswer + YAnswer;
         }
         <span class="keywordflow">case</span> X - Y: {
             eval(X, XAnswer);
             eval(Y, YAnswer);
             Answer is XAnswer - YAnswer;
         }
         <span class="keywordflow">case</span> X * Y: {
             eval(X, XAnswer);
             eval(Y, YAnswer);
             Answer is XAnswer * YAnswer;
         }
         <span class="keywordflow">case</span> X / Y: {
             eval(X, XAnswer);
             eval(Y, YAnswer);
             Answer is XAnswer / YAnswer;
         }
         <span class="keywordflow">case</span> -X: {
             eval(X, XAnswer);
             Answer is -XAnswer;
         }
         <span class="keywordflow">default</span>: {
             <span class="keywordflow">if</span> (number(Term))
                 Answer = Term;
             <span class="keywordflow">else</span>
                 lookup_variable(Term, Answer);
         }
     }
 }

 eval(2 * x + y, Answer)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#if_stmt">if</a>, <a class="el" href="syntax_statements.html#syntax_switch_stmt">Formal syntax of switch statements</a></dd></dl>
<hr/>
 <a class="anchor" id="throw_1"></a> <b>throw/1</b> - throws an error to an enclosing catch goal.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>throw</b>(<em>Term</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Throws a freshly renamed version of <em>Term</em> as an error to an enclosing <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a> goal that matches <em>Term</em>. Plang will backtrack to the matching <a class="el" href="group__logic__and__control.html#catch_3">catch/3</a> goal and then execute the associated recovery goal.</dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#catch_3">catch/3</a></dd></dl>
<hr/>
 <a class="anchor" id="true_0"></a> <b>true/0</b> - always succeed.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>true</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>true</b> predicate always succeeds execution of the current goal.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">true</span>                 succeeds
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#fail_0">fail/0</a></dd></dl>
<hr/>
 <a class="anchor" id="while_stmt"></a> <b>while</b> - repeatedly execute a statement while a condition is true.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>while</b> (<em>Condition</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>while</b> [<em>UnbindVars</em>] (<em>Condition</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>while</b> loop evaluates <em>Condition</em> at the beginning of each iteration. If <em>Condition</em> is true then <em>Statement</em> will be executed. Otherwise, the loop terminates. If <em>Statement</em> fails, then the loop will fail. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>UnbindVars</em> is specified, then it contains a list of local variables that will be unbound at the beginning of each loop iteration before <em>Condition</em> is evaluated.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X = 1; <span class="keywordflow">while</span> (X &lt;= 10) { stdout::writeln(X); X ::= X + 1; }
 X = 1; <span class="keywordflow">while</span> [Y] (X &lt;= 10) { Y is X * 2; stdout::writeln(Y); X ::= X + 1; }
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__logic__and__control.html#do_stmt">do</a>, <a class="el" href="group__logic__and__control.html#for_stmt">for</a>, <a class="el" href="syntax_statements.html#syntax_while_stmt">Formal syntax of while statements</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
