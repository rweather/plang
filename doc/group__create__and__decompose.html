<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Builtin predicates - Term creation and decomposition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Builtin predicates - Term creation and decomposition</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Predicates in this group create and decompose terms dynamically.</p>
<p><a class="el" href="group__create__and__decompose.html#list_cons_2">(.)/2</a>, <a class="el" href="group__create__and__decompose.html#univ_2">(=..)/2</a>, <a class="el" href="group__create__and__decompose.html#arg_3">arg/3</a>, <a class="el" href="group__create__and__decompose.html#copy_term_2">copy_term/2</a>, <a class="el" href="group__create__and__decompose.html#functor_3">functor/3</a></p>
<hr/>
 <a class="anchor" id="list_cons_2"></a> <b>(.)/2</b>, <b>[_|_]/2</b> - constructs a list from head and tail terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>X</em> = [<em>Head</em> | <em>Tail</em>] </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>X</em> = <b>'.'</b>(<em>Head</em>, <em>Tail</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Unifies <em>X</em> with a list constructed from the specified <em>Head</em> and <em>Tail</em> terms. The [<em>Head</em> | <em>Tail</em>] form is the recommended syntax for expressing list construction.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> [H | T] = [a, b]             succeeds with H = a, T = [b]
 [a, b] = <span class="charliteral">&apos;.&apos;</span>(a, <span class="charliteral">&apos;.&apos;</span>(b, []))  succeeds
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A common use for <b>(.)/2</b> is to decompose a predicate argument into its head and tail components for walking every element in a list: <div class="fragment"><pre class="fragment"> is_member(X, [X|T]).
 is_member(X, [_|T]) { is_member(X, T); }
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__create__and__decompose.html#arg_3">arg/3</a>, <a class="el" href="group__create__and__decompose.html#functor_3">functor/3</a>, <a class="el" href="group__create__and__decompose.html#univ_2">(=..)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="univ_2"></a> <b>(=..)/2</b> - decomposes a term into a list containing the term's functor name and arguments.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Term</em> <b>=..</b> <em>List</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is an atomic term, then <em>List</em> is unified with [<em>Term</em>]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a compound term, then <em>List</em> is unified with [<em>Name</em>, <em>Arg1</em>, ..., <em>ArgN</em>], where <em>Name</em> is the name of the functor of <em>Term</em>, and <em>Arg1</em>, ... <em>ArgN</em> are its arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a variable, and <em>List</em> contains a single atomic value then <em>Term</em> is unified with that atomic value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a variable, and <em>List</em> contains two or more members, and the first is an atom, then <em>Term</em> is unified with a new compound term with the first element as its name, and the remaining list members as its arguments.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Term</em> is a variable and <em>List</em> is not a list, or the tail of <em>List</em> is not the <code>[]</code> atom. </li>
<li><code>instantiation_error</code> - <em>Term</em> is a variable and the first member of <em>List</em> is also a variable. </li>
<li><code>domain_error(non_empty_list, <em>List</em>)</code> - <em>Term</em> is a variable and <em>List</em> is an empty list. </li>
<li><code>type_error(atom, <em>Name</em>)</code> - <em>Term</em> is a variable, <em>List</em> has two or more members, and the first member is not an atom. </li>
<li><code>type_error(atomic, <em>Name</em>)</code> - <em>Term</em> is a variable, <em>List</em> has one member, and it is not atomic. </li>
<li><code>type_error(list, <em>List</em>)</code> - <em>Term</em> is not a variable and <em>List</em> is not a list or variable.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> foo =.. [foo]                    succeeds
 1.5 =.. [1.5]                    succeeds
 [a, b, c] =.. [<span class="charliteral">&apos;.&apos;</span>, a, [b, c]]   succeeds
 f(a, b, c) =.. [f, X, Y, Z]      succeeds with X = a, Y = b, Z = c
 f(a, b) =.. List                 succeeds with List = [f, a, b]
 Term =.. [foo]                   succeeds with Term = foo
 Term =.. [1.5]                   succeeds with Term = 1.5
 Term =.. [f, a, b]               succeeds with Term = f(a, b)
 Term =.. [&apos;.&apos;, a, []]            succeeds with Term = [a]
 Term =.. List                    instantiation_error
 Term =.. f(a, b)                 instantiation_error
 Term =.. [f|X]                   instantiation_error
 Term =.. []                      domain_error(non_empty_list, [])
 Term =.. [f(a, b)]               type_error(atomic, f(a, b))
 Term =.. [1.5, a, b]             type_error(atom, 1.5)
 f(a, b) =.. g(a)                 type_error(list, g(a))
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__create__and__decompose.html#list_cons_2">(.)/2</a>, <a class="el" href="group__create__and__decompose.html#arg_3">arg/3</a>, <a class="el" href="group__create__and__decompose.html#functor_3">functor/3</a></dd></dl>
<hr/>
 <a class="anchor" id="arg_3"></a> <b>arg/3</b> - extracts the n'th argument from a term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>arg</b>(<em>N</em>, <em>Term</em>, <em>Arg</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Unifies <em>Arg</em> with argument <em>N</em> of the compound <em>Term</em>. The first argument of <em>Term</em> is numbered 1. Fails if <em>N</em> is out of range or <em>Arg</em> does not unify with the extracted argument.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>N</em> or <em>Term</em> is a variable. </li>
<li><code>type_error(integer, <em>N</em>)</code> - <em>N</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>N</em>)</code> - <em>N</em> is an integer that is less than zero. </li>
<li><code>type_error(compound, <em>Term</em>)</code> - <em>Term</em> is not a compound term (functor or list).</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> arg(1, foo(a, b), X)         succeeds with X = a
 arg(2, foo(a, b), X)         succeeds with X = b
 arg(3, foo(a, b), X)         fails
 arg(0, foo(a, b), X)         fails
 arg(1, [a, b], X)            succeeds with X = a
 arg(2, [a, b], X)            succeeds with X = [b]
 arg(1, foo(a, b), a)         succeeds
 arg(1, foo(a, b), b)         fails
 arg(1, foo(X, b), f(X))      fails due to occurs check
 arg(N, foo(a, b), X)         instantiation_error
 arg(1, Term, X)              instantiation_error
 arg(a, [a, b], X)            type_error(integer, a)
 arg(-3, [a, b], X)           domain_error(not_less_than_zero, -3)
 arg(1, a, X)                 type_error(compound, a)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__create__and__decompose.html#list_cons_2">(.)/2</a>, <a class="el" href="group__create__and__decompose.html#univ_2">(=..)/2</a>, <a class="el" href="group__create__and__decompose.html#functor_3">functor/3</a></dd></dl>
<hr/>
 <a class="anchor" id="copy_term_2"></a> <b>copy_term/2</b> - unifies the second argument with a freshly renamed copy of the first.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>copy_term</b>(<em>Term1</em>, <em>Term2</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Creates a copy of <em>Term1</em> where all variables have been replaced with freshly renamed variables, and then unifies the copy with <em>Term2</em>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd>In the following examples X and Y are renamed to A and B respectively: <div class="fragment"><pre class="fragment"> copy_term(f(X, Y), Z)        succeeds with Z = f(A, B)
 copy_term(X, a)              succeeds with A = a, X still unbound
 copy_term(f(a, X), f(X, b))  succeeds with X = a
 copy_term(f(X, X), f(Y, Z))  succeeds with Y = Z
 copy_term(foo, bar)          fails
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<hr/>
 <a class="anchor" id="functor_3"></a> <b>functor/3</b> - extracts the name and arity of a functor term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>functor</b>(<em>Term</em>, <em>Name</em>, <em>Arity</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is a compound functor term, then <em>Name</em> is unified with the name of the functor, and <em>Arity</em> with its arity. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a list, then <em>Name</em> is unified with the atom "." and <em>Arity</em> is unified with 2. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is an atomic term, then <em>Name</em> is unified with <em>Term</em>, and <em>Arity</em> is unified with 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a variable, <em>Name</em> is an atomic term, and <em>Arity</em> is zero, then <em>Term</em> is unified with <em>Name</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is a variable and <em>Name</em> and <em>Arity</em> are not variables, then <em>Term</em> is bound to a new compound term of type <em>Name</em> / <em>Arity</em>, with new free variables as the arguments.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Term</em> and <em>Name</em> are both variables. </li>
<li><code>instantiation_error</code> - <em>Term</em> and <em>Arity</em> are both variables. </li>
<li><code>type_error(atomic, <em>Name</em>)</code> - <em>Name</em> is not an atomic term and <em>Term</em> is a variable. </li>
<li><code>type_error(integer, <em>Arity</em>)</code> - <em>Arity</em> is not an integer and <em>Term</em> is a variable. </li>
<li><code>domain_error(not_less_than_zero, <em>Arity</em>)</code> - <em>Arity</em> is an integer that is less than zero and <em>Term</em> is a variable. </li>
<li><code>type_error(atom, <em>Name</em>)</code> - <em>Name</em> is not an atom, <em>Arity</em> is not zero, and <em>Term</em> is a variable.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> functor(a, Name, Arity)          succeeds with Name = a, Arity = 0
 functor(1.5, Name, Arity)        succeeds with Name = 1.5, Arity = 0
 functor(f(a, b), Name, Arity)    succeeds with Name = f, Arity = 2
 functor([H|T], Name, Arity)      succeeds with Name = &apos;.&apos;, Arity = 2
 functor(Term, a, 0)              succeeds with Term = a
 functor(Term, 1.5, 0)            succeeds with Term = 1.5
 functor(Term, f, 2)              succeeds with Term = f(X, Y)
 functor(Term, &apos;.&apos;, 2)            succeeds with Term = [X|Y]
 functor(Term, Name, 2)           instantiation_error
 functor(Term, f, Arity)          instantiation_error
 functor(Term, f(a), 1)           type_error(atomic, f(a))
 functor(Term, f, 1.5)            type_error(integer, 1.5)
 functor(Term, f, -1)             domain_error(not_less_than_zero, -1)
 functor(Term, 1.5, 1)            type_error(atom, 1.5)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__create__and__decompose.html#list_cons_2">(.)/2</a>, <a class="el" href="group__create__and__decompose.html#arg_3">arg/3</a>, <a class="el" href="group__create__and__decompose.html#univ_2">(=..)/2</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
