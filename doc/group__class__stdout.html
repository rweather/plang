<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Classes - stdout and stderr</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Classes - stdout and stderr</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p><a class="anchor" id="class_stderr"></a></p>
<p>The <code>stdout</code> and <code>stderr</code> classes provide I/O stream implementations that write to the process's standard output and standard error streams. The two classes implement the <a class="el" href="group__class__iostream.html">iostream</a> API, and can be used as follows:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).
:- <span class="keyword">import</span>(stderr).

main(Args)
{
    <span class="keyword">new</span> stdout(Stdout);
    Stdout.writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);

    <span class="keyword">new</span> stderr(Stderr);
    Stderr.writeln(<span class="stringliteral">&quot;Hello Error!&quot;</span>);

    Stdout.writeln(<span class="stringliteral">&quot;Arguments: &quot;</span> + Args);
}
</pre></div><p>The <code>stdout</code> and <code>stderr</code> classes also provide some static convenience methods which remove the need to create an object first:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(stdout).
:- <span class="keyword">import</span>(stderr).

main(Args)
{
    stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);
    stderr::writeln(<span class="stringliteral">&quot;Hello Error!&quot;</span>);
    stdout::writeln(<span class="stringliteral">&quot;Arguments: &quot;</span> + Args);
}
</pre></div><dl class="user"><dt><b>Parent class</b></dt><dd><a class="el" href="group__class__iostream.html">iostream</a></dd></dl>
<dl class="user"><dt><b>Class members</b></dt><dd><code>override</code> <a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite</a>() <br/>
 <code>override</code> <a class="el" href="group__class__iostream.html#iostream_flush">flush</a>() <br/>
 <code>override</code> <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte</a>(<em>Byte</em>) <br/>
 <code>override</code> <a class="el" href="group__class__iostream.html#iostream_writeString">writeString</a>(<em>String</em>) <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_flush">flush</a>() <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_write">write</a>(<em>Term</em>) <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_writeln">writeln</a>(<em>Term</em>) <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_writeln">writeln</a>() <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm</a>(<em>Term</em>) <br/>
 <code>static</code> <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm</a>(<em>Term</em>, <em>Vars</em>)</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdin.html">stdin</a></dd></dl>
<hr/>
 <a class="anchor" id="stdout_flush"></a> <b>stdout::flush</b>() <br/>
 <b>stderr::flush</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Flushes all data that has been written so far to standard output (or standard error).</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">stdout::write(<span class="stringliteral">&quot;| ?- &quot;</span>);
stdout::flush();
Stdin.readTerm(Term);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdout.html#stdout_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">iostream::flush()</a></dd></dl>
<hr/>
 <a class="anchor" id="stdout_write"></a> <b>stdout::write</b>(<em>Term</em>) <br/>
 <b>stderr::write</b>(<em>Term</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is a string, then write it directly to standard output (or standard error) without quoting. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> has the form (<em>A</em> + <em>B</em>), then write <em>A</em> and <em>B</em> to the output without the plus sign. This rule is applied recursively for writing terms such as (<em>A</em> + <em>B</em> + <em>C</em> + ...). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is not a string or of the form (<em>A</em> + <em>B</em>), then write it using the same representation and quoting rules as <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm()</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">Answer is 2 + 2;
stdout::write(<span class="stringliteral">&quot;The answer is: &quot;</span> + Answer);
stdout::writeln();

The answer is: 4
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdout.html#stdout_flush">flush()</a>, <a class="el" href="group__class__stdout.html#stdout_writeln">writeln()</a>, <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm()</a>, <a class="el" href="group__class__iostream.html#iostream_write">iostream::write()</a></dd></dl>
<hr/>
 <a class="anchor" id="stdout_writeln"></a> <b>stdout::writeln</b>(<em>Term</em>) <br/>
 <b>stdout::writeln</b>() <br/>
 <b>stderr::writeln</b>(<em>Term</em>) <br/>
 <b>stderr::writeln</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is a string, then write it directly to standard output (or standard error) without quoting. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> has the form (<em>A</em> + <em>B</em>), then write <em>A</em> and <em>B</em> to the output without the plus sign. This rule is applied recursively for writing terms such as (<em>A</em> + <em>B</em> + <em>C</em> + ...). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is not a string or of the form (<em>A</em> + <em>B</em>), then write it using the same representation and quoting rules as <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm()</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A newline is written after <em>Term</em>. If <em>Term</em> is omitted, then only a newline is written.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">Answer is 2 + 2;
stdout::writeln(<span class="stringliteral">&quot;The answer is: &quot;</span> + Answer);

The answer is: 4
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdout.html#stdout_write">write()</a>, <a class="el" href="group__class__stdout.html#stdout_writeTerm">writeTerm()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">iostream::writeln()</a></dd></dl>
<hr/>
 <a class="anchor" id="stdout_writeTerm"></a> <b>stdout::writeTerm</b>(<em>Term</em>) <br/>
 <b>stdout::writeTerm</b>(<em>Term</em>, <em>Vars</em>) <br/>
 <b>stderr::writeTerm</b>(<em>Term</em>) <br/>
 <b>stderr::writeTerm</b>(<em>Term</em>, <em>Vars</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Write <em>Term</em> to standard output (or standard error) in a form that is compatible with the Plang source parser for <a class="el" href="syntax_terms.html">terms</a>. The <em>Term</em> is not terminated with a "." or end of line marker. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Vars</em> is present, then it must be a list of <em>Name</em> = <em>Var</em> declarations. If <em>Var</em> is encountered as an unbound variable in <em>Term</em>, then it will be written to <em>Stream</em> as <em>Name</em>. Variables not listed in <em>Vars</em> will be written as "_N", where "N" is the variable's pointer value. If <em>Vars</em> is not present, then all unbound variables are written as "_N". <em>Name</em> must be an atom or string.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Vars</em> is a variable. </li>
<li><code>type_error(variable_names, <em>Vars</em>)</code> - <em>Vars</em> is not a valid list of variable names.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">stdout::writeTerm(A - B * 1.5 + pi / 2);
    produces: _1f95460 - _1f95420 * 1.5 + pi / 2

stdout::writeTerm(A - B * 1.5 + pi / 2, [<span class="stringliteral">&quot;A&quot;</span> = A, <span class="stringliteral">&quot;B&quot;</span> = B]);
    produces: A - B * 1.5 + pi / 2
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdout.html#stdout_write">write()</a>, <a class="el" href="group__class__stdout.html#stdout_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">iostream::writeTerm()</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
