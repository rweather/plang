<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Classes - iostream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Classes - iostream</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>This module defines a single class called <code>iostream</code> that acts as the base of a hierarchy of related I/O handling classes.</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(iostream).
</pre></div><dl class="user"><dt><b>Parent class</b></dt><dd>None.</dd></dl>
<dl class="user"><dt><b>Class members</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_close">close</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_flush">flush</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_length">length</a>(<em>Length</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_readByte">readByte</a>(<em>Byte</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes</a>(<em>Bytes</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_readLine">readLine</a>(<em>Line</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm</a>(<em>Term</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm</a>(<em>Term</em>, <em>Vars</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_seek">seek</a>(<em>Position</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_seek">seek</a>(<em>Position</em>, <em>Origin</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_tell">tell</a>(<em>Position</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_write">write</a>(<em>Term</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte</a>(<em>Byte</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeln">writeln</a>(<em>Term</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeln">writeln</a>() <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeString">writeString</a>(<em>String</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm</a>(<em>Term</em>) <br/>
 <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm</a>(<em>Term</em>, <em>Vars</em>)</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__stdout.html#class_stderr">stderr</a>, <a class="el" href="group__class__stdin.html">stdin</a>, <a class="el" href="group__class__stdout.html">stdout</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_canRead"></a> <em>Stream</em>.<b>canRead</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Succeeds if <em>Stream</em> supports reading; fails otherwise. The default implementation always fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a subclass overrides <b>canRead()</b> and indicates that <em>Stream</em> is capable of reading, then the subclass should also override <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, and <a class="el" href="group__class__iostream.html#iostream_readBytes">readLine()</a>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek()</a>, <a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_canSeek"></a> <em>Stream</em>.<b>canSeek</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Succeeds if <em>Stream</em> supports seeking; fails otherwise. The default implementation always fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a subclass overrides <b>canSeek()</b> and indicates that <em>Stream</em> is capable of seeking, then the subclass should also override <a class="el" href="group__class__iostream.html#iostream_length">length()</a>, <a class="el" href="group__class__iostream.html#iostream_seek">seek()</a>, and <a class="el" href="group__class__iostream.html#iostream_tell">tell()</a>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_length">length()</a>, <a class="el" href="group__class__iostream.html#iostream_seek">seek()</a>, <a class="el" href="group__class__iostream.html#iostream_tell">tell()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_canWrite"></a> <em>Stream</em>.<b>canWrite</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Succeeds if <em>Stream</em> supports writing; fails otherwise. The default implementation always fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a subclass overrides <b>canWrite()</b> and indicates that <em>Stream</em> is capable of writing, then the subclass should also override <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a> and <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_close"></a> <em>Stream</em>.<b>close</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Closes <em>Stream</em>, releasing all resources associated with it, and then succeeds. The default implementation always succeeds.</dd></dl>
<hr/>
 <a class="anchor" id="iostream_flush"></a> <em>Stream</em>.<b>flush</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>Flushes all data that has been written so far to <em>Stream</em>, and then succeeds.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(output, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of writing. This error is thrown by the default implementation.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_length"></a> <em>Stream</em>.<b>length</b>(<em>Length</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Unifies <em>Length</em> with the length of <em>Stream</em>. Because <em>Length</em> is represented as a 32-bit integer, this method cannot return the length of streams that are larger than 2 Gb in size.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(reposition, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of seeking. This error is thrown by the default implementation. </li>
<li><code>representation_error(seek_position)</code> - the stream length cannot be represented as a 32-bit integer.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek()</a>, <a class="el" href="group__class__iostream.html#iostream_seek">seek()</a>, <a class="el" href="group__class__iostream.html#iostream_tell">tell()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_readByte"></a> <em>Stream</em>.<b>readByte</b>(<em>Byte</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Unifies <em>Byte</em> with the integer value of the next byte of <em>Stream</em> and succeeds; or fails if at the end of <em>Stream</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Stream</em> is non-blocking and there are no bytes available at present, then the method will succeed and <em>Byte</em> will be unified with -1.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(input, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of reading. This error is thrown by the default implementation.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_readBytes"></a> <em>Stream</em>.<b>readBytes</b>(<em>Bytes</em>, <em>MaxLength</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Reads up to <em>MaxLength</em> bytes from <em>Stream</em> and then unifies <em>Bytes</em> with a string containing the bytes that were read. Fails if the end of stream has been reached and no bytes were available for reading. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The number of bytes returned in <em>Bytes</em> may be less than <em>MaxLength</em> if the end of file has almost been reached or <em>Stream</em> is non-blocking and there are insufficient bytes available at present. It is possible for an empty string to be returned in <em>Bytes</em> if <em>MaxLength</em> is zero, or if <em>Stream</em> is non-blocking and there are no bytes available.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(input, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of reading. This error is thrown by the default implementation. </li>
<li><code>instantiation_error</code> - <em>MaxLength</em> is a variable. </li>
<li><code>type_error(integer, <em>MaxLength</em>)</code> - <em>MaxLength</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>MaxLength</em>)</code> - <em>MaxLength</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_readLine"></a> <em>Stream</em>.<b>readLine</b>(<em>Line</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Reads a single UTF-8 text line from <em>Stream</em>, unifies it with <em>Line</em>, and succeeds. End of line CRLF or LF sequences are stripped from <em>Line</em>. Fails if the end of stream has been reached and no bytes are available for reading. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>readLine()</b> method is always blocking, even if <em>Stream</em> is not. On non-blocking streams, this method will force <em>Stream</em> to block until an end of line character or the end of stream is reached. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the last line of <em>Stream</em> is non-empty and does not end in a CRLF or LF sequence, then <b>readLine()</b> will act as though it does. The following call to <b>readLine()</b> will fail, indicating end of stream.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(input, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of reading. This error is thrown by the default implementation.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, <a class="el" href="group__class__iostream.html#iostream_readTerm">readTerm()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_readTerm"></a> <em>Stream</em>.<b>readTerm</b>(<em>Term</em>) <br/>
 <em>Stream</em>.<b>readTerm</b>(<em>Term</em>, <em>Vars</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Reads a single <a class="el" href="syntax_terms.html">term</a> from <em>Stream</em> and unifies it with <em>Term</em>. Fails if the end of stream has been reached. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Internally, the default implementation of <b>readTerm()</b> calls <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a> to fetch the raw textual data. Reading continues until a line is encountered that ends in ".". All of the lines read up until that point are parsed using the Plang source parser to create a term. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Vars</em> is present, then it is unified with a list of variable names and references within <em>Term</em>. The members of the <em>Vars</em> list have the form <code><em>Name</em> = <em>Var</code></em> where <em>Name</em> is a string and <em>Var</em> is the unbound variable that <em>Name</em> refers to in <em>Term</em>. Each <em>Name</em> will appear only once in the list.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(input, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of reading. </li>
<li><code>syntax_error(<em>Message</em>)</code> - a syntax error was encountered while reading the term. <em>Message</em> is set to a string describing the error.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canRead">canRead()</a>, <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_seek"></a> <em>Stream</em>.<b>seek</b>(<em>Position</em>) <br/>
 <em>Stream</em>.<b>seek</b>(<em>Position</em>, <em>Origin</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Seeks to offset <em>Position</em> within <em>Stream</em>. If <em>Origin</em> is present, then it must be one of the atoms <code>start</code>, <code>current</code>, or <code>end</code>, which indicate whether <em>Position</em> should be interepreted relative to the start, current position, or end of <em>Stream</em> respectively. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Because <em>Position</em> is limited to a 32-bit integer, this predicate cannot seek directly to a position within a stream larger than 2 Gb in size. The <em>Origin</em> values of <code>current</code> and <code>end</code> can be used to hop through the file in 2 Gb or smaller steps.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(reposition, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of seeking. This error is thrown by the default implementation. </li>
<li><code>instantiation_error</code> - <em>Position</em> or <em>Origin</em> is a variable. </li>
<li><code>type_error(integer, <em>Position</em>)</code> - <em>Position</em> is not an integer. </li>
<li><code>type_error(seek_origin, <em>Origin</em>)</code> - <em>Origin</em> is not one of the atoms <code>start</code>, <code>current</code>, or <code>end</code>. </li>
<li><code>domain_error(seek_position, <em>Position</em> / <em>Origin</em>)</code> - <em>Position</em> and <em>Origin</em> do not define a valid seek position, although <em>Stream</em> is otherwise capable of seeking.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek()</a>, <a class="el" href="group__class__iostream.html#iostream_length">length()</a>, <a class="el" href="group__class__iostream.html#iostream_tell">tell()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_tell"></a> <em>Stream</em>.<b>tell</b>(<em>Position</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Unifies <em>Position</em> with the an integer representing the current seek position within <em>Stream</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Because <em>Position</em> is limited to a 32-bit integer, this predicate cannot return the seek position within files larger than 2 Gb in size.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(reposition, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of seeking. This error is thrown by the default implementation. </li>
<li><code>representation_error(seek_position)</code> - the current position cannot be represented as a 32-bit integer.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canSeek">canSeek()</a>, <a class="el" href="group__class__iostream.html#iostream_length">length()</a>, <a class="el" href="group__class__iostream.html#iostream_seek">seek()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_write"></a> <em>Stream</em>.<b>write</b>(<em>Term</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is a string, then write it directly to the stream using <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> has the form (<em>A</em> + <em>B</em>), then write <em>A</em> and <em>B</em> to the stream without the plus sign. This rule is applied recursively for writing terms such as (<em>A</em> + <em>B</em> + <em>C</em> + ...). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is not a string or of the form (<em>A</em> + <em>B</em>), then write it using <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">Answer is 2 + 2;
Stream.write(<span class="stringliteral">&quot;The answer is: &quot;</span> + Answer);
Stream.writeln();

The answer is: 4
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_writeByte"></a> <em>Stream</em>.<b>writeByte</b>(<em>Byte</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Writes <em>Byte</em> to <em>Stream</em>. The <em>Byte</em> must be an integer between 0 and 255.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(output, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of writing. This error is thrown by the default implementation. </li>
<li><code>instantiation_error</code> - <em>Byte</em> is a variable. </li>
<li><code>type_error(byte, <em>Byte</em>)</code> - <em>Byte</em> is not an integer between 0 and 255.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_readByte">readByte()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_writeln"></a> <em>Stream</em>.<b>writeln</b>(<em>Term</em>) <br/>
 <em>Stream</em>.<b>writeln</b>()</p>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Term</em> is a string, then write it directly to the stream using <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> has the form (<em>A</em> + <em>B</em>), then write <em>A</em> and <em>B</em> to the stream without the plus sign. This rule is applied recursively for writing terms such as (<em>A</em> + <em>B</em> + <em>C</em> + ...). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Term</em> is not a string or of the form (<em>A</em> + <em>B</em>), then write it using <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A newline is written after <em>Term</em>. If <em>Term</em> is omitted, then only a newline is written.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">Answer is 2 + 2;
Stream.writeln(<span class="stringliteral">&quot;The answer is: &quot;</span> + Answer);

The answer is: 4
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_writeString"></a> <em>Stream</em>.<b>writeString</b>(<em>String</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Writes <em>String</em> to <em>Stream</em> as an unquoted string literal. Use <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a> instead to quote the string.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>permission_error(output, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of writing. This error is thrown by the default implementation. </li>
<li><code>instantiation_error</code> - <em>String</em> is a variable. </li>
<li><code>type_error(string, <em>String</em>)</code> - <em>String</em> is not a string.</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_readBytes">readBytes()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeTerm">writeTerm()</a></dd></dl>
<hr/>
 <a class="anchor" id="iostream_writeTerm"></a> <em>Stream</em>.<b>writeTerm</b>(<em>Term</em>) <br/>
 <em>Stream</em>.<b>writeTerm</b>(<em>Term</em>, <em>Vars</em>)</p>
<dl class="user"><dt><b>Description</b></dt><dd>Write <em>Term</em> to <em>Stream</em> in a form that is compatible with the Plang source parser for <a class="el" href="syntax_terms.html">terms</a>. The <em>Term</em> is not terminated with a "." or end of line marker. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Vars</em> is present, then it must be a list of <em>Name</em> = <em>Var</em> declarations. If <em>Var</em> is encountered as an unbound variable in <em>Term</em>, then it will be written to <em>Stream</em> as <em>Name</em>. Variables not listed in <em>Vars</em> will be written as "_N", where "N" is the variable's pointer value. If <em>Vars</em> is not present, then all unbound variables are written as "_N". <em>Name</em> must be an atom or string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default implementation will call <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a> with a succession of string values, each making up a part of <em>Term</em>. It is undefined as to which parts of <em>Term</em> each string corresponds to, other than the requirement that the strings must serialize the <em>Term</em> from left to right.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Vars</em> is a variable. </li>
<li><code>type_error(variable_names, <em>Vars</em>)</code> - <em>Vars</em> is not a valid list of variable names. </li>
<li><code>permission_error(output, stream, <em>Stream</em>)</code> - <em>Stream</em> is not capable of writing.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment">Stream.writeTerm(A - B * 1.5 + pi / 2);
    produces: _1f95460 - _1f95420 * 1.5 + pi / 2

Stream.writeTerm(A - B * 1.5 + pi / 2, [<span class="stringliteral">&quot;A&quot;</span> = A, <span class="stringliteral">&quot;B&quot;</span> = B]);
    produces: A - B * 1.5 + pi / 2
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__class__iostream.html#iostream_canWrite">canWrite()</a>, <a class="el" href="group__class__iostream.html#iostream_flush">flush()</a>, <a class="el" href="group__class__iostream.html#iostream_readLine">readLine()</a>, <a class="el" href="group__class__iostream.html#iostream_write">write()</a>, <a class="el" href="group__class__iostream.html#iostream_writeByte">writeByte()</a>, <a class="el" href="group__class__iostream.html#iostream_writeln">writeln()</a>, <a class="el" href="group__class__iostream.html#iostream_writeString">writeString()</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
