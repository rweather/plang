<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Issues with Prolog</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="issues_with_prolog">Issues with Prolog </a></h1><p>This page discusses some of the issues in conventional Prolog systems which have motivated Plang's design:</p>
<ul>
<li><a class="el" href="issues_with_prolog.html#prolog_cryptic">Cryptic syntax</a> </li>
<li><a class="el" href="issues_with_prolog.html#prolog_sugar">Syntactic sugar is not harmful!</a> </li>
<li><a class="el" href="issues_with_prolog.html#prolog_procedural">Procedural code happens</a> </li>
<li><a class="el" href="issues_with_prolog.html#prolog_freeze">Unwanted unification</a></li>
</ul>
<h2><a class="anchor" id="prolog_cryptic">
Cryptic syntax</a></h2>
<p>Logic programming is a very powerful concept, able to express problems in artificial intelligence, theorem proving, and natural deduction very compactly. It is unfortunate that new users are often turned off by the cryptic nature of the traditional logic programming languages. The following are some examples (this list is not intended to be exhaustive):</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>: <code>!</code>, <code>(A -&gt; B ; C)</code> </li>
<li><a href="http://www.sics.se/isl/sicstus/docs/latest/html/sicstus.html">SICStus Prolog</a>: <code>PointObj &gt;&gt; x(InitX)</code> to fetch the value of the property <code>x</code>. </li>
<li><a href="http://en.wikipedia.org/wiki/Cyc">Cyc</a>: <code>(#$capitalCity #$France #$Paris)</code></li>
</ul>
<p>A proficient user of these languages will no doubt see no problem with the above examples. However, the learning curve for a new user of the language can be quite steep. Key to Plang's design is the principle of <em>use conventional syntax to perform conventional tasks</em>.</p>
<p>For Plang, <em>conventional</em> means syntactic conventions that mainstream programmers are already familiar with. The following code is instantly recognizable:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (X &lt; Y)
    A;
<span class="keywordflow">else</span>
    B;
</pre></div><p>The Prolog equivalent is not obvious to the uninitiated without consulting the language manual:</p>
<div class="fragment"><pre class="fragment">(X &lt; Y) -&gt; A ; B
</pre></div><p>The Prolog version is also error-prone. The following two statements are not equivalent:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (X &lt; Y) A;

(X &lt; Y) -&gt; A
</pre></div><p>The user's natural interpretation is that execution should continue with the next statement if the condition is false. In Prolog however, the <code>-&gt;</code> operator will fail the entire clause if the condition is false and there is no "else" clause. It is necessary to do this instead to capture the user's actual intent:</p>
<div class="fragment"><pre class="fragment">(X &lt; Y) -&gt; A ; <span class="keyword">true</span>
</pre></div><p>In Plang, <a class="el" href="group__logic__and__control.html#commit_0">commit</a> can be used in place of <b>!</b>, because that is what the traditional Prolog "cut" does - commits the program to the current clause choice. For example, the following predicate is a safe version of list membership checking that does not loop infinitely if the list tail is a variable:</p>
<div class="fragment"><pre class="fragment">is_member(X, L) { var(L); commit; fail; }
is_member(X, [X|_]) { commit; }
is_member(X, [_|T]) { is_member(X, T); }
</pre></div><h2><a class="anchor" id="prolog_sugar">
Syntactic sugar is not harmful!</a></h2>
<p>The <code>-&gt;</code> operator in the previous section is an example of syntactic sugar. Many Prolog systems will compile <code>(A -&gt; B ; C)</code> by expanding it into normal Horn clause form first:</p>
<div class="fragment"><pre class="fragment">if_stmt_123 :- A, !, B.
if_stmt_123 :- C.
</pre></div><p>Oddly though, adding syntactic sugar for loop constructs is considered heretical. The following tail-recursive predicate iterates over all members of a list and performs an action:</p>
<div class="fragment"><pre class="fragment">perform_action([]).
perform_action([Head|Tail]) :- action(Head), perform_action(Tail).
</pre></div><p>Except this code is dangerous if the <code>Tail</code> is a variable. It may enter an infinite loop. A safer version is:</p>
<div class="fragment"><pre class="fragment">perform_action(List) :- var(List), !, fail.
perform_action([]).
perform_action([Head|Tail]) :- action(Head), perform_action(Tail).
</pre></div><p>In Plang, this can be expressed as follows:</p>
<div class="fragment"><pre class="fragment">perform_action(List)
{
    <span class="keywordflow">for</span> (X in List)
        action(X);
}
</pre></div><p>This version is more obvious as to what it is doing, and closer to how a regular programmer thinks about solving the problem. The Plang parser internally expands the <a class="el" href="group__logic__and__control.html#for_stmt">for</a> loop to a hidden predicate similar in structure to <code>perform_action</code> above.</p>
<p>Another more involved example happens in programs that prompt the user for commands and then execute those commands. The programmer wants to write something like this:</p>
<div class="fragment"><pre class="fragment">main_loop()
{
    <span class="keywordflow">do</span> {
        read_command(Cmd);
        <span class="keywordflow">switch</span> (Cmd) {
        <span class="keywordflow">case</span> <span class="stringliteral">&apos;save&apos;</span>: save_to_file();
        <span class="keywordflow">case</span> <span class="stringliteral">&apos;load&apos;</span>: load_from_file();
        ...
        <span class="keywordflow">case</span> <span class="stringliteral">&apos;quit&apos;</span>: Quit = yes;
        <span class="keywordflow">default</span>:     stdout::writeln(<span class="stringliteral">&apos;Invalid command&apos;</span>);
        }
    } <span class="keywordflow">while</span> (Quit !== yes);
}
</pre></div><p>Prolog instead forces the code to be unwound into multiple predicates:</p>
<div class="fragment"><pre class="fragment">main_loop :-
    read_command(Cmd),
    (Cmd !== quit -&gt;
        execute_command(Cmd),
        main_loop
    ; <span class="keyword">true</span>).

execute_command(save) :- !, save_to_file.
execute_command(load) :- !, load_from_file.
...
execute_command(X) :- !, write(<span class="stringliteral">&apos;Invalid command&apos;</span>), nl.
</pre></div><p>With multiple levels of commands, parameter error reporting, and so on, this can very quickly snowball into dozens of predicates micro-managing each tiny step. Plang's design recognizes that breaking code up into tiny steps is a job for a compiler, not a human!</p>
<h2><a class="anchor" id="prolog_procedural">
Procedural code happens</a></h2>
<p>One response to the previous examples is that they are procedural rather than declarative, which is against "The Prolog Way". However, code like the command processor above happens a lot in Prolog applications. Most applications have two main aspects:</p>
<ul>
<li>The core problem in theorem proving, artificial intelligence, etc, that the application is trying to solve. </li>
<li>The application shell that awaits user input, or reads data from a file, and calls the core problem solver as needed.</li>
</ul>
<p>The first aspect needs the full power of backtracking search to solve it. The second does not - it is implicitly procedural. It is possible (and encouraged!) to write declarative Horn clauses in Plang, but the language doesn't make it unnecessarily difficult to do other things as well.</p>
<h2><a class="anchor" id="prolog_freeze">
Unwanted unification</a></h2>
<p>It is very easy in Prolog to write a predicate that "over-unifies" its arguments, making it difficult to write certain kinds of matching algorithms. For example, the following predicate expands expressions in its first argument using the normal rules of arithmetic:</p>
<div class="fragment"><pre class="fragment">expand(A * (B + C), A * B + A * C).
expand((A + B) * C, A * C + B * C).
</pre></div><p>If we were to call <code>expand((X + Y) * Z, Solution)</code>, then the predicate will respond with the following solutions:</p>
<div class="fragment"><pre class="fragment">(X + Y) * B + (X + Y) * C   where Z = B + C
X * Z + Y * Z
</pre></div><p>Clearly, only the second of these is what we intended with the predicate. The issue is that we want variables in the clause arguments (A, B, and C) to be bound, but not variables in the value we passed in (X, Y, and Z).</p>
<p>Traditional Prolog implementations often have a predicate that can freeze or lock a term to prevent unification of its variables. The drawback with that approach is that it requires the caller to know the internal details of the callee and then take steps to protect its terms from unexpected unification. This breaks encapsulation. Plang's solution is <a class="el" href="syntax_input_only.html">input-only arguments</a> and <a class="el" href="group__unification.html#unify_one_way_2">one-way unification</a>. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
