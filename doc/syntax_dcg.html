<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Language syntax - Definite clause grammars</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="syntax_dcg">Language syntax - Definite clause grammars </a></h1><h2><a class="anchor" id="dcg_intro">
Introduction</a></h2>
<p>Definite clause grammars (DCG's) are used to describe parser frameworks for formal or natural languages. The following example adapted from <a href="http://en.wikipedia.org/wiki/Definite_clause_grammar">Wikipedia</a> can parse a subset of English sentences:</p>
<div class="fragment"><pre class="fragment">sentence --&gt; noun_phrase, verb_phrase.
noun_phrase --&gt; det, noun.
verb_phrase --&gt; verb, noun_phrase.
det --&gt; <span class="stringliteral">&quot;the&quot;</span>.
det --&gt; <span class="stringliteral">&quot;a&quot;</span>.
noun --&gt; <span class="stringliteral">&quot;cat&quot;</span>.
noun --&gt; <span class="stringliteral">&quot;bat&quot;</span>.
verb --&gt; <span class="stringliteral">&quot;eats&quot;</span>.
</pre></div><p>The first rule can be read as "a sentence is a noun phrase
followed by a verb phrase". DCG rules are translated into ordinary predicates by the Plang parser. The predicates take two arguments for the front and end of a "difference list":</p>
<div class="fragment"><pre class="fragment">sentence(L1, L3) { noun_phrase(L1, L2); verb_phrase(L2, L3); }
noun_phrase(L1, L3) { det(L1, L2); noun(L2, L3); }
verb_phrase(L1, L3) { verb(L1, L2); noun_phrase(L2, L3); }
det([<span class="stringliteral">&quot;the&quot;</span>|L], L).
det([<span class="stringliteral">&quot;a&quot;</span>|L], L).
noun([<span class="stringliteral">&quot;cat&quot;</span>|L], L).
noun([<span class="stringliteral">&quot;bat&quot;</span>|L], L).
verb([<span class="stringliteral">&quot;eats&quot;</span>|L], L).
</pre></div><p>Once the rules have been compiled, the program can be queried for valid sentences:</p>
<div class="fragment"><pre class="fragment">sentence([<span class="stringliteral">&quot;the&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;eats&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bat&quot;</span>], [])            succeeds
sentence([&quot;the&quot;, &quot;cat&quot;, &quot;killed&quot;, &quot;a&quot;, &quot;bat&quot;], [])          fails
</pre></div><p>The second sentence fails because "killed" is not listed as a valid verb.</p>
<h2><a class="anchor" id="dcg_wordnet">
DCG's and WordNet</a></h2>
<p>The <a class="el" href="group__module__words.html">words</a> module provides access to the <a href="http://wordnet.princeton.edu/">WordNet</a> lexical database from Princeton University. The database contains huge amounts of information about English words, particularly their part of speech (noun, verb, adverb, or adjective). This information can be very useful when building Natural Language Processing systems in Plang. The example above can be re-expressed as follows:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(words).
sentence --&gt; noun_phrase, verb_phrase.
noun_phrase --&gt; det, words::noun.
verb_phrase --&gt; words::verb, noun_phrase.
det --&gt; <span class="stringliteral">&quot;the&quot;</span>.
det --&gt; <span class="stringliteral">&quot;a&quot;</span>.
</pre></div><p>Now it is no longer necessary to explicitly list every noun and verb in the English language to parse useful sentences:</p>
<div class="fragment"><pre class="fragment">sentence([<span class="stringliteral">&quot;the&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;eats&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bat&quot;</span>], [])            succeeds
sentence([&quot;the&quot;, &quot;cat&quot;, &quot;killed&quot;, &quot;a&quot;, &quot;bat&quot;], [])          succeeds
sentence([&quot;the&quot;, &quot;car&quot;, &quot;killed&quot;, &quot;a&quot;, &quot;pedestrian&quot;], [])   succeeds
</pre></div><p>See the documentation for the <a class="el" href="group__module__words.html">words</a> module for more information on using WordNet with Plang.</p>
<h2><a class="anchor" id="dcg_parse_trees">
Building parse trees</a></h2>
<p>Usually an application wants to do more with a sentence than just check if it is valid. The applications wants to also extract a parse tree that describes the major features of the sentence to perform further processing. DCG rules can be augmented with parameters to build such a parse tree:</p>
<div class="fragment"><pre class="fragment">:- <span class="keyword">import</span>(words).
sentence(s(NP, VP)) --&gt; noun_phrase(NP), verb_phrase(VP).
noun_phrase(np(D, N)) --&gt; det(D), words::noun(N).
verb_phrase(vp(V, NP)) --&gt; words::verb(V), noun_phrase(NP).
det(d(<span class="stringliteral">&quot;the&quot;</span>)) --&gt; <span class="stringliteral">&quot;the&quot;</span>.
det(d(<span class="stringliteral">&quot;a&quot;</span>)) --&gt; <span class="stringliteral">&quot;a&quot;</span>.
</pre></div><p>We can now generate parse trees with the augmented predicates:</p>
<div class="fragment"><pre class="fragment">sentence(Tree, [<span class="stringliteral">&quot;the&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;eats&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bat&quot;</span>], [])

Tree = s(np(d(&quot;the&quot;), n(&quot;cat&quot;)), vp(&quot;eats&quot;, np(d(&quot;a&quot;), n(&quot;bat&quot;))))
</pre></div><h2><a class="anchor" id="dcg_rules">
DCG rule types</a></h2>
<p>The most common DCG rules express how to convert a head production into a body made up of the concatenation of other productions:</p>
<div class="fragment"><pre class="fragment">verb_phrase --&gt; words::verb, noun_phrase.
</pre></div><p>Multiple rules for the same head can be specified to provide alternatives:</p>
<div class="fragment"><pre class="fragment">verb_phrase --&gt; words::verb, noun_phrase.
verb_phrase --&gt; words::verb, pronoun(<span class="keywordtype">object</span>).
</pre></div><p>Alternatives can also be specified using the <b>(||)/2</b> operator:</p>
<div class="fragment"><pre class="fragment">verb_phrase --&gt; words::verb, noun_phrase || words::verb, pronoun(<span class="keywordtype">object</span>).
</pre></div><p>Alternatives can also appear in the body of a rule when surrounded by parentheses:</p>
<div class="fragment"><pre class="fragment">verb_phrase --&gt; words::verb, (noun_phrase || pronoun(<span class="keywordtype">object</span>)).
</pre></div><p>Sometimes a rule is only valid if the following text does not have a certain form. This can be expressed using the <b>(!)/1</b> operator. The following rule can be read as "a foo is a bar, but only if the bar is not followed by a baz":</p>
<div class="fragment"><pre class="fragment">foo --&gt; bar, !baz.
</pre></div><p>Rule commitment can be expressed using the <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> or <a class="el" href="group__logic__and__control.html#cut_0">!/0</a> operators. In the following example, if b is followed by c, then the DCG rule set will commit to using the first rule and try to match against d. If the text after c does not match d, then the parse fails rather than retry with e instead of c.</p>
<div class="fragment"><pre class="fragment">a --&gt; b, c, commit, d.
a --&gt; b, e.
</pre></div><p>The above rules can also be written as:</p>
<div class="fragment"><pre class="fragment">a --&gt; b, c, !, d.
a --&gt; b, e.
</pre></div><p>Literals strings or atoms for matching are expressed as lists:</p>
<div class="fragment"><pre class="fragment">noun --&gt; [<span class="stringliteral">&quot;cat&quot;</span>].
noun --&gt; [<span class="stringliteral">&quot;bat&quot;</span>].
noun --&gt; [<span class="stringliteral">&quot;bobby&quot;</span>, <span class="stringliteral">&quot;fischer&quot;</span>].
noun --&gt; [dog].
</pre></div><p>As a short-hand, it is possible to drop the list brackets if the literal is a string (but not an atom):</p>
<div class="fragment"><pre class="fragment">noun --&gt; <span class="stringliteral">&quot;cat&quot;</span>.
noun --&gt; <span class="stringliteral">&quot;bat&quot;</span>.
noun --&gt; <span class="stringliteral">&quot;bobby&quot;</span>, <span class="stringliteral">&quot;fischer&quot;</span>.
noun --&gt; dog.   <span class="comment">// expands to the dog rule, not the word &quot;dog&quot;.</span>
</pre></div><p>The empty list can be used to match nothing, which is useful for optional rules:</p>
<div class="fragment"><pre class="fragment">optional_foo --&gt; foo.
optional_foo --&gt; [].
</pre></div><p>Sometimes a parse rule cannot be expressed directly in DCG syntax. For example, recognizing an integer value - enumerating all of the integers in list literals is impractical. This case can be handled by embedding a statement into the rule to perform additional checks:</p>
<div class="fragment"><pre class="fragment">expression --&gt; integer_value.
expression --&gt; expression, <span class="stringliteral">&quot;+&quot;</span>, integer_value.

integer_value --&gt; [X], { integer(X); }.
</pre></div><p>Another method is to use a custom predicate of arity 2 instead of the rule:</p>
<div class="fragment"><pre class="fragment">expression --&gt; integer_value.
expression --&gt; expression, <span class="stringliteral">&quot;+&quot;</span>, integer_value.

integer_value([X|Tail], Tail)
{
    integer(X);
}
</pre></div><p>This is essentially what the <a class="el" href="group__module__words.html">words</a> module does for recognizing nouns, verbs, adjectives, and adverbs from WordNet. The module provides custom predicates that look and act like DCG rules.</p>
<h2><a class="anchor" id="dcg_fuzzy">
Fuzzy DCG rules</a></h2>
<p>DCG rules can be annotated with <a class="el" href="group__fuzzy__logic.html">fuzzy logic</a> to express the degree of confidence that the rule has in a particular sentence parse:</p>
<div class="fragment"><pre class="fragment">verb_phrase --&gt; verb &lt;&lt;0.7&gt;&gt;.
verb_phrase --&gt; verb, noun_phrase &lt;&lt;0.3&gt;&gt;.
</pre></div><p>When a grammar is ambiguous, this can help determine which of several parses for a sentence is the most likely.</p>
<h2><a class="anchor" id="dcg_formal">
Formal syntax of DCG rules</a></h2>
<div class="fragment"><pre class="fragment">dcg_rule --&gt; dcg_head, <span class="stringliteral">&quot;--&gt;&quot;</span>, dcg_body, <span class="stringliteral">&quot;.&quot;</span>.
dcg_rule --&gt; dcg_head, <span class="stringliteral">&quot;--&gt;&quot;</span>, dcg_body, dcg_confidence, <span class="stringliteral">&quot;.&quot;</span>.

dcg_head --&gt; atom.
dcg_head --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, arguments, <span class="stringliteral">&quot;)&quot;</span>.
dcg_head --&gt; atom, <span class="stringliteral">&quot;(&quot;</span>, <span class="stringliteral">&quot;)&quot;</span>.

dcg_body --&gt; dcg_term.
dcg_body --&gt; dcg_body, <span class="stringliteral">&quot;||&quot;</span>, dcg_term.

dcg_term --&gt; dcg_neg.
dcg_term --&gt; dcg_term, <span class="stringliteral">&quot;,&quot;</span>, dcg_neg.

dcg_neg  --&gt; dcg_prim.
dcg_neg  --&gt; <span class="stringliteral">&quot;!&quot;</span>, dcg_prim.

dcg_prim --&gt; dcg_head.
dcg_prim --&gt; compound_statement.
dcg_prim --&gt; <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>.
dcg_prim --&gt; <span class="stringliteral">&quot;[&quot;</span>, arguments, <span class="stringliteral">&quot;]&quot;</span>.
dcg_prim --&gt; <span class="keywordtype">string</span>.
dcg_prim --&gt; <span class="stringliteral">&quot;(&quot;</span>, dcg_body, <span class="stringliteral">&quot;)&quot;</span>.
dcg_prim --&gt; <span class="stringliteral">&quot;!&quot;</span>.
dcg_prim --&gt; <span class="stringliteral">&quot;commit&quot;</span>.

dcg_confidence --&gt; <span class="stringliteral">&quot;&lt;&lt;&quot;</span>, integer, <span class="stringliteral">&quot;&gt;&gt;&quot;</span>.
dcg_confidence --&gt; <span class="stringliteral">&quot;&lt;&lt;&quot;</span>, float, <span class="stringliteral">&quot;&gt;&gt;&quot;</span>.
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
