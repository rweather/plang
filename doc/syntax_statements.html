<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Language syntax - Statements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="syntax_statements">Language syntax - Statements </a></h1><ul>
<li><a class="el" href="syntax_statements.html#syntax_term_stmt">Term statements</a> </li>
<li><a class="el" href="syntax_statements.html#syntax_compound_stmt">Compound statements</a> </li>
<li><a class="el" href="syntax_statements.html#syntax_if_stmt">If statements</a> </li>
<li><a class="el" href="syntax_statements.html#syntax_loop_stmt">Loop statements</a> </li>
<li><a class="el" href="syntax_statements.html#syntax_try_stmt">Try statements</a> </li>
<li><a class="el" href="syntax_statements.html#syntax_switch_stmt">Switch statements</a></li>
</ul>
<div class="fragment"><pre class="fragment">statement --&gt; term_statement.
statement --&gt; compound_statement.
statement --&gt; if_statement.
statement --&gt; loop_statement.
statement --&gt; try_statement.
statement --&gt; switch_statement.
</pre></div><h2><a class="anchor" id="syntax_term_stmt">
Term statements</a></h2>
<p>Almost any Plang <a class="el" href="syntax_terms.html">term</a> can be used as a statement, as long as the outermost operator has a priority less than <b>(,)/2</b>, or is bracketed. This is typically referred to as an "argument term" because such terms normally appear as the arguments to predicate calls.</p>
<div class="fragment"><pre class="fragment">term_statement --&gt; argument_term, <span class="stringliteral">&quot;;&quot;</span>.
</pre></div><p>The following are some examples of term statements:</p>
<div class="fragment"><pre class="fragment">X = f(Y);
stdout::writeln(<span class="stringliteral">&quot;Hello World!&quot;</span>);
parent(P, C);
(V = 1, W = a || V = 2, W = b);
</pre></div><p>At runtime, the term is evaluated as a predicate call, which will either succeed, fail, or throw an error. If the term succeeds, then execution continues with the next statement. If the term fails, then Plang will backtrack and find an alternative solution. If the term throws an error, then control passes to the <a class="el" href="syntax_statements.html#syntax_try_stmt">try</a> statement that has a <a class="el" href="syntax_statements.html#syntax_try_stmt">catch</a> clause matching the error.</p>
<p>There is a special term statement, consisting of only a semi-colon, that is equivalent to <a class="el" href="group__logic__and__control.html#true_0">true/0</a>:</p>
<div class="fragment"><pre class="fragment">term_statement --&gt; <span class="stringliteral">&quot;;&quot;</span>.
</pre></div><h2><a class="anchor" id="syntax_compound_stmt">
Compound statements</a></h2>
<p>Compound statements are surrounded with curly braces, as in C:</p>
<div class="fragment"><pre class="fragment">compound_statement --&gt; <span class="stringliteral">&quot;{&quot;</span>, statements, <span class="stringliteral">&quot;}&quot;</span>.
compound_statement --&gt; <span class="stringliteral">&quot;{&quot;</span>, <span class="stringliteral">&quot;}&quot;</span>.

statements --&gt; statement.
statements --&gt; statements, statement.
</pre></div><h2><a class="anchor" id="syntax_if_stmt">
If statements</a></h2>
<p>Conditional statements can be expressed with the <a class="el" href="group__logic__and__control.html#if_stmt">if</a> statement:</p>
<dl class="user"><dt><b></b></dt><dd><b>if</b> (<em>Goal1</em>) <em>Goal2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>if</b> (<em>Goal1</em>) <em>Goal2</em> <b>else</b> <em>Goal3</em> </dd></dl>
<p><em>Goal1</em> is executed, and if it succeeds then <em>Goal2</em> is executed. If <em>Goal1</em> fails, then <em>Goal3</em> is executed. If <em>Goal3</em> is omitted, then the statement succeeds if <em>Goal1</em> fails.</p>
<p><em>Goal1</em> is only executed once. An implicit <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> is performed if <em>Goal1</em> succeeds. <em>Goal2</em> and <em>Goal3</em> may involve alternatives.</p>
<p>The formal syntax is as follows:</p>
<div class="fragment"><pre class="fragment">if_statement --&gt; <span class="stringliteral">&quot;if&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>, statement.
if_statement --&gt; <span class="stringliteral">&quot;if&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>, statement, <span class="stringliteral">&quot;else&quot;</span>, statement.
</pre></div><p>Conditional statements can also be written using the <a class="el" href="group__logic__and__control.html#if_stmt">(-&gt;)/2</a> and <a class="el" href="group__logic__and__control.html#logical_or_2">(||)/2</a> predicates:</p>
<dl class="user"><dt><b></b></dt><dd><b></b>(<em>Goal1</em> <b>-&gt;</b> <em>Goal2</em> <b>||</b> <b>true</b>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b></b>(<em>Goal1</em> <b>-&gt;</b> <em>Goal2</em> <b>||</b> <em>Goal3</em>)</dd></dl>
<p>The <b>if</b> statement form is recommended unless the conditional appears within an argument to <a class="el" href="group__logic__and__control.html#call_1">call/1</a>.</p>
<p><a class="anchor" id="syntax_do_stmt"></a> <a class="anchor" id="syntax_for_stmt"></a> <a class="anchor" id="syntax_while_stmt"></a> </p>
<h2><a class="anchor" id="syntax_loop_stmt">
Loop statements</a></h2>
<p>Loops are expressed using the <a class="el" href="group__logic__and__control.html#do_stmt">do</a>, <a class="el" href="group__logic__and__control.html#for_stmt">for</a>, and <a class="el" href="group__logic__and__control.html#while_stmt">while</a> keywords.</p>
<dl class="user"><dt><b></b></dt><dd><b>do</b> { <em>Statements</em> } (<em>Condition</em>); </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>for</b> (<em>Variable</em> <b>in</b> <em>List</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>while</b> (<em>Condition</em>) <em>Statement</em> </dd></dl>
<p>The semantics is similar to the corresponding loop constructs in C. The <b>do</b> statement executes <em>Statements</em> until <em>Condition</em> succeeds. The <b>for</b> statement executes <em>Statement</em> for each element of <em>List</em>, binding <em>Variable</em> to each in turn. The <b>while</b> statement executes <em>Statement</em> while <em>Condition</em> succeeds. The following code prints the first five powers of 2:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (X in [2, 4, 8, 16, 32]) {
    stdout::writeln(X);
}
</pre></div><p>We may instead want to express this loop as:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (X in [1, 2, 3, 4, 5]) {
    Y is 2 ** X;
    stdout::writeln(Y);
}
</pre></div><p>However, there is a problem. After the first loop iteration, Y will be bound to 2. In the second loop iteration, 2 will not unify with 4 (the new value of Y) and the loop fails. The solution is to list the local variables in the loop that must be unbound each time around the loop:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> [Y] (X in [1, 2, 3, 4, 5]) {
    Y is 2 ** X;
    stdout::writeln(Y);
}
</pre></div><p>The <code>X</code> variable in the <b>for</b> loop is implicitly added to the list of variables to unbind.</p>
<p>All of the loop statements can take a list of variables to unbind each time around the loop:</p>
<dl class="user"><dt><b></b></dt><dd><b>do</b> [<em>UnbindVars</em>] { <em>Statements</em> } (<em>Condition</em>); </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>for</b> [<em>UnbindVars</em>] (<em>Variable</em> <b>in</b> <em>List</em>) <em>Statement</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>while</b> [<em>UnbindVars</em>] (<em>Condition</em>) <em>Statement</em> </dd></dl>
<p>The formal syntax for loop statements is as follows:</p>
<div class="fragment"><pre class="fragment">loop_statement --&gt; <span class="stringliteral">&quot;do&quot;</span>, unbind_vars, compound_statement,
                        <span class="stringliteral">&quot;while&quot;</span> <span class="stringliteral">&quot;(&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>, <span class="stringliteral">&quot;;&quot;</span>.
loop_statement --&gt; <span class="stringliteral">&quot;for&quot;</span>, unbind_vars, <span class="stringliteral">&quot;(&quot;</span>, variable, <span class="stringliteral">&quot;in&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>,
                        statement.
loop_statement --&gt; <span class="stringliteral">&quot;while&quot;</span>, unbind_vars, <span class="stringliteral">&quot;(&quot;</span>, term, <span class="stringliteral">&quot;)&quot;</span>, statement.

unbind_vars --&gt; [].
unbind_vars --&gt; <span class="stringliteral">&quot;[&quot;</span>, <span class="stringliteral">&quot;]&quot;</span>.
unbind_vars --&gt; <span class="stringliteral">&quot;[&quot;</span>, unbind_var_list, <span class="stringliteral">&quot;]&quot;</span>.

unbind_var_list --&gt; variable.
unbind_var_list --&gt; unbind_var_list, <span class="stringliteral">&quot;,&quot;</span>, variable.
</pre></div><h2><a class="anchor" id="syntax_try_stmt">
Try statements</a></h2>
<p>Try/catch statements are used to catch errors that were thrown by the <a class="el" href="group__logic__and__control.html#throw_1">throw/1</a> predicate.</p>
<dl class="user"><dt><b></b></dt><dd><b>try</b> { <em>Statements</em> } <b>catch</b> (<em>Pattern1</em>) { <em>Recovery1</em> } <b>catch</b> (<em>Pattern2</em>) { <em>Recovery2</em> } ...</dd></dl>
<p>The <a class="el" href="group__logic__and__control.html#catch_3">try</a> statement executes <em>Statements</em> and succeeds or fails accordingly. If one of the <em>Statements</em> throws an error with <a class="el" href="group__logic__and__control.html#throw_1">throw/1</a>, and the error can be unified with <em>PatternN</em>, then <em>RecoveryN</em> will be executed. If the error does not unify with any of the patterns, then the error will continue to be thrown further up the call chain.</p>
<p>It is possible for <em>Statements</em> to succeed and then for execution to backtrack into the body of <em>Statements</em> seeking another solution. When that happens, a thrown error the second time may be caught by the <b>catch</b> clauses.</p>
<div class="fragment"><pre class="fragment">try_statement --&gt; <span class="stringliteral">&quot;try&quot;</span>, compound_statement, catch_clauses.

catch_clauses --&gt; catch_clause.
catch_clauses --&gt; catch_clauses, <span class="stringliteral">&quot;,&quot;</span>, catch_clause.

catch_clause --&gt; <span class="stringliteral">&quot;catch&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, argument_term, <span class="stringliteral">&quot;)&quot;</span>, compound_statement.
</pre></div><h2><a class="anchor" id="syntax_switch_stmt">
Switch statements</a></h2>
<p>The <a class="el" href="group__logic__and__control.html#switch_stmt">switch</a> statement is used to choose between a number of labels, seeking the first that unifies with a term.</p>
<dl class="user"><dt><b></b></dt><dd><b>switch</b> (<em>Term</em>) { <b>case</b> <em>Label1:</em> <em>Statement1</em>; ...; <b>case</b> <em>LabelN:</em> <em>StatementN</em>; <b>default:</b> <em>DefaultStatement</em>; }</dd></dl>
<p>Finds the first <em>LabelM</em> term in the <b>case</b> list that unifies with <em>Term</em>, and executes the associated <em>StatementM</em>. If none of the <b>case</b> labels match, then executes the <em>DefaultStatement</em> associated with the <b>default</b> label. If there is no <b>default</b> label, then the <b>switch</b> statement fails.</p>
<p>Multiple case labels can be specified for the same statement with <b>case</b> <em>Label1:</em> <b>case</b> <em>Label2:</em> ... <b>case</b> <em>LabelN:</em> <em>Statement</em>. The <b>default</b> label can be mixed with regular <b>case</b> labels.</p>
<p>Unlike C, execution does not fall through from <em>StatementM</em> to the following <em>StatementM+1</em>.</p>
<p>Once a <em>LabelM</em> is found that unifies with <em>Term</em>, the <b>switch</b> statement does an implicit <a class="el" href="group__logic__and__control.html#commit_0">commit/0</a> to commit the clause to that choice. Backtracking does not select later <b>case</b> labels even if they may have otherwise unified with <em>Term</em>.</p>
<p>The following is an example of an expression evaluator using <b>switch:</b> </p>
<div class="fragment"><pre class="fragment">eval(Term, Answer) {
    <span class="keywordflow">switch</span> (Term) {
        <span class="keywordflow">case</span> X + Y: {
            eval(X, XAnswer);
            eval(Y, YAnswer);
            Answer is XAnswer + YAnswer;
        }
        <span class="keywordflow">case</span> X - Y: {
            eval(X, XAnswer);
            eval(Y, YAnswer);
            Answer is XAnswer - YAnswer;
        }
        <span class="keywordflow">case</span> X * Y: {
            eval(X, XAnswer);
            eval(Y, YAnswer);
            Answer is XAnswer * YAnswer;
        }
        <span class="keywordflow">case</span> X / Y: {
            eval(X, XAnswer);
            eval(Y, YAnswer);
            Answer is XAnswer / YAnswer;
        }
        <span class="keywordflow">case</span> -X: {
            eval(X, XAnswer);
            Answer is -XAnswer;
        }
        <span class="keywordflow">default</span>: {
            <span class="keywordflow">if</span> (number(Term))
                Answer = Term;
            <span class="keywordflow">else</span>
                lookup_variable(Term, Answer);
        }
    }
}

eval(2 * x + y, Answer)
</pre></div><p>The formal syntax for <b>switch</b> statements is as follows:</p>
<div class="fragment"><pre class="fragment">switch_statement --&gt; <span class="stringliteral">&quot;switch&quot;</span>, <span class="stringliteral">&quot;(&quot;</span>, argument_term, <span class="stringliteral">&quot;)&quot;</span>, switch_body.

switch_body --&gt; <span class="stringliteral">&quot;{&quot;</span>, switch_cases, <span class="stringliteral">&quot;}&quot;</span>.
switch_body --&gt; <span class="stringliteral">&quot;{&quot;</span>, <span class="stringliteral">&quot;}&quot;</span>.

switch_cases --&gt; switch_case.
switch_cases --&gt; switch_cases, <span class="stringliteral">&quot;,&quot;</span>, switch_case.

switch_case --&gt; case_labels, statement.

case_labels --&gt; case_label.
case_labels --&gt; case_labels, case_label.

case_label --&gt; <span class="stringliteral">&quot;case&quot;</span>, argument_term, <span class="stringliteral">&quot;:&quot;</span>.
case_label --&gt; <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>.
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
