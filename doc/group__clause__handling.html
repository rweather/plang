<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Builtin predicates - Clause handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Builtin predicates - Clause handling</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Predicates in this group are used to add and remove clauses from the predicate database dynamically. There are two types of databases in the Plang system: <em>global</em> and <em>local</em>.</p>
<p>The global database is shared between all parts of the Plang system and contains the following:</p>
<ul>
<li><a class="el" href="group__predicates.html">Builtin predicates</a>. </li>
<li>Predicates and class member predicates from imported <a class="el" href="group__modules.html">modules</a>. </li>
<li>User-defined predicates from the application source code. </li>
<li>Dynamic predicates defined at runtime with <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a> and <a class="el" href="group__clause__handling.html#assertz_1">assertz/1</a>.</li>
</ul>
<p>As an example, we consider a theorem prover for propositional logic. The prover needs simplification rules to convert complex logical expressions into simpler ones. Rather than fix the set of rules at compile time, the theorem prover allows the user to add new rules at runtime. To support this, we declare the <b>simplify/2</b> predicate as dynamic and add the predefined rules as follows:</p>
<div class="fragment"><pre class="fragment"> :- dynamic(simplify/2).
 add_rules()
 {
     assertz(simplify(in A &amp;&amp; A, A));
     assertz(simplify(in B || <span class="keyword">true</span>, <span class="keyword">true</span>));
     ...
 }
</pre></div><p>To use the rules to simplify a logical expression, the application calls the <b>simplify/2</b> predicate in the usual fashion:</p>
<div class="fragment"><pre class="fragment"> simplify(Expr, Simplified);
</pre></div><p>When the user supplies a new rule, the application can call <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a> or <a class="el" href="group__clause__handling.html#assertz_1">assertz/1</a> to add the new rule to the start or end of the existing dynamic clause list. Rules that are no longer needed can be removed with <a class="el" href="group__clause__handling.html#retract_1">retract/1</a>.</p>
<p>In practice, theorem provers rarely implement a single theory of logic. We want our prover to be extensible from propositional logic to first order logic, higher order logic, and so on. Each logical theory will need its own simplification rules. We could define separate global predicates for each theory: <b>prop_simplify/2</b>, <b>fo_simplify/2</b>, etc. An alternative is to use local databases.</p>
<p>The application creates local databases with <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a> to store additional predicates that are generated at runtime. Each local database defines a separate scope - the same predicate name can have different purposes in different local databases.</p>
<p>Returning to our example, we will create a generic class to hold information about a logical theory. The constructor creates a new local database to hold the rules that make up the theory:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>theory
 {
     var rules;
     <span class="keyword">new</span>() { new_database(Self.rules); }
 }
</pre></div><p>We can then create our theory object for propositional logic as follows:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">new</span> theory(Prop);
 assertz(simplify(in A &amp;&amp; A, A), Prop.rules);
 assertz(simplify(in B || <span class="keyword">true</span>, <span class="keyword">true</span>), Prop.rules);
 ...
</pre></div><p>To use the simplification rules, we need to call the local predicate with <a class="el" href="group__logic__and__control.html#call_2">call/2</a>:</p>
<div class="fragment"><pre class="fragment"> call(simplify(Expr, Simplified), Prop.rules);
</pre></div><p>The local predicate is executed in a context where the <em>current database</em> is set to <code>Prop.rules</code>. If the local predicate calls other predicates, they will first be looked up in the local database, and then the global database.</p>
<p><a class="el" href="group__clause__handling.html#abolish_1">abolish/1</a>, <a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#abolish_database_1">abolish_database/1</a>, <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#assertz_1">assertz/1</a>, <a class="el" href="group__clause__handling.html#assertz_2">assertz/2</a>, <a class="el" href="group__clause__handling.html#clause_2">clause/2</a>, <a class="el" href="group__clause__handling.html#clause_3">clause/3</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a>, <a class="el" href="group__clause__handling.html#retract_1">retract/1</a>, <a class="el" href="group__clause__handling.html#retract_2">retract/2</a></p>
<hr/>
 <a class="anchor" id="abolish_1"></a> <b>abolish/1</b> - removes a user-defined predicate from the predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>abolish</b>(<em>Pred</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Removes all clauses from the predicate database that are associated with the predicate indicator <em>Pred</em> and succeeds. The indicator should have the form <em>Name</em> / <em>Arity</em>. If the predicate does not exist, then succeeds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Removing a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - one of <em>Pred</em>, <em>Name</em>, or <em>Arity</em>, is a variable. </li>
<li><code>type_error(predicate_indicator, <em>Pred</em>)</code> - <em>Pred</em> does not have the form <em>Name</em> / <em>Arity</em>. </li>
<li><code>type_error(integer, <em>Arity</em>)</code> - <em>Arity</em> is not an integer. </li>
<li><code>type_error(atom, <em>Name</em>)</code> - <em>Name</em> is not an atom. </li>
<li><code>domain_error(not_less_than_zero, <em>Arity</em>)</code> - <em>Arity</em> is less than zero. </li>
<li><code>permission_error(modify, static_procedure, <em>Pred</em>)</code> - <em>Pred</em> is a builtin or compiled predicate.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> abolish(userdef/3)       succeeds
 abolish(Pred)            instantiation_error
 abolish(Name/3)          instantiation_error
 abolish(userdef/Arity)   instantiation_error
 abolish(1.5)             type_error(predicate_indicator, 1.5)
 abolish(userdef/a)       type_error(integer, a)
 abolish(1/a)             type_error(integer, a)
 abolish(1/3)             type_error(atom, 1)
 abolish(userdef/-3)      domain_error(not_less_than_zero, -3)
 abolish(abolish/1)       permission_error(modify, static_procedure, abolish/1)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a>, <a class="el" href="group__clause__handling.html#retract_1">retract/1</a></dd></dl>
<hr/>
 <a class="anchor" id="abolish_2"></a> <b>abolish/2</b> - removes a user-defined predicate from a local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>abolish</b>(<em>Pred</em>, <em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Removes all clauses from the specified local predicate <em>Database</em> that are associated with the predicate indicator <em>Pred</em> and succeeds. The indicator should have the form <em>Name</em> / <em>Arity</em>. If the predicate does not exist, then succeeds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Removing a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database. </li>
<li><code>instantiation_error</code> - one of <em>Pred</em>, <em>Name</em>, or <em>Arity</em>, is a variable. </li>
<li><code>type_error(predicate_indicator, <em>Pred</em>)</code> - <em>Pred</em> does not have the form <em>Name</em> / <em>Arity</em>. </li>
<li><code>type_error(integer, <em>Arity</em>)</code> - <em>Arity</em> is not an integer. </li>
<li><code>type_error(atom, <em>Name</em>)</code> - <em>Name</em> is not an atom. </li>
<li><code>domain_error(not_less_than_zero, <em>Arity</em>)</code> - <em>Arity</em> is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
 assertz(userdef(a, b, c), DB);
 abolish(userdef/3, DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_1">abolish/1</a>, <a class="el" href="group__clause__handling.html#abolish_database_1">abolish_database/1</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a>, <a class="el" href="group__clause__handling.html#retract_2">retract/2</a></dd></dl>
<hr/>
 <a class="anchor" id="abolish_database_1"></a> <b>abolish_database/1</b> - removes all predicates from a local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>abolish_database</b>(<em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Removes all predicates from the specified local predicate <em>Database</em> and succeeds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Removing predicates that are in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
 assertz(userdef(a, b, c), DB);
 assertz(simplify(in A &amp;&amp; A, A), DB);
 abolish_database(DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a>, <a class="el" href="group__clause__handling.html#retract_2">retract/2</a></dd></dl>
<hr/>
 <a class="anchor" id="asserta_1"></a> <a class="anchor" id="assertz_1"></a> <b>asserta/1</b>, <b>assertz/1</b> - adds a clause to the start/end of a user-defined predicate in the predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>asserta</b>(<em>Clause</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>assertz</b>(<em>Clause</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If the <em>Clause</em> has <b>(:-)/2</b> as its top-level functor, then break it down into <em>Head</em> :- <em>Body</em>. If the <em>Clause</em> has <b>(--&gt;)/2</b> as its top-level functor, then expand the clause according to the <a class="el" href="syntax_dcg.html">Definite clause grammar</a> rules and then break it down into <em>Head</em> :- <em>Body</em>. Otherwise, let <em>Head</em> be <em>Clause</em> and <em>Body</em> be <b>true</b>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A freshly renamed version of the clause <em>Head</em> :- <em>Body</em> is added to the predicate database at the start (<b>asserta/1</b>) or end (<b>assertz/1</b>) of the predicate defined by <em>Head</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Adding a clause to a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Clause</em> or <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor). </li>
<li><code>type_error(callable, <em>Body</em>)</code> - <em>Body</em> is not a callable term. In a departure from <a class="el" href="group__predicates.html#standard">Standard Prolog</a>, this error is thrown when the <em>Body</em> is executed, not when the <em>Clause</em> is asserted into the database. </li>
<li><code>permission_error(modify, static_procedure, <em>Pred</em>)</code> - the predicate indicator <em>Pred</em> of <em>Head</em> refers to a builtin or compiled predicate.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> asserta(Clause)              instantiation_error
 assertz((Head :- true))      instantiation_error
 asserta((1.5 :- true))       type_error(callable, 1.5)
 assertz((a :- true))         succeeds
 asserta((a(X) :- b(X,Y)))    succeeds
 assertz(a(X))                succeeds
 asserta((det --&gt; &quot;the&quot;))     succeeds
 assertz((a :- X))            type_error(callable, X) when executed
 asserta(asserta(X))          permission_error(modify, static_procedure, asserta/1)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a>, with the addition of the handling for <b>(--&gt;)/2</b>.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_1">abolish/1</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#retract_1">retract/1</a>, <a class="el" href="group__directives.html#dynamic_1">dynamic/1</a></dd></dl>
<hr/>
 <a class="anchor" id="asserta_2"></a> <a class="anchor" id="assertz_2"></a> <b>asserta/2</b>, <b>assertz/2</b> - adds a clause to the start/end of a user-defined predicate in a local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>asserta</b>(<em>Clause</em>, <em>Database</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>assertz</b>(<em>Clause</em>, <em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If the <em>Clause</em> has <b>(:-)/2</b> as its top-level functor, then break it down into <em>Head</em> :- <em>Body</em>. If the <em>Clause</em> has <b>(--&gt;)/2</b> as its top-level functor, then expand the clause according to the <a class="el" href="syntax_dcg.html">Definite clause grammar</a> rules and then break it down into <em>Head</em> :- <em>Body</em>. Otherwise, let <em>Head</em> be <em>Clause</em> and <em>Body</em> be <b>true</b>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A freshly renamed version of the clause <em>Head</em> :- <em>Body</em> is added to the specified local predicate <em>Database</em> at the start (<b>asserta/2</b>) or end (<b>assertz/2</b>) of the predicate defined by <em>Head</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Adding a clause to a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database. </li>
<li><code>instantiation_error</code> - <em>Clause</em> or <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor). </li>
<li><code>type_error(callable, <em>Body</em>)</code> - <em>Body</em> is not a callable term. In a departure from <a class="el" href="group__predicates.html#standard">Standard Prolog</a>, this error is thrown when the <em>Body</em> is executed, not when the <em>Clause</em> is asserted into the database. </li>
<li><code>permission_error(modify, static_procedure, <em>Pred</em>)</code> - <em>Pred</em> is a builtin predicate in the global database that cannot be overridden by local databases.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
 assertz(userdef(a, b, c), DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a>, <a class="el" href="group__clause__handling.html#retract_2">retract/2</a></dd></dl>
<hr/>
 <a class="anchor" id="clause_2"></a> <b>clause/2</b> - searches for clauses in the predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>clause</b>(<em>Head</em>, <em>Body</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Succeeds if <em>Head</em> <code>:-</code> <em>Body</em> unifies with a clause in the predicate database. If there are multiple clauses that unify, then backtrack through the alternatives. Fails immediately if no clauses unify.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor). </li>
<li><code>permission_error(access, private_procedure, <em>Pred</em>)</code> - the predicate indicator <em>Pred</em> of <em>Head</em> refers to a predicate that is builtin or compiled.</li>
</ul>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a>, <a class="el" href="group__clause__handling.html#clause_3">clause/3</a></dd></dl>
<hr/>
 <a class="anchor" id="clause_3"></a> <b>clause/3</b> - searches for clauses in a local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>clause</b>(<em>Head</em>, <em>Body</em>, <em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Succeeds if <em>Head</em> <code>:-</code> <em>Body</em> unifies with a clause in the specified local predicate <em>Database</em>. If there are multiple clauses that unify, then backtrack through the alternatives. Fails immediately if no clauses unify.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database. </li>
<li><code>instantiation_error</code> - <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor).</li>
</ul>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a></dd></dl>
<hr/>
 <a class="anchor" id="new_database_1"></a> <b>new_database/1</b> - creates a new local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>new_database</b>(<em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Creates a new local predicate database and unifies it with <em>Database</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(variable, <em>Database</em>)</code> - <em>Database</em> is not a variable.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#clause_3">clause/3</a>, <a class="el" href="group__type__testing.html#database_1">database/1</a>, <a class="el" href="group__clause__handling.html#retract_2">retract/2</a></dd></dl>
<hr/>
 <a class="anchor" id="retract_1"></a> <b>retract/1</b> - removes a clause from a user-defined predicate in the predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>retract</b>(<em>Clause</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If the <em>Clause</em> has <b>(:-)/2</b> as its top-level functor, then break it down into <em>Head</em> :- <em>Body</em>. If the <em>Clause</em> has <b>(--&gt;)/2</b> as its top-level functor, then expand the clause according to the <a class="el" href="syntax_dcg.html">Definite clause grammar</a> rules and then break it down into <em>Head</em> :- <em>Body</em>. Otherwise, let <em>Head</em> be <em>Clause</em> and <em>Body</em> be <b>true</b>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>retract/1</b> predicate finds the first clause in the predicate database that unifies with <em>Head</em> :- <em>Body</em>, removes it, and then succeeds. If <em>Head</em> :- <em>Body</em> does not unify with any clause in the database, then <b>retract/1</b> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Upon success, <em>Clause</em> is unified with the clause that was removed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Removing a clause from a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Clause</em> or <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor). </li>
<li><code>permission_error(modify, static_procedure, <em>Pred</em>)</code> - the predicate indicator <em>Pred</em> of <em>Head</em> refers to a builtin or compiled predicate.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> retract(Clause)              instantiation_error
 retract((Head :- true))      instantiation_error
 retract((1.5 :- true))       type_error(callable, 1.5)
 retract((a(X) :- b(X, Y))    fails
 assertz((a(X) :- b(X, Y))); retract((a(X) :- b(X, Y)))   succeeds
 retract(retract(X))          permission_error(modify, static_procedure, retract/1)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>retract/1</b> predicate in <a class="el" href="group__predicates.html#standard">Standard Prolog</a> removes multiple clauses that match <em>Head</em> :- <em>Body</em> upon back-tracking. In Plang, only the first clause is removed and back-tracking will cause a failure. It is possible to remove all clauses that match a specific <em>Head</em> :- <em>Body</em> as follows: <div class="fragment"><pre class="fragment"> <span class="keywordflow">while</span> [X, Y] (retract((a(X) :- b(X, Y)))) {}
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_1">abolish/1</a>, <a class="el" href="group__clause__handling.html#asserta_1">asserta/1</a></dd></dl>
<hr/>
 <a class="anchor" id="retract_2"></a> <b>retract/2</b> - removes a clause from a user-defined predicate in a local predicate database.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>retract</b>(<em>Clause</em>, <em>Database</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If the <em>Clause</em> has <b>(:-)/2</b> as its top-level functor, then break it down into <em>Head</em> :- <em>Body</em>. If the <em>Clause</em> has <b>(--&gt;)/2</b> as its top-level functor, then expand the clause according to the <a class="el" href="syntax_dcg.html">Definite clause grammar</a> rules and then break it down into <em>Head</em> :- <em>Body</em>. Otherwise, let <em>Head</em> be <em>Clause</em> and <em>Body</em> be <b>true</b>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>retract/2</b> predicate finds the first clause in the specified local predicate <em>Database</em> that unifies with <em>Head</em> :- <em>Body</em>, removes it, and then succeeds. If <em>Head</em> :- <em>Body</em> does not unify with any clause in <em>Database</em>, then <b>retract/2</b> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Upon success, <em>Clause</em> is unified with the clause that was removed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Removing a clause from a predicate that is in the process of being executed leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Database</em> is a variable. </li>
<li><code>type_error(database, <em>Database</em>)</code> - <em>Database</em> is not a local database. </li>
<li><code>instantiation_error</code> - <em>Clause</em> or <em>Head</em> is a variable. </li>
<li><code>type_error(callable, <em>Head</em>)</code> - <em>Head</em> is not a callable term (atom or functor).</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> new_database(DB);
 assertz(userdef(a, b, c), DB);
 retract(userdef(A, B, C), DB);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__clause__handling.html#abolish_2">abolish/2</a>, <a class="el" href="group__clause__handling.html#asserta_2">asserta/2</a>, <a class="el" href="group__clause__handling.html#new_database_1">new_database/1</a>, <a class="el" href="group__clause__handling.html#retract_1">retract/1</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
