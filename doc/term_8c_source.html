<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: term.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>term.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * plang logic programming language</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (C) 2011  Southern Storm Software, Pty Ltd.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * The plang package is free software: you can redistribute it and/or</span>
<a name="l00006"></a>00006 <span class="comment"> * modify it under the terms of the GNU Lesser General Public License</span>
<a name="l00007"></a>00007 <span class="comment"> * as published by the Free Software Foundation, either version 3 of</span>
<a name="l00008"></a>00008 <span class="comment"> * the License, or (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * The plang package is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU Lesser General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
<a name="l00016"></a>00016 <span class="comment"> * License along with the libcompiler library.  If not,</span>
<a name="l00017"></a>00017 <span class="comment"> * see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00018"></a>00018 <span class="comment"> */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;plang/term.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;plang/database.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;term-priv.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;context-priv.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;rbtree-priv.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;inst-priv.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/* Internal dereference algorithm, which we inline for maximum</span>
<a name="l00031"></a>00031 <span class="comment"> * performance in the functions that use it */</span>
<a name="l00032"></a>00032 P_INLINE p_term *p_term_deref_non_null(<span class="keyword">const</span> p_term *term)
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034     <span class="keywordflow">for</span>(;;) {
<a name="l00035"></a>00035         <span class="keywordflow">if</span> (term-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>) {
<a name="l00036"></a>00036             <span class="keywordflow">if</span> (!term-&gt;var.value)
<a name="l00037"></a>00037                 <span class="keywordflow">break</span>;
<a name="l00038"></a>00038             term = term-&gt;var.value;
<a name="l00039"></a>00039         } <span class="keywordflow">else</span> {
<a name="l00040"></a>00040             <span class="keywordflow">break</span>;
<a name="l00041"></a>00041         }
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00060"></a>00060 <span class="comment">/*\@{*/</span>
<a name="l00061"></a>00061 
<a name="l00173"></a><a class="code" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7">00173</a> p_term *<a class="code" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor</a>(p_context *context, p_term *name, <span class="keywordtype">int</span> arg_count)
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175     <span class="keyword">struct </span><a class="code" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor</a> *term;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <span class="comment">/* Bail out if the parameters are invalid */</span>
<a name="l00178"></a>00178     <span class="keywordflow">if</span> (!name || arg_count &lt; 0)
<a name="l00179"></a>00179         <span class="keywordflow">return</span> 0;
<a name="l00180"></a>00180     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>) {
<a name="l00181"></a>00181         name = p_term_deref_non_null(name);
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l00183"></a>00183             <span class="keywordflow">return</span> 0;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="comment">/* A functor with zero arguments is just an atom */</span>
<a name="l00187"></a>00187     <span class="keywordflow">if</span> (!arg_count)
<a name="l00188"></a>00188         <span class="keywordflow">return</span> name;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">/* Create the functor term, with empty argument slots */</span>
<a name="l00191"></a>00191     term = p_term_malloc
<a name="l00192"></a>00192         (context, <span class="keyword">struct</span> <a class="code" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor</a>,
<a name="l00193"></a>00193             <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor</a>) +
<a name="l00194"></a>00194             (<span class="keyword">sizeof</span>(p_term *) * (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(arg_count - 1)));
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (!term)
<a name="l00196"></a>00196         <span class="keywordflow">return</span> 0;
<a name="l00197"></a>00197     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>;
<a name="l00198"></a>00198     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)arg_count;
<a name="l00199"></a>00199     term-&gt;functor_name = name;
<a name="l00200"></a>00200     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 
<a name="l00214"></a><a class="code" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a">00214</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a" title="Binds the argument at index within the specified functor term to value.">p_term_bind_functor_arg</a>(p_term *term, <span class="keywordtype">int</span> index, p_term *value)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (!term || term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> || !value)
<a name="l00217"></a>00217         <span class="keywordflow">return</span> 0;
<a name="l00218"></a>00218     <span class="keywordflow">if</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)index) &gt;= term-&gt;header.size)
<a name="l00219"></a>00219         <span class="keywordflow">return</span> 0;
<a name="l00220"></a>00220     <span class="keywordflow">if</span> (term-&gt;functor.arg[index])
<a name="l00221"></a>00221         <span class="keywordflow">return</span> 0;
<a name="l00222"></a>00222     term-&gt;functor.arg[index] = value;
<a name="l00223"></a>00223     <span class="keywordflow">return</span> 1;
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00234"></a><a class="code" href="group__term.html#ga62097d28b6ff5e4d3532b83d5dcbae9c">00234</a> p_term *<a class="code" href="group__term.html#ga62097d28b6ff5e4d3532b83d5dcbae9c" title="Creates a functor term within ontext with the specified name and the arg_count members...">p_term_create_functor_with_args</a>(p_context *context, p_term *name, p_term **args, <span class="keywordtype">int</span> arg_count)
<a name="l00235"></a>00235 {
<a name="l00236"></a>00236     <span class="keywordtype">int</span> index;
<a name="l00237"></a>00237     p_term *term = <a class="code" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor</a>(context, name, arg_count);
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (!term)
<a name="l00239"></a>00239         <span class="keywordflow">return</span> 0;
<a name="l00240"></a>00240     <span class="keywordflow">for</span> (index = 0; index &lt; arg_count; ++index)
<a name="l00241"></a>00241         term-&gt;functor.arg[index] = args[index];
<a name="l00242"></a>00242     <span class="keywordflow">return</span> term;
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00252"></a><a class="code" href="group__term.html#ga17481776d0fda576367bae90263f7fe5">00252</a> p_term *<a class="code" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list</a>(p_context *context, p_term *head, p_term *tail)
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254     <span class="keyword">struct </span>p_term_list *term = p_term_new(context, <span class="keyword">struct</span> p_term_list);
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (!term)
<a name="l00256"></a>00256         <span class="keywordflow">return</span> 0;
<a name="l00257"></a>00257     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>;
<a name="l00258"></a>00258     term-&gt;header.size = 2;  <span class="comment">/* Arity indication for p_term_precedes */</span>
<a name="l00259"></a>00259     term-&gt;head = head;
<a name="l00260"></a>00260     term-&gt;tail = tail;
<a name="l00261"></a>00261     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00274"></a><a class="code" href="group__term.html#ga4fe9ffcf5da089493b43bfb0140670b0">00274</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga4fe9ffcf5da089493b43bfb0140670b0" title="Sets the tail of list to tail.">p_term_set_tail</a>(p_term *list, p_term *tail)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276     <span class="keywordflow">if</span> (!list || list-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l00277"></a>00277         <span class="keywordflow">return</span>;
<a name="l00278"></a>00278     list-&gt;list.tail = tail;
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00300"></a><a class="code" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8">00300</a> p_term *<a class="code" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom</a>(p_context *context, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00301"></a>00301 {
<a name="l00302"></a>00302     <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067" title="Creates an atom within context with the len bytes at name as its atom name.">p_term_create_atom_n</a>(context, name, name ? strlen(name) : 0);
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00324"></a><a class="code" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067">00324</a> p_term *<a class="code" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067" title="Creates an atom within context with the len bytes at name as its atom name.">p_term_create_atom_n</a>(p_context *context, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">size_t</span> len)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash;
<a name="l00327"></a>00327     <span class="keyword">const</span> <span class="keywordtype">char</span> *n;
<a name="l00328"></a>00328     <span class="keywordtype">size_t</span> nlen;
<a name="l00329"></a>00329     p_term *atom;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="comment">/* Look for the name in the context&apos;s atom hash */</span>
<a name="l00332"></a>00332     hash = 0;
<a name="l00333"></a>00333     n = name;
<a name="l00334"></a>00334     nlen = len;
<a name="l00335"></a>00335     <span class="keywordflow">while</span> (nlen &gt; 0) {
<a name="l00336"></a>00336         hash = hash * 5 + (((<span class="keywordtype">unsigned</span> int)(*n++)) &amp; 0xFF);
<a name="l00337"></a>00337         --nlen;
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339     hash %= P_CONTEXT_HASH_SIZE;
<a name="l00340"></a>00340     atom = context-&gt;atom_hash[hash];
<a name="l00341"></a>00341     <span class="keywordflow">while</span> (atom != 0) {
<a name="l00342"></a>00342         <span class="keywordflow">if</span> (atom-&gt;header.size == len &amp;&amp;
<a name="l00343"></a>00343                 !memcmp(atom-&gt;atom.name, name, len))
<a name="l00344"></a>00344             <span class="keywordflow">return</span> atom;
<a name="l00345"></a>00345         atom = atom-&gt;atom.next;
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">/* Create a new atom and add it to the hash */</span>
<a name="l00349"></a>00349     atom = p_term_malloc
<a name="l00350"></a>00350         (context, p_term, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_atom) + len);
<a name="l00351"></a>00351     <span class="keywordflow">if</span> (!atom)
<a name="l00352"></a>00352         <span class="keywordflow">return</span> 0;
<a name="l00353"></a>00353     atom-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>;
<a name="l00354"></a>00354     atom-&gt;header.size = (<span class="keywordtype">unsigned</span> int)len;
<a name="l00355"></a>00355     atom-&gt;atom.next = context-&gt;atom_hash[hash];
<a name="l00356"></a>00356     <span class="keywordflow">if</span> (len &gt; 0)
<a name="l00357"></a>00357         memcpy(atom-&gt;atom.name, name, len);
<a name="l00358"></a>00358     atom-&gt;atom.name[len] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00359"></a>00359     context-&gt;atom_hash[hash] = atom;
<a name="l00360"></a>00360     <span class="keywordflow">return</span> atom;
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00382"></a><a class="code" href="group__term.html#ga07c94636569314c0d219497aa61ab925">00382</a> p_term *<a class="code" href="group__term.html#ga07c94636569314c0d219497aa61ab925" title="Creates a string within context with the specified str value.">p_term_create_string</a>(p_context *context, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00383"></a>00383 {
<a name="l00384"></a>00384     <span class="keywordtype">size_t</span> len = str ? strlen(str) : 0;
<a name="l00385"></a>00385     <span class="keyword">struct </span>p_term_string *term = p_term_malloc
<a name="l00386"></a>00386         (context, <span class="keyword">struct</span> p_term_string, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_string) + len);
<a name="l00387"></a>00387     <span class="keywordflow">if</span> (!term)
<a name="l00388"></a>00388         <span class="keywordflow">return</span> 0;
<a name="l00389"></a>00389     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>;
<a name="l00390"></a>00390     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)len;
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (len &gt; 0)
<a name="l00392"></a>00392         memcpy(term-&gt;name, str, len);
<a name="l00393"></a>00393     term-&gt;name[len] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00394"></a>00394     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00413"></a><a class="code" href="group__term.html#ga8c7104a045903c1d9c5fa56881e9d9f1">00413</a> p_term *<a class="code" href="group__term.html#ga8c7104a045903c1d9c5fa56881e9d9f1" title="Creates a string within context with the len bytes from the specified str buffer...">p_term_create_string_n</a>(p_context *context, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> len)
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415     <span class="keyword">struct </span>p_term_string *term = p_term_malloc
<a name="l00416"></a>00416         (context, <span class="keyword">struct</span> p_term_string, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_string) + len);
<a name="l00417"></a>00417     <span class="keywordflow">if</span> (!term)
<a name="l00418"></a>00418         <span class="keywordflow">return</span> 0;
<a name="l00419"></a>00419     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>;
<a name="l00420"></a>00420     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)len;
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (len &gt; 0)
<a name="l00422"></a>00422         memcpy(term-&gt;name, str, len);
<a name="l00423"></a>00423     term-&gt;name[len] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00424"></a>00424     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00435"></a><a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96">00435</a> p_term *<a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(p_context *context)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437     <span class="keyword">struct </span>p_term_var *term = p_term_new(context, <span class="keyword">struct</span> p_term_var);
<a name="l00438"></a>00438     <span class="keywordflow">if</span> (!term)
<a name="l00439"></a>00439         <span class="keywordflow">return</span> 0;
<a name="l00440"></a>00440     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>;
<a name="l00441"></a>00441     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00442"></a>00442 }
<a name="l00443"></a>00443 
<a name="l00454"></a><a class="code" href="group__term.html#ga899f47e78554cdb98491716cc3c5072c">00454</a> p_term *<a class="code" href="group__term.html#ga899f47e78554cdb98491716cc3c5072c" title="Creates an unbound variable within context and associates it with name.">p_term_create_named_variable</a>(p_context *context, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00455"></a>00455 {
<a name="l00456"></a>00456     <span class="keywordtype">size_t</span> len = name ? strlen(name) : 0;
<a name="l00457"></a>00457     <span class="keyword">struct </span>p_term_var *term;
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (!len)
<a name="l00459"></a>00459         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(context);
<a name="l00460"></a>00460     term = p_term_malloc(context, <span class="keyword">struct</span> p_term_var,
<a name="l00461"></a>00461                          <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_var) + len + 1);
<a name="l00462"></a>00462     <span class="keywordflow">if</span> (!term)
<a name="l00463"></a>00463         <span class="keywordflow">return</span> 0;
<a name="l00464"></a>00464     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>;
<a name="l00465"></a>00465     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)len;
<a name="l00466"></a>00466     strcpy((<span class="keywordtype">char</span> *)(term + 1), name);
<a name="l00467"></a>00467     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00484"></a><a class="code" href="group__term.html#ga5b517baf3da998736bf7a07ab83004ea">00484</a> p_term *<a class="code" href="group__term.html#ga5b517baf3da998736bf7a07ab83004ea" title="Creates an unbound member variable within context that refers to the member name...">p_term_create_member_variable</a>(p_context *context, p_term *<span class="keywordtype">object</span>, p_term *name, <span class="keywordtype">int</span> auto_create)
<a name="l00485"></a>00485 {
<a name="l00486"></a>00486     <span class="keyword">struct </span>p_term_member_var *term;
<a name="l00487"></a>00487     <span class="keywordflow">if</span> (!name || !<span class="keywordtype">object</span>)
<a name="l00488"></a>00488         <span class="keywordflow">return</span> 0;
<a name="l00489"></a>00489     name = p_term_deref_non_null(name);
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l00491"></a>00491         <span class="keywordflow">return</span> 0;
<a name="l00492"></a>00492     term = p_term_new(context, <span class="keyword">struct</span> p_term_member_var);
<a name="l00493"></a>00493     <span class="keywordflow">if</span> (!term)
<a name="l00494"></a>00494         <span class="keywordflow">return</span> 0;
<a name="l00495"></a>00495     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>;
<a name="l00496"></a>00496     term-&gt;header.size = (auto_create ? 1 : 0);
<a name="l00497"></a>00497     term-&gt;object = object;
<a name="l00498"></a>00498     term-&gt;name = name;
<a name="l00499"></a>00499     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 
<a name="l00511"></a><a class="code" href="group__term.html#gaf8aa094355a33451017b76a059771247">00511</a> p_term *<a class="code" href="group__term.html#gaf8aa094355a33451017b76a059771247" title="Creates an integer within context with the specified value.">p_term_create_integer</a>(p_context *context, <span class="keywordtype">int</span> value)
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513     <span class="keyword">struct </span>p_term_integer *term =
<a name="l00514"></a>00514         p_term_new(context, <span class="keyword">struct</span> p_term_integer);
<a name="l00515"></a>00515     <span class="keywordflow">if</span> (!term)
<a name="l00516"></a>00516         <span class="keywordflow">return</span> 0;
<a name="l00517"></a>00517     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>;
<a name="l00518"></a>00518 <span class="preprocessor">#if defined(P_TERM_64BIT)</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span>    <span class="comment">/* Pack the value into the header, to save memory */</span>
<a name="l00520"></a>00520     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)value;
<a name="l00521"></a>00521 <span class="preprocessor">#else</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span>    term-&gt;value = value;
<a name="l00523"></a>00523 <span class="preprocessor">#endif</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (p_term *)term;
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 
<a name="l00536"></a><a class="code" href="group__term.html#ga739432392dc4edf3fa58afe559702697">00536</a> p_term *<a class="code" href="group__term.html#ga739432392dc4edf3fa58afe559702697" title="Creates a real within context with the specified value.">p_term_create_real</a>(p_context *context, <span class="keywordtype">double</span> value)
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538     <span class="keyword">struct </span>p_term_real *term = p_term_new(context, <span class="keyword">struct</span> p_term_real);
<a name="l00539"></a>00539     <span class="keywordflow">if</span> (!term)
<a name="l00540"></a>00540         <span class="keywordflow">return</span> 0;
<a name="l00541"></a>00541     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>;
<a name="l00542"></a>00542     term-&gt;value = value;
<a name="l00543"></a>00543     <span class="keywordflow">return</span> (p_term *)term;
<a name="l00544"></a>00544 }
<a name="l00545"></a>00545 
<a name="l00557"></a><a class="code" href="group__term.html#gacdd67ab1558d9c6756170fc550bb873c">00557</a> p_term *<a class="code" href="group__term.html#gacdd67ab1558d9c6756170fc550bb873c" title="Returns the special &amp;quot;nil&amp;quot; atom that represents the empty list within context...">p_term_nil_atom</a>(p_context *context)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559     <span class="keywordflow">return</span> context-&gt;nil_atom;
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00573"></a><a class="code" href="group__term.html#gaf9664345cc144da2c249a6d5c245e1e7">00573</a> p_term *<a class="code" href="group__term.html#gaf9664345cc144da2c249a6d5c245e1e7" title="Returns the special &amp;quot;prototype&amp;quot; atom within context that names the prototype...">p_term_prototype_atom</a>(p_context *context)
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575     <span class="keywordflow">return</span> context-&gt;prototype_atom;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00589"></a><a class="code" href="group__term.html#gab2b33e5072cb40115a6a23cb7a1eef9f">00589</a> p_term *<a class="code" href="group__term.html#gab2b33e5072cb40115a6a23cb7a1eef9f" title="Returns the special &amp;quot;className&amp;quot; atom within context that names the class...">p_term_class_name_atom</a>(p_context *context)
<a name="l00590"></a>00590 {
<a name="l00591"></a>00591     <span class="keywordflow">return</span> context-&gt;class_name_atom;
<a name="l00592"></a>00592 }
<a name="l00593"></a>00593 
<a name="l00609"></a><a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0">00609</a> p_term *<a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(<span class="keyword">const</span> p_term *term)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611     <span class="keywordflow">return</span> term ? p_term_deref_non_null(term) : 0;
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00629"></a><a class="code" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174">00629</a> p_term *<a class="code" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member</a>(p_context *context, p_term *term)
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631     p_term *object;
<a name="l00632"></a>00632     p_term *value;
<a name="l00633"></a>00633     <span class="keywordflow">if</span> (!term)
<a name="l00634"></a>00634         <span class="keywordflow">return</span> 0;
<a name="l00635"></a>00635     term = p_term_deref_non_null(term);
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>)
<a name="l00637"></a>00637         <span class="keywordflow">return</span> term;
<a name="l00638"></a>00638     <span class="keywordtype">object</span> = <a class="code" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member</a>(context, term-&gt;member_var.object);
<a name="l00639"></a>00639     <span class="keywordflow">if</span> (!<span class="keywordtype">object</span> || object-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l00640"></a>00640         <span class="keywordflow">return</span> term;
<a name="l00641"></a>00641     value = <a class="code" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property</a>(context, <span class="keywordtype">object</span>, term-&gt;member_var.name);
<a name="l00642"></a>00642     <span class="keywordflow">if</span> (value) {
<a name="l00643"></a>00643         <span class="comment">/* Propery has a value - bind the term to it */</span>
<a name="l00644"></a>00644         <a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable</a>(context, term, value, <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aecdf42bd91c99f85a757b5dfe15d319d">P_BIND_DEFAULT</a>);
<a name="l00645"></a>00645     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;header.size) {
<a name="l00646"></a>00646         <span class="comment">/* Auto-create the property with an unbound variable slot,</span>
<a name="l00647"></a>00647 <span class="comment">         * and then bind this term to the new variable */</span>
<a name="l00648"></a>00648         value = <a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(context);
<a name="l00649"></a>00649         <a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property</a>
<a name="l00650"></a>00650             (context, <span class="keywordtype">object</span>, term-&gt;member_var.name, value);
<a name="l00651"></a>00651         <a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable</a>(context, term, value, <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aecdf42bd91c99f85a757b5dfe15d319d">P_BIND_DEFAULT</a>);
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653     <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(value);
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 
<a name="l00673"></a><a class="code" href="group__term.html#ga068ea25e5f02b95da3b353dd2f6b647b">00673</a> p_term *<a class="code" href="group__term.html#ga068ea25e5f02b95da3b353dd2f6b647b" title="Dereferences term to resolve bound variables within context.">p_term_deref_own_member</a>(p_context *context, p_term *term)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675     p_term *object;
<a name="l00676"></a>00676     p_term *value;
<a name="l00677"></a>00677     <span class="keywordflow">if</span> (!term)
<a name="l00678"></a>00678         <span class="keywordflow">return</span> 0;
<a name="l00679"></a>00679     term = p_term_deref_non_null(term);
<a name="l00680"></a>00680     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>)
<a name="l00681"></a>00681         <span class="keywordflow">return</span> term;
<a name="l00682"></a>00682     <span class="keywordtype">object</span> = <a class="code" href="group__term.html#gaa914c3fb08f1a03a5a8c3cc264273174" title="Dereferences term to resolve bound variables within context.">p_term_deref_member</a>(context, term-&gt;member_var.object);
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (!<span class="keywordtype">object</span> || object-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l00684"></a>00684         <span class="keywordflow">return</span> term;
<a name="l00685"></a>00685     value = <a class="code" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd" title="Returns the value associated with the property name on term within context, or null...">p_term_own_property</a>(context, <span class="keywordtype">object</span>, term-&gt;member_var.name);
<a name="l00686"></a>00686     <span class="keywordflow">if</span> (value) {
<a name="l00687"></a>00687         <span class="comment">/* Propery has a value - bind the term to it */</span>
<a name="l00688"></a>00688         <a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable</a>(context, term, value, <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aecdf42bd91c99f85a757b5dfe15d319d">P_BIND_DEFAULT</a>);
<a name="l00689"></a>00689     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;header.size) {
<a name="l00690"></a>00690         <span class="comment">/* Auto-create the property with an unbound variable slot,</span>
<a name="l00691"></a>00691 <span class="comment">         * and then bind this term to the new variable */</span>
<a name="l00692"></a>00692         value = <a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(context);
<a name="l00693"></a>00693         <a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property</a>
<a name="l00694"></a>00694             (context, <span class="keywordtype">object</span>, term-&gt;member_var.name, value);
<a name="l00695"></a>00695         <a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable</a>(context, term, value, <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aecdf42bd91c99f85a757b5dfe15d319d">P_BIND_DEFAULT</a>);
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697     <span class="keywordflow">return</span> term;
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00709"></a><a class="code" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495">00709</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga412cae4cf75b595d8d8a64d9b06a0495" title="Returns the type of term after dereferencing it.">p_term_type</a>(<span class="keyword">const</span> p_term *term)
<a name="l00710"></a>00710 {
<a name="l00711"></a>00711     <span class="keywordflow">if</span> (term)
<a name="l00712"></a>00712         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(p_term_deref_non_null(term)-&gt;header.type);
<a name="l00713"></a>00713     <span class="keywordflow">else</span>
<a name="l00714"></a>00714         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba083668b8a2221ef2018a963908181d58">P_TERM_INVALID</a>;
<a name="l00715"></a>00715 }
<a name="l00716"></a>00716 
<a name="l00727"></a><a class="code" href="group__term.html#ga85c7d733fc9801d98f35b3e103a18c27">00727</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga85c7d733fc9801d98f35b3e103a18c27" title="Returns the number of arguments for a functor or predicate term, or zero if term...">p_term_arg_count</a>(<span class="keyword">const</span> p_term *term)
<a name="l00728"></a>00728 {
<a name="l00729"></a>00729     <span class="keywordflow">if</span> (!term)
<a name="l00730"></a>00730         <span class="keywordflow">return</span> 0;
<a name="l00731"></a>00731     <span class="comment">/* Short-cut: avoid dereference if already a functor/predicate */</span>
<a name="l00732"></a>00732     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> ||
<a name="l00733"></a>00733             term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l00734"></a>00734         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(term-&gt;header.size);
<a name="l00735"></a>00735     term = p_term_deref_non_null(term);
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> ||
<a name="l00737"></a>00737             term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l00738"></a>00738         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(term-&gt;header.size);
<a name="l00739"></a>00739     <span class="keywordflow">else</span>
<a name="l00740"></a>00740         <span class="keywordflow">return</span> 0;
<a name="l00741"></a>00741 }
<a name="l00742"></a>00742 
<a name="l00753"></a><a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777">00753</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(<span class="keyword">const</span> p_term *term)
<a name="l00754"></a>00754 {
<a name="l00755"></a>00755     <span class="keywordflow">if</span> (!term)
<a name="l00756"></a>00756         <span class="keywordflow">return</span> 0;
<a name="l00757"></a>00757     term = p_term_deref_non_null(term);
<a name="l00758"></a>00758     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l00759"></a>00759     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l00760"></a>00760         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name);
<a name="l00761"></a>00761     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l00762"></a>00762         <span class="keywordflow">return</span> term-&gt;atom.name;
<a name="l00763"></a>00763     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l00764"></a>00764         <span class="keywordflow">return</span> term-&gt;string.name;
<a name="l00765"></a>00765     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l00766"></a>00766         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;predicate.name);
<a name="l00767"></a>00767     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l00768"></a>00768         <span class="keywordflow">if</span> (term-&gt;header.size &gt; 0)
<a name="l00769"></a>00769             <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *)(&amp;(term-&gt;var) + 1);
<a name="l00770"></a>00770         <span class="keywordflow">break</span>;
<a name="l00771"></a>00771     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l00772"></a>00772         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;member_var.name);
<a name="l00773"></a>00773     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775     <span class="keywordflow">return</span> 0;
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 
<a name="l00790"></a><a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb">00790</a> <span class="keywordtype">size_t</span> <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(<span class="keyword">const</span> p_term *term)
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (!term)
<a name="l00793"></a>00793         <span class="keywordflow">return</span> 0;
<a name="l00794"></a>00794     term = p_term_deref_non_null(term);
<a name="l00795"></a>00795     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l00796"></a>00796     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l00797"></a>00797         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(term-&gt;functor.functor_name);
<a name="l00798"></a>00798     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l00799"></a>00799         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(term-&gt;predicate.name);
<a name="l00800"></a>00800     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l00801"></a>00801     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l00802"></a>00802     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l00803"></a>00803         <span class="keywordflow">return</span> term-&gt;header.size;
<a name="l00804"></a>00804     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l00805"></a>00805         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(term-&gt;member_var.name);
<a name="l00806"></a>00806     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808     <span class="keywordflow">return</span> 0;
<a name="l00809"></a>00809 }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 <span class="comment">/* Fetch the next UTF-8 character from a string */</span>
<a name="l00812"></a>00812 <span class="keywordtype">int</span> _p_term_next_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> len, <span class="keywordtype">size_t</span> *size)
<a name="l00813"></a>00813 {
<a name="l00814"></a>00814     <span class="keywordtype">int</span> ch, ch2;
<a name="l00815"></a>00815     <span class="keywordtype">size_t</span> req, sz;
<a name="l00816"></a>00816     <span class="keywordflow">if</span> (!len) {
<a name="l00817"></a>00817         *size = 0;
<a name="l00818"></a>00818         <span class="keywordflow">return</span> -1;
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820     ch = ((int)(*str)) &amp; 0xFF;
<a name="l00821"></a>00821     sz = 1;
<a name="l00822"></a>00822     <span class="keywordflow">if</span> (ch &lt; 0x80) {
<a name="l00823"></a>00823         req = 0;
<a name="l00824"></a>00824     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &amp; 0xE0) == 0xC0) {
<a name="l00825"></a>00825         ch &amp;= 0x1F;
<a name="l00826"></a>00826         req = 1;
<a name="l00827"></a>00827         ++str;
<a name="l00828"></a>00828         --len;
<a name="l00829"></a>00829     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &amp; 0xF0) == 0xE0) {
<a name="l00830"></a>00830         ch &amp;= 0x0F;
<a name="l00831"></a>00831         req = 2;
<a name="l00832"></a>00832         ++str;
<a name="l00833"></a>00833         --len;
<a name="l00834"></a>00834     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ch &amp; 0xF8) == 0xF0) {
<a name="l00835"></a>00835         ch &amp;= 0x07;
<a name="l00836"></a>00836         req = 3;
<a name="l00837"></a>00837         ++str;
<a name="l00838"></a>00838         --len;
<a name="l00839"></a>00839     } <span class="keywordflow">else</span> {
<a name="l00840"></a>00840         ++str;
<a name="l00841"></a>00841         --len;
<a name="l00842"></a>00842     invalid:
<a name="l00843"></a>00843         <span class="comment">/* Invalid UTF-8 char: search for a re-synchronization point */</span>
<a name="l00844"></a>00844         <span class="keywordflow">while</span> (len &gt; 0) {
<a name="l00845"></a>00845             ch = ((int)(*str)) &amp; 0xFF;
<a name="l00846"></a>00846             <span class="keywordflow">if</span> (ch &lt; 0x80 || (ch &amp; 0xE0) == 0xC0 ||
<a name="l00847"></a>00847                     (ch &amp; 0xF0) == 0xE0 || (ch &amp; 0xF8) == 0xF0)
<a name="l00848"></a>00848                 <span class="keywordflow">break</span>;
<a name="l00849"></a>00849             ++sz;
<a name="l00850"></a>00850             ++str;
<a name="l00851"></a>00851             --len;
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853         *size = sz;
<a name="l00854"></a>00854         <span class="keywordflow">return</span> -1;
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856     <span class="keywordflow">while</span> (req &gt; 0) {
<a name="l00857"></a>00857         <span class="keywordflow">if</span> (!len)
<a name="l00858"></a>00858             <span class="keywordflow">goto</span> invalid;
<a name="l00859"></a>00859         ch2 = ((int)(*str)) &amp; 0xFF;
<a name="l00860"></a>00860         <span class="keywordflow">if</span> ((ch2 &amp; 0xC0) == 0x80)
<a name="l00861"></a>00861             ch = (ch &lt;&lt; 6) | (ch2 &amp; 0x3F);
<a name="l00862"></a>00862         <span class="keywordflow">else</span>
<a name="l00863"></a>00863             <span class="keywordflow">goto</span> invalid;
<a name="l00864"></a>00864         ++str;
<a name="l00865"></a>00865         --len;
<a name="l00866"></a>00866         ++sz;
<a name="l00867"></a>00867         --req;
<a name="l00868"></a>00868     }
<a name="l00869"></a>00869     *size = sz;
<a name="l00870"></a>00870     <span class="keywordflow">return</span> ch;
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00885"></a><a class="code" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd">00885</a> <span class="keywordtype">size_t</span> <a class="code" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8</a>(<span class="keyword">const</span> p_term *term)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887     <span class="keyword">const</span> <span class="keywordtype">char</span> *name;
<a name="l00888"></a>00888     <span class="keywordtype">size_t</span> byte_len;
<a name="l00889"></a>00889     <span class="keywordtype">size_t</span> utf8_len;
<a name="l00890"></a>00890     <span class="keywordtype">size_t</span> ch_size;
<a name="l00891"></a>00891     <span class="keywordflow">if</span> (!term)
<a name="l00892"></a>00892         <span class="keywordflow">return</span> 0;
<a name="l00893"></a>00893     term = p_term_deref_non_null(term);
<a name="l00894"></a>00894     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l00895"></a>00895     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l00896"></a>00896         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8</a>(term-&gt;functor.functor_name);
<a name="l00897"></a>00897     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l00898"></a>00898         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8</a>(term-&gt;predicate.name);
<a name="l00899"></a>00899     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l00900"></a>00900         name = term-&gt;atom.name;
<a name="l00901"></a>00901         byte_len = term-&gt;header.size;
<a name="l00902"></a>00902         <span class="keywordflow">break</span>;
<a name="l00903"></a>00903     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l00904"></a>00904         name = term-&gt;string.name;
<a name="l00905"></a>00905         byte_len = term-&gt;header.size;
<a name="l00906"></a>00906         <span class="keywordflow">break</span>;
<a name="l00907"></a>00907     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l00908"></a>00908         byte_len = term-&gt;header.size;
<a name="l00909"></a>00909         <span class="keywordflow">if</span> (!byte_len)
<a name="l00910"></a>00910             <span class="keywordflow">return</span> 0;
<a name="l00911"></a>00911         name = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)(&amp;(term-&gt;var) + 1);
<a name="l00912"></a>00912         <span class="keywordflow">break</span>;
<a name="l00913"></a>00913     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l00914"></a>00914         <span class="keywordflow">return</span> <a class="code" href="group__term.html#gab6582e252c8a8333f4b03560f715e5fd" title="Returns the UTF-8 length of the name of the functor, predicate, atom, or variable...">p_term_name_length_utf8</a>(term-&gt;member_var.name);
<a name="l00915"></a>00915     <span class="keywordflow">default</span>: <span class="keywordflow">return</span> 0;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917     utf8_len = 0;
<a name="l00918"></a>00918     <span class="keywordflow">while</span> (byte_len &gt; 0) {
<a name="l00919"></a>00919         _p_term_next_utf8(name, byte_len, &amp;ch_size);
<a name="l00920"></a>00920         name += ch_size;
<a name="l00921"></a>00921         byte_len -= ch_size;
<a name="l00922"></a>00922         ++utf8_len;
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924     <span class="keywordflow">return</span> utf8_len;
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 
<a name="l00936"></a><a class="code" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48">00936</a> p_term *<a class="code" href="group__term.html#gad0dd17e897bd22628da3f65d063fca48" title="Returns the atom name of the functor or predicate term, or null if term is not a...">p_term_functor</a>(<span class="keyword">const</span> p_term *term)
<a name="l00937"></a>00937 {
<a name="l00938"></a>00938     <span class="keywordflow">if</span> (!term)
<a name="l00939"></a>00939         <span class="keywordflow">return</span> 0;
<a name="l00940"></a>00940     <span class="comment">/* Short-cut: avoid dereference if already a functor or predicate */</span>
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>)
<a name="l00942"></a>00942         <span class="keywordflow">return</span> term-&gt;functor.functor_name;
<a name="l00943"></a>00943     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l00944"></a>00944         <span class="keywordflow">return</span> term-&gt;predicate.name;
<a name="l00945"></a>00945     term = p_term_deref_non_null(term);
<a name="l00946"></a>00946     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>)
<a name="l00947"></a>00947         <span class="keywordflow">return</span> term-&gt;functor.functor_name;
<a name="l00948"></a>00948     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l00949"></a>00949         <span class="keywordflow">return</span> term-&gt;predicate.name;
<a name="l00950"></a>00950     <span class="keywordflow">return</span> 0;
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00963"></a><a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb">00963</a> p_term *<a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(<span class="keyword">const</span> p_term *term, <span class="keywordtype">int</span> index)
<a name="l00964"></a>00964 {
<a name="l00965"></a>00965     <span class="keywordflow">if</span> (!term)
<a name="l00966"></a>00966         <span class="keywordflow">return</span> 0;
<a name="l00967"></a>00967     <span class="comment">/* Short-cut: avoid the dereference if already a functor */</span>
<a name="l00968"></a>00968     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>) {
<a name="l00969"></a>00969         term = p_term_deref_non_null(term);
<a name="l00970"></a>00970         <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>)
<a name="l00971"></a>00971             <span class="keywordflow">return</span> 0;
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973     <span class="keywordflow">if</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)index) &lt; term-&gt;header.size)
<a name="l00974"></a>00974         <span class="keywordflow">return</span> term-&gt;functor.arg[index];
<a name="l00975"></a>00975     <span class="keywordflow">else</span>
<a name="l00976"></a>00976         <span class="keywordflow">return</span> 0;
<a name="l00977"></a>00977 }
<a name="l00978"></a>00978 
<a name="l00988"></a><a class="code" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c">00988</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c" title="Returns the 32-bit signed integer value within term, or zero if term is not an integer...">p_term_integer_value</a>(<span class="keyword">const</span> p_term *term)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990     <span class="keywordflow">if</span> (!term)
<a name="l00991"></a>00991         <span class="keywordflow">return</span> 0;
<a name="l00992"></a>00992 <span class="preprocessor">#if defined(P_TERM_64BIT)</span>
<a name="l00993"></a>00993 <span class="preprocessor"></span>    <span class="comment">/* The value is packed into the header, to save memory */</span>
<a name="l00994"></a>00994     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>)
<a name="l00995"></a>00995         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(term-&gt;header.size);
<a name="l00996"></a>00996     term = p_term_deref_non_null(term);
<a name="l00997"></a>00997     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>)
<a name="l00998"></a>00998         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(term-&gt;header.size);
<a name="l00999"></a>00999     <span class="keywordflow">else</span>
<a name="l01000"></a>01000         <span class="keywordflow">return</span> 0;
<a name="l01001"></a>01001 <span class="preprocessor">#else</span>
<a name="l01002"></a>01002 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>)
<a name="l01003"></a>01003         <span class="keywordflow">return</span> term-&gt;integer.value;
<a name="l01004"></a>01004     term = p_term_deref_non_null(term);
<a name="l01005"></a>01005     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>)
<a name="l01006"></a>01006         <span class="keywordflow">return</span> term-&gt;integer.value;
<a name="l01007"></a>01007     <span class="keywordflow">else</span>
<a name="l01008"></a>01008         <span class="keywordflow">return</span> 0;
<a name="l01009"></a>01009 <span class="preprocessor">#endif</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>}
<a name="l01011"></a>01011 
<a name="l01021"></a><a class="code" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d">01021</a> <span class="keywordtype">double</span> <a class="code" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d" title="Returns the double-precision floating point value within term, or zero if term is...">p_term_real_value</a>(<span class="keyword">const</span> p_term *term)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (!term)
<a name="l01024"></a>01024         <span class="keywordflow">return</span> 0.0;
<a name="l01025"></a>01025     <span class="comment">/* Short-cut: avoid the dereference if already a real */</span>
<a name="l01026"></a>01026     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>)
<a name="l01027"></a>01027         <span class="keywordflow">return</span> term-&gt;real.value;
<a name="l01028"></a>01028     term = p_term_deref_non_null(term);
<a name="l01029"></a>01029     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>)
<a name="l01030"></a>01030         <span class="keywordflow">return</span> term-&gt;real.value;
<a name="l01031"></a>01031     <span class="keywordflow">else</span>
<a name="l01032"></a>01032         <span class="keywordflow">return</span> 0.0;
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01044"></a><a class="code" href="group__term.html#ga084f1904b152af8467ab2c7a4dfbb403">01044</a> p_term *<a class="code" href="group__term.html#ga084f1904b152af8467ab2c7a4dfbb403" title="Returns the head of the specified list term, or null if term is not a list term.">p_term_head</a>(<span class="keyword">const</span> p_term *term)
<a name="l01045"></a>01045 {
<a name="l01046"></a>01046     <span class="keywordflow">if</span> (!term)
<a name="l01047"></a>01047         <span class="keywordflow">return</span> 0;
<a name="l01048"></a>01048     <span class="comment">/* Short-cut: avoid the dereference if already a list */</span>
<a name="l01049"></a>01049     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l01050"></a>01050         <span class="keywordflow">return</span> term-&gt;list.head;
<a name="l01051"></a>01051     term = p_term_deref_non_null(term);
<a name="l01052"></a>01052     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l01053"></a>01053         <span class="keywordflow">return</span> term-&gt;list.head;
<a name="l01054"></a>01054     <span class="keywordflow">else</span>
<a name="l01055"></a>01055         <span class="keywordflow">return</span> 0;
<a name="l01056"></a>01056 }
<a name="l01057"></a>01057 
<a name="l01067"></a><a class="code" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0">01067</a> p_term *<a class="code" href="group__term.html#gab2dd3010fa91261ac29d46a2b85974e0" title="Returns the tail of the specified list term, or null if term is not a list term.">p_term_tail</a>(<span class="keyword">const</span> p_term *term)
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069     <span class="keywordflow">if</span> (!term)
<a name="l01070"></a>01070         <span class="keywordflow">return</span> 0;
<a name="l01071"></a>01071     <span class="comment">/* Short-cut: avoid the dereference if already a list */</span>
<a name="l01072"></a>01072     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l01073"></a>01073         <span class="keywordflow">return</span> term-&gt;list.tail;
<a name="l01074"></a>01074     term = p_term_deref_non_null(term);
<a name="l01075"></a>01075     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l01076"></a>01076         <span class="keywordflow">return</span> term-&gt;list.tail;
<a name="l01077"></a>01077     <span class="keywordflow">else</span>
<a name="l01078"></a>01078         <span class="keywordflow">return</span> 0;
<a name="l01079"></a>01079 }
<a name="l01080"></a>01080 
<a name="l01092"></a><a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2">01092</a> p_term *<a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a>(<span class="keyword">const</span> p_term *term)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094     <span class="keywordflow">if</span> (!term)
<a name="l01095"></a>01095         <span class="keywordflow">return</span> 0;
<a name="l01096"></a>01096     <span class="comment">/* Short-cut: avoid the dereference if already a member var ref */</span>
<a name="l01097"></a>01097     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>)
<a name="l01098"></a>01098         <span class="keywordflow">return</span> term-&gt;member_var.object;
<a name="l01099"></a>01099     term = p_term_deref_non_null(term);
<a name="l01100"></a>01100     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>)
<a name="l01101"></a>01101         <span class="keywordflow">return</span> term-&gt;member_var.object;
<a name="l01102"></a>01102     <span class="keywordflow">else</span>
<a name="l01103"></a>01103         <span class="keywordflow">return</span> 0;
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 
<a name="l01116"></a><a class="code" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d">01116</a> p_term *<a class="code" href="group__term.html#ga3fa6a6d2393a60166fde6df21f76f92d" title="Creates an object term within context with the specified class prototype.">p_term_create_object</a>(p_context *context, p_term *prototype)
<a name="l01117"></a>01117 {
<a name="l01118"></a>01118     <span class="keyword">struct </span><a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a> *term;
<a name="l01119"></a>01119     <span class="keywordflow">if</span> (!prototype)
<a name="l01120"></a>01120         <span class="keywordflow">return</span> 0;
<a name="l01121"></a>01121     prototype = p_term_deref_non_null(prototype);
<a name="l01122"></a>01122     <span class="keywordflow">if</span> (prototype-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01123"></a>01123         <span class="keywordflow">return</span> 0;
<a name="l01124"></a>01124     term = p_term_new(context, <span class="keyword">struct</span> <a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a>);
<a name="l01125"></a>01125     <span class="keywordflow">if</span> (!term)
<a name="l01126"></a>01126         <span class="keywordflow">return</span> 0;
<a name="l01127"></a>01127     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>;
<a name="l01128"></a>01128     term-&gt;header.size = 1;
<a name="l01129"></a>01129     term-&gt;properties[0].name = context-&gt;prototype_atom;
<a name="l01130"></a>01130     term-&gt;properties[0].value = prototype;
<a name="l01131"></a>01131     <span class="keywordflow">return</span> (p_term *)term;
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 
<a name="l01145"></a><a class="code" href="group__term.html#gadd8c3bb381f75d082b9878a634e043ca">01145</a> p_term *<a class="code" href="group__term.html#gadd8c3bb381f75d082b9878a634e043ca" title="Creates a class object term within context for the class called name with the specified...">p_term_create_class_object</a>(p_context *context, p_term *class_name, p_term *prototype)
<a name="l01146"></a>01146 {
<a name="l01147"></a>01147     <span class="keyword">struct </span><a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a> *term;
<a name="l01148"></a>01148     <span class="keywordflow">if</span> (!class_name)
<a name="l01149"></a>01149         <span class="keywordflow">return</span> 0;
<a name="l01150"></a>01150     class_name = p_term_deref_non_null(class_name);
<a name="l01151"></a>01151     <span class="keywordflow">if</span> (class_name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01152"></a>01152         <span class="keywordflow">return</span> 0;
<a name="l01153"></a>01153     <span class="keywordflow">if</span> (prototype) {
<a name="l01154"></a>01154         prototype = p_term_deref_non_null(prototype);
<a name="l01155"></a>01155         <span class="keywordflow">if</span> (prototype-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01156"></a>01156             <span class="keywordflow">return</span> 0;
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158     term = p_term_new(context, <span class="keyword">struct</span> <a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a>);
<a name="l01159"></a>01159     <span class="keywordflow">if</span> (!term)
<a name="l01160"></a>01160         <span class="keywordflow">return</span> 0;
<a name="l01161"></a>01161     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>;
<a name="l01162"></a>01162     <span class="keywordflow">if</span> (prototype) {
<a name="l01163"></a>01163         <span class="comment">/* The prototype should be the first property if present */</span>
<a name="l01164"></a>01164         term-&gt;properties[0].name = context-&gt;prototype_atom;
<a name="l01165"></a>01165         term-&gt;properties[0].value = prototype;
<a name="l01166"></a>01166         term-&gt;properties[1].name = context-&gt;class_name_atom;
<a name="l01167"></a>01167         term-&gt;properties[1].value = class_name;
<a name="l01168"></a>01168         term-&gt;header.size = 2;
<a name="l01169"></a>01169     } <span class="keywordflow">else</span> {
<a name="l01170"></a>01170         term-&gt;properties[0].name = context-&gt;class_name_atom;
<a name="l01171"></a>01171         term-&gt;properties[0].value = class_name;
<a name="l01172"></a>01172         term-&gt;header.size = 1;
<a name="l01173"></a>01173     }
<a name="l01174"></a>01174     <span class="keywordflow">return</span> (p_term *)term;
<a name="l01175"></a>01175 }
<a name="l01176"></a>01176 
<a name="l01192"></a><a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137">01192</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property</a>(p_context *context, p_term *term, p_term *name, p_term *value)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194     <span class="comment">/* Validate the parameters */</span>
<a name="l01195"></a>01195     <span class="keywordflow">if</span> (!term || !name)
<a name="l01196"></a>01196         <span class="keywordflow">return</span> 0;
<a name="l01197"></a>01197     term = p_term_deref_non_null(term);
<a name="l01198"></a>01198     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01199"></a>01199         <span class="keywordflow">return</span> 0;
<a name="l01200"></a>01200     name = p_term_deref_non_null(name);
<a name="l01201"></a>01201     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01202"></a>01202         <span class="keywordflow">return</span> 0;
<a name="l01203"></a>01203     <span class="keywordflow">if</span> (name == context-&gt;prototype_atom ||
<a name="l01204"></a>01204             name == context-&gt;class_name_atom)
<a name="l01205"></a>01205         <span class="keywordflow">return</span> 0;
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="comment">/* Find an object block with spare capacity to add the property */</span>
<a name="l01208"></a>01208     <span class="keywordflow">while</span> (term-&gt;header.size &gt;= P_TERM_MAX_PROPS &amp;&amp; term-&gt;object.next)
<a name="l01209"></a>01209         term = term-&gt;object.next;
<a name="l01210"></a>01210     <span class="keywordflow">if</span> (term-&gt;header.size &gt;= P_TERM_MAX_PROPS) {
<a name="l01211"></a>01211         <span class="comment">/* Add a new extension block */</span>
<a name="l01212"></a>01212         p_term *block = p_term_malloc
<a name="l01213"></a>01213             (context, p_term, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="group__term.html#gad3aaeba3a153845864e314ecd112a7f2" title="Returns the object term associated with a member variable reference term, or null...">p_term_object</a>));
<a name="l01214"></a>01214         <span class="keywordflow">if</span> (!block)
<a name="l01215"></a>01215             <span class="keywordflow">return</span> 0;
<a name="l01216"></a>01216         block-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>;
<a name="l01217"></a>01217         term-&gt;object.next = block;
<a name="l01218"></a>01218         term = block;
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     <span class="comment">/* Add the new property */</span>
<a name="l01222"></a>01222     term-&gt;object.properties[term-&gt;header.size].name = name;
<a name="l01223"></a>01223     term-&gt;object.properties[term-&gt;header.size].value = value;
<a name="l01224"></a>01224     ++(term-&gt;header.size);
<a name="l01225"></a>01225     <span class="keywordflow">return</span> 1;
<a name="l01226"></a>01226 }
<a name="l01227"></a>01227 
<a name="l01239"></a><a class="code" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73">01239</a> p_term *<a class="code" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property</a>(p_context *context, <span class="keyword">const</span> p_term *term, <span class="keyword">const</span> p_term *name)
<a name="l01240"></a>01240 {
<a name="l01241"></a>01241     <span class="keyword">const</span> p_term *block;
<a name="l01242"></a>01242     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     <span class="comment">/* Validate the parameters */</span>
<a name="l01245"></a>01245     <span class="keywordflow">if</span> (!term || !name)
<a name="l01246"></a>01246         <span class="keywordflow">return</span> 0;
<a name="l01247"></a>01247     term = p_term_deref_non_null(term);
<a name="l01248"></a>01248     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01249"></a>01249         <span class="keywordflow">return</span> 0;
<a name="l01250"></a>01250     name = p_term_deref_non_null(name);
<a name="l01251"></a>01251     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01252"></a>01252         <span class="keywordflow">return</span> 0;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="keywordflow">for</span> (;;) {
<a name="l01255"></a>01255         <span class="comment">/* Locate the property in the object */</span>
<a name="l01256"></a>01256         block = term;
<a name="l01257"></a>01257         <span class="keywordflow">do</span> {
<a name="l01258"></a>01258             <span class="keywordflow">for</span> (index = 0; index &lt; block-&gt;header.size; ++index) {
<a name="l01259"></a>01259                 <span class="keywordflow">if</span> (block-&gt;object.properties[index].name == name)
<a name="l01260"></a>01260                     <span class="keywordflow">return</span> block-&gt;object.properties[index].value;
<a name="l01261"></a>01261             }
<a name="l01262"></a>01262             block = block-&gt;object.next;
<a name="l01263"></a>01263         } <span class="keywordflow">while</span> (block != 0);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265         <span class="comment">/* Try the prototype object instead */</span>
<a name="l01266"></a>01266         <span class="keywordflow">if</span> (term-&gt;object.properties[0].name != context-&gt;prototype_atom)
<a name="l01267"></a>01267             <span class="keywordflow">break</span>;
<a name="l01268"></a>01268         term = term-&gt;object.properties[0].value;
<a name="l01269"></a>01269     }
<a name="l01270"></a>01270     <span class="keywordflow">return</span> 0;
<a name="l01271"></a>01271 }
<a name="l01272"></a>01272 
<a name="l01283"></a><a class="code" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd">01283</a> p_term *<a class="code" href="group__term.html#gadeef4b96990a43a3e397d6c27a07fefd" title="Returns the value associated with the property name on term within context, or null...">p_term_own_property</a>(p_context *context, <span class="keyword">const</span> p_term *term, <span class="keyword">const</span> p_term *name)
<a name="l01284"></a>01284 {
<a name="l01285"></a>01285     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     <span class="comment">/* Validate the parameters */</span>
<a name="l01288"></a>01288     <span class="keywordflow">if</span> (!term || !name)
<a name="l01289"></a>01289         <span class="keywordflow">return</span> 0;
<a name="l01290"></a>01290     term = p_term_deref_non_null(term);
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01292"></a>01292         <span class="keywordflow">return</span> 0;
<a name="l01293"></a>01293     name = p_term_deref_non_null(name);
<a name="l01294"></a>01294     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01295"></a>01295         <span class="keywordflow">return</span> 0;
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="comment">/* Locate the property in the object */</span>
<a name="l01298"></a>01298     <span class="keywordflow">do</span> {
<a name="l01299"></a>01299         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l01300"></a>01300             <span class="keywordflow">if</span> (term-&gt;object.properties[index].name == name)
<a name="l01301"></a>01301                 <span class="keywordflow">return</span> term-&gt;object.properties[index].value;
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303         term = term-&gt;object.next;
<a name="l01304"></a>01304     } <span class="keywordflow">while</span> (term != 0);
<a name="l01305"></a>01305     <span class="keywordflow">return</span> 0;
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01328"></a><a class="code" href="group__term.html#gacbfe67d6fa4e2295ae305f390f22a715">01328</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gacbfe67d6fa4e2295ae305f390f22a715" title="Sets the value associated with the property name on term within context.">p_term_set_own_property</a>(p_context *context, p_term *term, p_term *name, p_term *value)
<a name="l01329"></a>01329 {
<a name="l01330"></a>01330     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="comment">/* Validate the parameters */</span>
<a name="l01333"></a>01333     <span class="keywordflow">if</span> (!term || !name)
<a name="l01334"></a>01334         <span class="keywordflow">return</span> 0;
<a name="l01335"></a>01335     term = p_term_deref_non_null(term);
<a name="l01336"></a>01336     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01337"></a>01337         <span class="keywordflow">return</span> 0;
<a name="l01338"></a>01338     name = p_term_deref_non_null(name);
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01340"></a>01340         <span class="keywordflow">return</span> 0;
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     <span class="comment">/* Locate the property in the object */</span>
<a name="l01343"></a>01343     <span class="keywordflow">do</span> {
<a name="l01344"></a>01344         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l01345"></a>01345             <span class="keywordflow">if</span> (term-&gt;object.properties[index].name == name) {
<a name="l01346"></a>01346                 term-&gt;object.properties[index].value = value;
<a name="l01347"></a>01347                 <span class="keywordflow">return</span> 1;
<a name="l01348"></a>01348             }
<a name="l01349"></a>01349         }
<a name="l01350"></a>01350         term = term-&gt;object.next;
<a name="l01351"></a>01351     } <span class="keywordflow">while</span> (term != 0);
<a name="l01352"></a>01352 
<a name="l01353"></a>01353     <span class="comment">/* Property not found, so add a new one */</span>
<a name="l01354"></a>01354     <span class="keywordflow">return</span> <a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property</a>(context, term, name, value);
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 
<a name="l01367"></a><a class="code" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207">01367</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207" title="Returns non-zero if term is an object within context and term is not a class object...">p_term_is_instance_object</a>(p_context *context, <span class="keyword">const</span> p_term *term)
<a name="l01368"></a>01368 {
<a name="l01369"></a>01369     p_term *name;
<a name="l01370"></a>01370     <span class="keywordflow">if</span> (!term)
<a name="l01371"></a>01371         <span class="keywordflow">return</span> 0;
<a name="l01372"></a>01372     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>) {
<a name="l01373"></a>01373         term = p_term_deref_non_null(term);
<a name="l01374"></a>01374         <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01375"></a>01375             <span class="keywordflow">return</span> 0;
<a name="l01376"></a>01376     }
<a name="l01377"></a>01377     name = context-&gt;class_name_atom;
<a name="l01378"></a>01378     <span class="keywordflow">return</span> term-&gt;object.properties[0].name != name &amp;&amp;
<a name="l01379"></a>01379            term-&gt;object.properties[1].name != name;
<a name="l01380"></a>01380 }
<a name="l01381"></a>01381 
<a name="l01392"></a><a class="code" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de">01392</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object</a>(p_context *context, <span class="keyword">const</span> p_term *term)
<a name="l01393"></a>01393 {
<a name="l01394"></a>01394     p_term *name;
<a name="l01395"></a>01395     <span class="keywordflow">if</span> (!term)
<a name="l01396"></a>01396         <span class="keywordflow">return</span> 0;
<a name="l01397"></a>01397     <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>) {
<a name="l01398"></a>01398         term = p_term_deref_non_null(term);
<a name="l01399"></a>01399         <span class="keywordflow">if</span> (term-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01400"></a>01400             <span class="keywordflow">return</span> 0;
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402     name = context-&gt;class_name_atom;
<a name="l01403"></a>01403     <span class="keywordflow">return</span> term-&gt;object.properties[0].name == name ||
<a name="l01404"></a>01404            term-&gt;object.properties[1].name == name;
<a name="l01405"></a>01405 }
<a name="l01406"></a>01406 
<a name="l01416"></a><a class="code" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21">01416</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21" title="Returns non-zero if term1 inherits from term2 within context, zero otherwise.">p_term_inherits</a>(p_context *context, <span class="keyword">const</span> p_term *term1, <span class="keyword">const</span> p_term *term2)
<a name="l01417"></a>01417 {
<a name="l01418"></a>01418     p_term *pname = context-&gt;prototype_atom;
<a name="l01419"></a>01419     <span class="keywordflow">if</span> (!term1 || !term2)
<a name="l01420"></a>01420         <span class="keywordflow">return</span> 0;
<a name="l01421"></a>01421     term2 = p_term_deref_non_null(term2);
<a name="l01422"></a>01422     <span class="keywordflow">if</span> (term2-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01423"></a>01423         <span class="keywordflow">return</span> 0;
<a name="l01424"></a>01424     <span class="keywordflow">do</span> {
<a name="l01425"></a>01425         term1 = p_term_deref_non_null(term1);
<a name="l01426"></a>01426         <span class="keywordflow">if</span> (term1 == term2)
<a name="l01427"></a>01427             <span class="keywordflow">return</span> 1;
<a name="l01428"></a>01428         <span class="keywordflow">if</span> (term1-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l01429"></a>01429             <span class="keywordflow">break</span>;
<a name="l01430"></a>01430         <span class="keywordflow">if</span> (term1-&gt;object.properties[0].name != pname)
<a name="l01431"></a>01431             <span class="keywordflow">break</span>;
<a name="l01432"></a>01432         term1 = term1-&gt;object.properties[0].value;
<a name="l01433"></a>01433     } <span class="keywordflow">while</span> (term1 != 0);
<a name="l01434"></a>01434     <span class="keywordflow">return</span> 0;
<a name="l01435"></a>01435 }
<a name="l01436"></a>01436 
<a name="l01447"></a><a class="code" href="group__term.html#gabb40c835640fed369b9ce34375663aab">01447</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gabb40c835640fed369b9ce34375663aab" title="Returns non-zero if term1 is an instance of term2, zero otherwise.">p_term_is_instance_of</a>(p_context *context, <span class="keyword">const</span> p_term *term1, <span class="keyword">const</span> p_term *term2)
<a name="l01448"></a>01448 {
<a name="l01449"></a>01449     <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#gae5e5969d3f3b1b70e062436b89f7a207" title="Returns non-zero if term is an object within context and term is not a class object...">p_term_is_instance_object</a>(context, term1))
<a name="l01450"></a>01450         <span class="keywordflow">return</span> 0;
<a name="l01451"></a>01451     <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object</a>(context, term2))
<a name="l01452"></a>01452         <span class="keywordflow">return</span> 0;
<a name="l01453"></a>01453     <span class="keywordflow">return</span> <a class="code" href="group__term.html#gaac80dd2765e7ce6c8b1a209e9fa92a21" title="Returns non-zero if term1 inherits from term2 within context, zero otherwise.">p_term_inherits</a>(context, term1, term2);
<a name="l01454"></a>01454 }
<a name="l01455"></a>01455 
<a name="l01469"></a><a class="code" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb">01469</a> p_term *<a class="code" href="group__term.html#gaa9d06aa5a8ea6c4a8009317ee107b8eb" title="Creates a new predicate instance within context with the specified name and arg_count...">p_term_create_predicate</a>(p_context *context, p_term *name, <span class="keywordtype">int</span> arg_count)
<a name="l01470"></a>01470 {
<a name="l01471"></a>01471     <span class="keyword">struct </span>p_term_predicate *term;
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="comment">/* Bail out if the parameters are invalid */</span>
<a name="l01474"></a>01474     <span class="keywordflow">if</span> (!name || arg_count &lt; 0)
<a name="l01475"></a>01475         <span class="keywordflow">return</span> 0;
<a name="l01476"></a>01476     <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>) {
<a name="l01477"></a>01477         name = p_term_deref_non_null(name);
<a name="l01478"></a>01478         <span class="keywordflow">if</span> (name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01479"></a>01479             <span class="keywordflow">return</span> 0;
<a name="l01480"></a>01480     }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482     <span class="comment">/* Create the predicate term */</span>
<a name="l01483"></a>01483     term = p_term_new(context, <span class="keyword">struct</span> p_term_predicate);
<a name="l01484"></a>01484     <span class="keywordflow">if</span> (!term)
<a name="l01485"></a>01485         <span class="keywordflow">return</span> 0;
<a name="l01486"></a>01486     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>;
<a name="l01487"></a>01487     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)arg_count;
<a name="l01488"></a>01488     term-&gt;name = name;
<a name="l01489"></a>01489     <span class="keywordflow">return</span> (p_term *)term;
<a name="l01490"></a>01490 }
<a name="l01491"></a>01491 
<a name="l01499"></a><a class="code" href="group__term.html#gac191f9077fea60ad8f19220301920b5b">01499</a> p_term *<a class="code" href="group__term.html#gac191f9077fea60ad8f19220301920b5b" title="Creates a new clause within context with the specified head and body.">p_term_create_dynamic_clause</a>(p_context *context, p_term *head, p_term *body)
<a name="l01500"></a>01500 {
<a name="l01501"></a>01501     <span class="keyword">struct </span>p_term_clause *term =
<a name="l01502"></a>01502         p_term_new(context, <span class="keyword">struct</span> p_term_clause);
<a name="l01503"></a>01503     p_code *code = _p_code_new();
<a name="l01504"></a>01504     <span class="keywordflow">if</span> (!term || !code)
<a name="l01505"></a>01505         <span class="keywordflow">return</span> 0;
<a name="l01506"></a>01506     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55badb8fcd6ce1379975862e21b90bf761c9">P_TERM_CLAUSE</a>;
<a name="l01507"></a>01507     _p_code_generate_dynamic_clause(context, head, body, code);
<a name="l01508"></a>01508     _p_code_finish(code, &amp;(term-&gt;clause_code));
<a name="l01509"></a>01509     <span class="keywordflow">return</span> (p_term *)term;
<a name="l01510"></a>01510 }
<a name="l01511"></a>01511 
<a name="l01512"></a>01512 <span class="comment">/* Add a clause to an indexed clause list */</span>
<a name="l01513"></a>01513 P_INLINE <span class="keywordtype">void</span> p_term_add_indexed_clause
<a name="l01514"></a>01514     (p_context *context, <span class="keyword">struct</span> p_term_clause_list *list,
<a name="l01515"></a>01515      <span class="keyword">struct</span> p_term_clause *clause, <span class="keywordtype">int</span> first)
<a name="l01516"></a>01516 {
<a name="l01517"></a>01517     <span class="keywordflow">if</span> (!list-&gt;head) {
<a name="l01518"></a>01518         list-&gt;head = clause;
<a name="l01519"></a>01519         list-&gt;tail = clause;
<a name="l01520"></a>01520         clause-&gt;next_index = 0;
<a name="l01521"></a>01521     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!first) {
<a name="l01522"></a>01522         list-&gt;tail-&gt;next_index = clause;
<a name="l01523"></a>01523         clause-&gt;next_index = 0;
<a name="l01524"></a>01524         list-&gt;tail = clause;
<a name="l01525"></a>01525     } <span class="keywordflow">else</span> {
<a name="l01526"></a>01526         clause-&gt;next_index = list-&gt;head;
<a name="l01527"></a>01527         list-&gt;head = clause;
<a name="l01528"></a>01528     }
<a name="l01529"></a>01529 }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531 <span class="comment">/* Add a clause to a regular (non-indexed) clause list */</span>
<a name="l01532"></a>01532 P_INLINE <span class="keywordtype">void</span> p_term_add_regular_clause
<a name="l01533"></a>01533     (p_context *context, <span class="keyword">struct</span> p_term_clause_list *list,
<a name="l01534"></a>01534      p_term *clause, <span class="keywordtype">int</span> first)
<a name="l01535"></a>01535 {
<a name="l01536"></a>01536     <span class="keywordflow">if</span> (!list-&gt;head) {
<a name="l01537"></a>01537         list-&gt;head = &amp;(clause-&gt;clause);
<a name="l01538"></a>01538         list-&gt;tail = &amp;(clause-&gt;clause);
<a name="l01539"></a>01539         clause-&gt;clause.next_clause = 0;
<a name="l01540"></a>01540     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!first) {
<a name="l01541"></a>01541         list-&gt;tail-&gt;next_clause = &amp;(clause-&gt;clause);
<a name="l01542"></a>01542         clause-&gt;clause.next_clause = 0;
<a name="l01543"></a>01543         list-&gt;tail = &amp;(clause-&gt;clause);
<a name="l01544"></a>01544     } <span class="keywordflow">else</span> {
<a name="l01545"></a>01545         clause-&gt;clause.next_clause = list-&gt;head;
<a name="l01546"></a>01546         list-&gt;head = &amp;(clause-&gt;clause);
<a name="l01547"></a>01547     }
<a name="l01548"></a>01548 }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="comment">/* Add a specific clause to a predicate&apos;s index */</span>
<a name="l01551"></a>01551 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_index_clause
<a name="l01552"></a>01552     (p_context *context, p_term *predicate,
<a name="l01553"></a>01553      <span class="keyword">struct</span> p_term_clause *clause, <span class="keywordtype">int</span> first)
<a name="l01554"></a>01554 {
<a name="l01555"></a>01555     p_rbkey key;
<a name="l01556"></a>01556     p_rbnode *node;
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     <span class="comment">/* Turn the index argument into a key.  If that isn&apos;t possible</span>
<a name="l01559"></a>01559 <span class="comment">     * (usually because the argument is a variable), then add it</span>
<a name="l01560"></a>01560 <span class="comment">     * to the list of &quot;variable clauses&quot; */</span>
<a name="l01561"></a>01561     <span class="keywordflow">if</span> (!_p_code_argument_key(&amp;key, &amp;(clause-&gt;clause_code),
<a name="l01562"></a>01562                               predicate-&gt;predicate.index_arg)) {
<a name="l01563"></a>01563         p_term_add_indexed_clause
<a name="l01564"></a>01564             (context, &amp;(predicate-&gt;predicate.var_clauses),
<a name="l01565"></a>01565              clause, first);
<a name="l01566"></a>01566         <span class="keywordflow">return</span>;
<a name="l01567"></a>01567     }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569     <span class="comment">/* Add the clause to the list associated with the key */</span>
<a name="l01570"></a>01570     node = _p_rbtree_insert(&amp;(predicate-&gt;predicate.index), &amp;key);
<a name="l01571"></a>01571     <span class="keywordflow">if</span> (!node)
<a name="l01572"></a>01572         <span class="keywordflow">return</span>;
<a name="l01573"></a>01573     p_term_add_indexed_clause(context, &amp;(node-&gt;clauses), clause, first);
<a name="l01574"></a>01574 }
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 <span class="comment">/* Add all clauses within a predicate to its index */</span>
<a name="l01577"></a>01577 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_index_all_clauses
<a name="l01578"></a>01578     (p_context *context, p_term *predicate)
<a name="l01579"></a>01579 {
<a name="l01580"></a>01580     <span class="keyword">struct </span>p_term_clause *clause;
<a name="l01581"></a>01581     p_rbkey key;
<a name="l01582"></a>01582     p_rbkey keys[4];
<a name="l01583"></a>01583     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> counts[4];
<a name="l01584"></a>01584     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> arg;
<a name="l01585"></a>01585     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_count;
<a name="l01586"></a>01586 
<a name="l01587"></a>01587     <span class="comment">/* Cannot index arity-0 predicates */</span>
<a name="l01588"></a>01588     <span class="keywordflow">if</span> (predicate-&gt;header.size == 0) {
<a name="l01589"></a>01589         predicate-&gt;predicate.dont_index = 1;
<a name="l01590"></a>01590         <span class="keywordflow">return</span>;
<a name="l01591"></a>01591     }
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <span class="comment">/* Determine the best argument to use for indexing by counting</span>
<a name="l01594"></a>01594 <span class="comment">     * the number of key changes in each argument.  The argument</span>
<a name="l01595"></a>01595 <span class="comment">     * with the most key changes is used for indexing */</span>
<a name="l01596"></a>01596     clause = predicate-&gt;predicate.clauses.head;
<a name="l01597"></a>01597     <span class="keywordflow">for</span> (arg = 0; arg &lt; 4 &amp;&amp; arg &lt; predicate-&gt;header.size; ++arg) {
<a name="l01598"></a>01598         <span class="keywordflow">if</span> (!_p_code_argument_key
<a name="l01599"></a>01599                 (&amp;(keys[arg]), &amp;(clause-&gt;clause_code), arg)) {
<a name="l01600"></a>01600             keys[arg].type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>;
<a name="l01601"></a>01601             keys[arg].size = 0;
<a name="l01602"></a>01602             keys[arg].name = 0;
<a name="l01603"></a>01603         }
<a name="l01604"></a>01604         counts[arg] = 0;
<a name="l01605"></a>01605     }
<a name="l01606"></a>01606     <span class="keywordflow">while</span> ((clause = clause-&gt;next_clause) != 0) {
<a name="l01607"></a>01607         <span class="keywordflow">for</span> (arg = 0; arg &lt; 4 &amp;&amp; arg &lt; predicate-&gt;header.size; ++arg) {
<a name="l01608"></a>01608             <span class="keywordflow">if</span> (!_p_code_argument_key
<a name="l01609"></a>01609                     (&amp;key, &amp;(clause-&gt;clause_code), arg)) {
<a name="l01610"></a>01610                 key.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>;
<a name="l01611"></a>01611                 key.size = 0;
<a name="l01612"></a>01612                 key.name = 0;
<a name="l01613"></a>01613             }
<a name="l01614"></a>01614             <span class="keywordflow">if</span> (_p_rbkey_compare_keys(&amp;(keys[arg]), &amp;key) != 0) {
<a name="l01615"></a>01615                 ++(counts[arg]);
<a name="l01616"></a>01616                 keys[arg] = key;
<a name="l01617"></a>01617             }
<a name="l01618"></a>01618         }
<a name="l01619"></a>01619     }
<a name="l01620"></a>01620     max_count = counts[0];
<a name="l01621"></a>01621     predicate-&gt;predicate.index_arg = 0;
<a name="l01622"></a>01622     <span class="keywordflow">for</span> (arg = 1; arg &lt; 4 &amp;&amp; arg &lt; predicate-&gt;header.size; ++arg) {
<a name="l01623"></a>01623         <span class="keywordflow">if</span> (counts[arg] &gt; max_count) {
<a name="l01624"></a>01624             max_count = counts[arg];
<a name="l01625"></a>01625             predicate-&gt;predicate.index_arg = arg;
<a name="l01626"></a>01626         }
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628     <span class="keywordflow">if</span> (predicate-&gt;predicate.index_arg == 0 &amp;&amp;
<a name="l01629"></a>01629             keys[0].type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a> &amp;&amp; !(counts[arg]) &amp;&amp;
<a name="l01630"></a>01630             predicate-&gt;header.size &gt;= 2) {
<a name="l01631"></a>01631         <span class="comment">/* Probably a class member predicate.  For some reason the</span>
<a name="l01632"></a>01632 <span class="comment">         * first argument was chosen for indexing, but the second</span>
<a name="l01633"></a>01633 <span class="comment">         * is more likely to be what we wanted */</span>
<a name="l01634"></a>01634         predicate-&gt;predicate.index_arg = 1;
<a name="l01635"></a>01635     }
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     <span class="comment">/* Add all existing clauses to the index */</span>
<a name="l01638"></a>01638     clause = predicate-&gt;predicate.clauses.head;
<a name="l01639"></a>01639     <span class="keywordflow">while</span> (clause != 0) {
<a name="l01640"></a>01640         p_term_index_clause(context, predicate, clause, 0);
<a name="l01641"></a>01641         clause = clause-&gt;next_clause;
<a name="l01642"></a>01642     }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644     <span class="comment">/* The predicate is now indexed */</span>
<a name="l01645"></a>01645     predicate-&gt;predicate.is_indexed = 1;
<a name="l01646"></a>01646 }
<a name="l01647"></a>01647 
<a name="l01648"></a>01648 <span class="comment">/* Renumber the clauses on a predicate because the clause number</span>
<a name="l01649"></a>01649 <span class="comment"> * has wrapped around to zero */</span>
<a name="l01650"></a>01650 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_renumber_clauses(p_term *predicate)
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clause_num = P_TERM_DEFAULT_CLAUSE_NUM -
<a name="l01653"></a>01653         predicate-&gt;predicate.clause_count / 2;
<a name="l01654"></a>01654     <span class="keyword">struct </span>p_term_clause *clause = predicate-&gt;predicate.clauses.head;
<a name="l01655"></a>01655     <span class="keywordflow">while</span> (clause != 0) {
<a name="l01656"></a>01656         clause-&gt;header.size = clause_num++;
<a name="l01657"></a>01657         clause = clause-&gt;next_clause;
<a name="l01658"></a>01658     }
<a name="l01659"></a>01659 }
<a name="l01660"></a>01660 
<a name="l01675"></a><a class="code" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada">01675</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga83bf2d0d46b0b4ce885efd5680b00ada" title="Adds clause to predicate within context at the front of the predicate&amp;#39;s clause...">p_term_add_clause_first</a>(p_context *context, p_term *predicate, p_term *clause)
<a name="l01676"></a>01676 {
<a name="l01677"></a>01677     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clause_num;
<a name="l01678"></a>01678     <span class="keywordflow">if</span> (predicate-&gt;predicate.clauses.head) {
<a name="l01679"></a>01679         <span class="keyword">struct </span>p_term_clause *first = predicate-&gt;predicate.clauses.head;
<a name="l01680"></a>01680         clause_num = first-&gt;header.size - 1;
<a name="l01681"></a>01681     } <span class="keywordflow">else</span> {
<a name="l01682"></a>01682         clause_num = P_TERM_DEFAULT_CLAUSE_NUM;
<a name="l01683"></a>01683     }
<a name="l01684"></a>01684     clause-&gt;header.size = clause_num;
<a name="l01685"></a>01685     p_term_add_regular_clause
<a name="l01686"></a>01686         (context, &amp;(predicate-&gt;predicate.clauses), clause, 1);
<a name="l01687"></a>01687     ++(predicate-&gt;predicate.clause_count);
<a name="l01688"></a>01688     <span class="keywordflow">if</span> (!clause-&gt;header.size)
<a name="l01689"></a>01689         p_term_renumber_clauses(predicate);
<a name="l01690"></a>01690     <span class="keywordflow">if</span> (predicate-&gt;predicate.is_indexed) {
<a name="l01691"></a>01691         p_term_index_clause(context, predicate, &amp;(clause-&gt;clause), 1);
<a name="l01692"></a>01692     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(predicate-&gt;predicate.dont_index) &amp;&amp;
<a name="l01693"></a>01693                predicate-&gt;predicate.clause_count &gt; P_TERM_INDEX_TRIGGER) {
<a name="l01694"></a>01694         p_term_index_all_clauses(context, predicate);
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696 }
<a name="l01697"></a>01697 
<a name="l01712"></a><a class="code" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa">01712</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga0e3ef6b55a045f1409bdb14a6e2bb4aa" title="Adds clause to predicate within context at the end of the predicate&amp;#39;s clause...">p_term_add_clause_last</a>(p_context *context, p_term *predicate, p_term *clause)
<a name="l01713"></a>01713 {
<a name="l01714"></a>01714     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clause_num;
<a name="l01715"></a>01715     <span class="keywordflow">if</span> (predicate-&gt;predicate.clauses.tail) {
<a name="l01716"></a>01716         <span class="keyword">struct </span>p_term_clause *last = predicate-&gt;predicate.clauses.tail;
<a name="l01717"></a>01717         clause_num = last-&gt;header.size + 1;
<a name="l01718"></a>01718     } <span class="keywordflow">else</span> {
<a name="l01719"></a>01719         clause_num = P_TERM_DEFAULT_CLAUSE_NUM;
<a name="l01720"></a>01720     }
<a name="l01721"></a>01721     clause-&gt;header.size = clause_num;
<a name="l01722"></a>01722     p_term_add_regular_clause
<a name="l01723"></a>01723         (context, &amp;(predicate-&gt;predicate.clauses), clause, 0);
<a name="l01724"></a>01724     ++(predicate-&gt;predicate.clause_count);
<a name="l01725"></a>01725     <span class="keywordflow">if</span> (!clause-&gt;header.size)
<a name="l01726"></a>01726         p_term_renumber_clauses(predicate);
<a name="l01727"></a>01727     <span class="keywordflow">if</span> (predicate-&gt;predicate.is_indexed) {
<a name="l01728"></a>01728         p_term_index_clause(context, predicate, &amp;(clause-&gt;clause), 0);
<a name="l01729"></a>01729     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(predicate-&gt;predicate.dont_index) &amp;&amp;
<a name="l01730"></a>01730                predicate-&gt;predicate.clause_count &gt; P_TERM_INDEX_TRIGGER) {
<a name="l01731"></a>01731         p_term_index_all_clauses(context, predicate);
<a name="l01732"></a>01732     }
<a name="l01733"></a>01733 }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="comment">/* Retract &quot;clause&quot; if it can be unified with &quot;clause2&quot; */</span>
<a name="l01736"></a>01736 <span class="keywordtype">int</span> _p_term_retract_clause
<a name="l01737"></a>01737     (p_context *context, p_term *predicate,
<a name="l01738"></a>01738      <span class="keyword">struct</span> p_term_clause *clause, p_term *clause2)
<a name="l01739"></a>01739 {
<a name="l01740"></a>01740     p_rbkey key;
<a name="l01741"></a>01741     p_rbnode *node;
<a name="l01742"></a>01742     p_term *body;
<a name="l01743"></a>01743     <span class="keywordtype">void</span> *marker;
<a name="l01744"></a>01744     <span class="keyword">struct </span>p_term_clause_list *list;
<a name="l01745"></a>01745     <span class="keyword">struct </span>p_term_clause *current;
<a name="l01746"></a>01746     <span class="keyword">struct </span>p_term_clause *prev;
<a name="l01747"></a>01747 
<a name="l01748"></a>01748     <span class="comment">/* Compute the key for the index argument */</span>
<a name="l01749"></a>01749     <span class="keywordflow">if</span> (!predicate-&gt;predicate.is_indexed ||
<a name="l01750"></a>01750             !_p_code_argument_key
<a name="l01751"></a>01751                 (&amp;key, &amp;(clause-&gt;clause_code),
<a name="l01752"></a>01752                  predicate-&gt;predicate.index_arg)) {
<a name="l01753"></a>01753         key.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>;
<a name="l01754"></a>01754         key.size = 0;
<a name="l01755"></a>01755         key.name = 0;
<a name="l01756"></a>01756     }
<a name="l01757"></a>01757 
<a name="l01758"></a>01758     <span class="comment">/* Unify against the clause to see if this is the one we wanted */</span>
<a name="l01759"></a>01759     marker = <a class="code" href="group__context.html#gac75be874ed6eb4ab5cded2f1146e9ff9" title="Marks the current position in the backtrack trail in context and returns a marker...">p_context_mark_trail</a>(context);
<a name="l01760"></a>01760     body = <a class="code" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485" title="Unifies term with the renamed head of clause.">p_term_unify_clause</a>
<a name="l01761"></a>01761         (context, <a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(clause2, 0), (p_term *)clause);
<a name="l01762"></a>01762     <span class="keywordflow">if</span> (!body)
<a name="l01763"></a>01763         <span class="keywordflow">return</span> 0;
<a name="l01764"></a>01764     <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5" title="Unifies term1 with term2 within context.">p_term_unify</a>(context, body,
<a name="l01765"></a>01765                       <a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(clause2, 1), <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aecdf42bd91c99f85a757b5dfe15d319d">P_BIND_DEFAULT</a>)) {
<a name="l01766"></a>01766         <a class="code" href="group__context.html#gabec73eb41d877b21bb78c742d3b8afe2" title="Backtracks the trail in context, undoing variable bindings until marker is reached...">p_context_backtrack_trail</a>(context, marker);
<a name="l01767"></a>01767         <span class="keywordflow">return</span> 0;
<a name="l01768"></a>01768     }
<a name="l01769"></a>01769 
<a name="l01770"></a>01770     <span class="comment">/* If the predicate is not indexed, then nothing more to do */</span>
<a name="l01771"></a>01771     <span class="keywordflow">if</span> (!predicate-&gt;predicate.is_indexed)
<a name="l01772"></a>01772         <span class="keywordflow">return</span> 1;
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     <span class="comment">/* Remove the clause from the index list it is a member of */</span>
<a name="l01775"></a>01775     <span class="keywordflow">if</span> (key.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>) {
<a name="l01776"></a>01776         node = _p_rbtree_lookup(&amp;(predicate-&gt;predicate.index), &amp;key);
<a name="l01777"></a>01777         <span class="keywordflow">if</span> (node)
<a name="l01778"></a>01778             list = &amp;(node-&gt;clauses);
<a name="l01779"></a>01779         <span class="keywordflow">else</span>
<a name="l01780"></a>01780             list = &amp;(predicate-&gt;predicate.var_clauses); <span class="comment">/* Just in case */</span>
<a name="l01781"></a>01781     } <span class="keywordflow">else</span> {
<a name="l01782"></a>01782         list = &amp;(predicate-&gt;predicate.var_clauses);
<a name="l01783"></a>01783     }
<a name="l01784"></a>01784     current = list-&gt;head;
<a name="l01785"></a>01785     prev = 0;
<a name="l01786"></a>01786     <span class="keywordflow">while</span> (current != 0 &amp;&amp; current != clause) {
<a name="l01787"></a>01787         prev = current;
<a name="l01788"></a>01788         current = current-&gt;next_index;
<a name="l01789"></a>01789     }
<a name="l01790"></a>01790     <span class="keywordflow">if</span> (!current)
<a name="l01791"></a>01791         <span class="keywordflow">return</span> 1;
<a name="l01792"></a>01792     <span class="keywordflow">if</span> (prev) {
<a name="l01793"></a>01793         prev-&gt;next_index = current-&gt;next_index;
<a name="l01794"></a>01794         <span class="keywordflow">if</span> (!current-&gt;next_index)
<a name="l01795"></a>01795             list-&gt;tail = prev;
<a name="l01796"></a>01796     } <span class="keywordflow">else</span> {
<a name="l01797"></a>01797         list-&gt;head = current-&gt;next_index;
<a name="l01798"></a>01798         <span class="keywordflow">if</span> (!(list-&gt;head)) {
<a name="l01799"></a>01799             list-&gt;tail = 0;
<a name="l01800"></a>01800             <span class="keywordflow">if</span> (key.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>)
<a name="l01801"></a>01801                 _p_rbtree_remove(&amp;(predicate-&gt;predicate.index), &amp;key);
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803     }
<a name="l01804"></a>01804     <span class="keywordflow">return</span> 1;
<a name="l01805"></a>01805 }
<a name="l01806"></a>01806 
<a name="l01821"></a><a class="code" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4">01821</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga9af92fee96e9b92ecca2f952667944b4" title="Starts an iteration over the clauses of predicate, using iter as the iteration control...">p_term_clauses_begin</a>(<span class="keyword">const</span> p_term *predicate, <span class="keyword">const</span> p_term *head, p_term_clause_iter *iter)
<a name="l01822"></a>01822 {
<a name="l01823"></a>01823     iter-&gt;next1 = 0;
<a name="l01824"></a>01824     iter-&gt;next2 = 0;
<a name="l01825"></a>01825     iter-&gt;next3 = 0;
<a name="l01826"></a>01826     <span class="keywordflow">if</span> (!predicate)
<a name="l01827"></a>01827         <span class="keywordflow">return</span>;
<a name="l01828"></a>01828     <span class="keywordflow">if</span> (predicate-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>) {
<a name="l01829"></a>01829         predicate = p_term_deref_non_null(predicate);
<a name="l01830"></a>01830         <span class="keywordflow">if</span> (predicate-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l01831"></a>01831             <span class="keywordflow">return</span>;
<a name="l01832"></a>01832     }
<a name="l01833"></a>01833     <span class="keywordflow">if</span> (head &amp;&amp; predicate-&gt;predicate.is_indexed) {
<a name="l01834"></a>01834         p_rbkey key;
<a name="l01835"></a>01835         p_rbnode *node;
<a name="l01836"></a>01836         p_term *arg = <a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(head, predicate-&gt;predicate.index_arg);
<a name="l01837"></a>01837         <span class="keywordflow">if</span> (_p_rbkey_init(&amp;key, arg)) {
<a name="l01838"></a>01838             node = _p_rbtree_lookup
<a name="l01839"></a>01839                 (&amp;(predicate-&gt;predicate.index), &amp;key);
<a name="l01840"></a>01840             <span class="keywordflow">if</span> (node) {
<a name="l01841"></a>01841                 iter-&gt;next1 = node-&gt;clauses.head;
<a name="l01842"></a>01842                 iter-&gt;next2 = predicate-&gt;predicate.var_clauses.head;
<a name="l01843"></a>01843                 <span class="keywordflow">return</span>;
<a name="l01844"></a>01844             }
<a name="l01845"></a>01845         }
<a name="l01846"></a>01846     }
<a name="l01847"></a>01847     iter-&gt;next3 = predicate-&gt;predicate.clauses.head;
<a name="l01848"></a>01848 }
<a name="l01849"></a>01849 
<a name="l01857"></a><a class="code" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a">01857</a> p_term *<a class="code" href="group__term.html#ga9f12d42eecc40407851784aa0c21db1a" title="Returns the next clause for the iteration control block iter.">p_term_clauses_next</a>(p_term_clause_iter *iter)
<a name="l01858"></a>01858 {
<a name="l01859"></a>01859     <span class="keyword">struct </span>p_term_clause *clause;
<a name="l01860"></a>01860     <span class="keywordflow">if</span> (iter-&gt;next1) {
<a name="l01861"></a>01861         clause = iter-&gt;next1;
<a name="l01862"></a>01862         <span class="keywordflow">if</span> (iter-&gt;next2 &amp;&amp; iter-&gt;next2-&gt;header.size &lt; clause-&gt;header.size) {
<a name="l01863"></a>01863             clause = iter-&gt;next2;
<a name="l01864"></a>01864             iter-&gt;next2 = clause-&gt;next_index;
<a name="l01865"></a>01865         } <span class="keywordflow">else</span> {
<a name="l01866"></a>01866             iter-&gt;next1 = clause-&gt;next_index;
<a name="l01867"></a>01867             <span class="keywordflow">if</span> (!(iter-&gt;next1)) {
<a name="l01868"></a>01868                 iter-&gt;next1 = iter-&gt;next2;
<a name="l01869"></a>01869                 iter-&gt;next2 = 0;
<a name="l01870"></a>01870             }
<a name="l01871"></a>01871         }
<a name="l01872"></a>01872         <span class="keywordflow">return</span> (p_term *)clause;
<a name="l01873"></a>01873     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iter-&gt;next3) {
<a name="l01874"></a>01874         clause = iter-&gt;next3;
<a name="l01875"></a>01875         iter-&gt;next3 = clause-&gt;next_clause;
<a name="l01876"></a>01876         <span class="keywordflow">return</span> (p_term *)clause;
<a name="l01877"></a>01877     }
<a name="l01878"></a>01878     <span class="keywordflow">return</span> 0;
<a name="l01879"></a>01879 }
<a name="l01880"></a>01880 
<a name="l01888"></a><a class="code" href="group__term.html#ga96bedcc8fb7e25d93845faa4a78bcd77">01888</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga96bedcc8fb7e25d93845faa4a78bcd77" title="Returns non-zero if iter has more clauses yet to be iterated.">p_term_clauses_has_more</a>(<span class="keyword">const</span> p_term_clause_iter *iter)
<a name="l01889"></a>01889 {
<a name="l01890"></a>01890     <span class="keywordflow">return</span> iter-&gt;next1 != 0 || iter-&gt;next3 != 0;
<a name="l01891"></a>01891 }
<a name="l01892"></a>01892 
<a name="l01899"></a><a class="code" href="group__term.html#gaece9b6033996b5718a7e2f3d360e62ba">01899</a> p_term *<a class="code" href="group__term.html#gaece9b6033996b5718a7e2f3d360e62ba" title="Returns a new database term within context.">p_term_create_database</a>(p_context *context)
<a name="l01900"></a>01900 {
<a name="l01901"></a>01901     <span class="keyword">struct </span>p_term_database *term =
<a name="l01902"></a>01902         p_term_new(context, <span class="keyword">struct</span> p_term_database);
<a name="l01903"></a>01903     <span class="keywordflow">if</span> (!term)
<a name="l01904"></a>01904         <span class="keywordflow">return</span> 0;
<a name="l01905"></a>01905     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>;
<a name="l01906"></a>01906     <span class="keywordflow">return</span> (p_term *)term;
<a name="l01907"></a>01907 }
<a name="l01908"></a>01908 
<a name="l01916"></a><a class="code" href="group__term.html#ga672972a8bcdd8790638276dc8db446f3">01916</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga672972a8bcdd8790638276dc8db446f3" title="Adds predicate to database.">p_term_database_add_predicate</a>(p_term *database, p_term *predicate)
<a name="l01917"></a>01917 {
<a name="l01918"></a>01918     p_rbkey key;
<a name="l01919"></a>01919     p_rbnode *node;
<a name="l01920"></a>01920     database = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(database);
<a name="l01921"></a>01921     predicate = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(predicate);
<a name="l01922"></a>01922     <span class="keywordflow">if</span> (!database || database-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>)
<a name="l01923"></a>01923         <span class="keywordflow">return</span>;
<a name="l01924"></a>01924     <span class="keywordflow">if</span> (!predicate || predicate-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>)
<a name="l01925"></a>01925         <span class="keywordflow">return</span>;
<a name="l01926"></a>01926     key.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>;
<a name="l01927"></a>01927     key.size = predicate-&gt;header.size;
<a name="l01928"></a>01928     key.name = predicate-&gt;predicate.name;
<a name="l01929"></a>01929     node = _p_rbtree_insert(&amp;(database-&gt;database.predicates), &amp;key);
<a name="l01930"></a>01930     <span class="keywordflow">if</span> (!node)
<a name="l01931"></a>01931         <span class="keywordflow">return</span>;
<a name="l01932"></a>01932     node-&gt;value = predicate;
<a name="l01933"></a>01933 }
<a name="l01934"></a>01934 
<a name="l01944"></a>01944 p_term *<a class="code" href="group__term.html#gac4f5d5ff89205c3c02945657616a5ea5" title="Returns the predicate in database that is associated with name and arity.">p_term_database_lookup_predicate</a>
<a name="l01945"></a><a class="code" href="group__term.html#gac4f5d5ff89205c3c02945657616a5ea5">01945</a>     (p_term *database, p_term *name, <span class="keywordtype">int</span> arity)
<a name="l01946"></a>01946 {
<a name="l01947"></a>01947     p_rbkey key;
<a name="l01948"></a>01948     p_rbnode *node;
<a name="l01949"></a>01949     database = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(database);
<a name="l01950"></a>01950     name = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(name);
<a name="l01951"></a>01951     <span class="keywordflow">if</span> (!database || database-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>)
<a name="l01952"></a>01952         <span class="keywordflow">return</span> 0;
<a name="l01953"></a>01953     <span class="keywordflow">if</span> (!name || name-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l01954"></a>01954         <span class="keywordflow">return</span> 0;
<a name="l01955"></a>01955     key.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>;
<a name="l01956"></a>01956     key.size = arity;
<a name="l01957"></a>01957     key.name = name;
<a name="l01958"></a>01958     node = _p_rbtree_lookup(&amp;(database-&gt;database.predicates), &amp;key);
<a name="l01959"></a>01959     <span class="keywordflow">if</span> (node)
<a name="l01960"></a>01960         <span class="keywordflow">return</span> node-&gt;value;
<a name="l01961"></a>01961     <span class="keywordflow">else</span>
<a name="l01962"></a>01962         <span class="keywordflow">return</span> 0;
<a name="l01963"></a>01963 }
<a name="l01964"></a>01964 
<a name="l01976"></a>01976 p_term *<a class="code" href="group__term.html#gac26b67ff7d5f2ad9e55e92ba74d69179" title="Returns an atom which is the concatenation of class_name, ::, and name. The atom...">p_term_create_member_name</a>
<a name="l01977"></a><a class="code" href="group__term.html#gac26b67ff7d5f2ad9e55e92ba74d69179">01977</a>     (p_context *context, p_term *class_name, p_term *name)
<a name="l01978"></a>01978 {
<a name="l01979"></a>01979     <span class="keywordtype">size_t</span> clen = <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(class_name);
<a name="l01980"></a>01980     <span class="keywordtype">size_t</span> nlen = <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(name);
<a name="l01981"></a>01981     <span class="keywordtype">char</span> *str = (<span class="keywordtype">char</span> *)GC_MALLOC(clen + nlen + 2);
<a name="l01982"></a>01982     p_term *result;
<a name="l01983"></a>01983     <span class="keywordflow">if</span> (!str)
<a name="l01984"></a>01984         <span class="keywordflow">return</span> name;
<a name="l01985"></a>01985     memcpy(str, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(class_name), clen);
<a name="l01986"></a>01986     str[clen] = <span class="charliteral">&apos;:&apos;</span>;
<a name="l01987"></a>01987     str[clen + 1] = <span class="charliteral">&apos;:&apos;</span>;
<a name="l01988"></a>01988     memcpy(str + clen + 2, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(name), nlen);
<a name="l01989"></a>01989     result = <a class="code" href="group__term.html#ga7cdf6cb2a37ac6bd1852f52019243067" title="Creates an atom within context with the len bytes at name as its atom name.">p_term_create_atom_n</a>(context, str, clen + nlen + 2);
<a name="l01990"></a>01990     GC_FREE(str);
<a name="l01991"></a>01991     <span class="keywordflow">return</span> result;
<a name="l01992"></a>01992 }
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 <span class="comment">/* Perform an occurs check */</span>
<a name="l01995"></a>01995 <span class="keywordtype">int</span> p_term_occurs_in(<span class="keyword">const</span> p_term *var, <span class="keyword">const</span> p_term *value)
<a name="l01996"></a>01996 {
<a name="l01997"></a>01997     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l01998"></a>01998     <span class="keywordflow">if</span> (!value)
<a name="l01999"></a>01999         <span class="keywordflow">return</span> 0;
<a name="l02000"></a>02000     value = p_term_deref_non_null(value);
<a name="l02001"></a>02001     <span class="keywordflow">if</span> (var == value)
<a name="l02002"></a>02002         <span class="keywordflow">return</span> 1;
<a name="l02003"></a>02003     <span class="keywordflow">switch</span> (value-&gt;header.type) {
<a name="l02004"></a>02004     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l02005"></a>02005         <span class="comment">/* Scan the functor arguments */</span>
<a name="l02006"></a>02006         <span class="keywordflow">for</span> (index = 0; index &lt; value-&gt;header.size; ++index) {
<a name="l02007"></a>02007             <span class="keywordflow">if</span> (p_term_occurs_in(var, value-&gt;functor.arg[index]))
<a name="l02008"></a>02008                 <span class="keywordflow">return</span> 1;
<a name="l02009"></a>02009         }
<a name="l02010"></a>02010         <span class="keywordflow">break</span>;
<a name="l02011"></a>02011     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>:
<a name="l02012"></a>02012         <span class="comment">/* Try to reduce depth of recursion issues with long lists */</span>
<a name="l02013"></a>02013         <span class="keywordflow">do</span> {
<a name="l02014"></a>02014             <span class="keywordflow">if</span> (p_term_occurs_in(var, value-&gt;list.head))
<a name="l02015"></a>02015                 <span class="keywordflow">return</span> 1;
<a name="l02016"></a>02016             value = value-&gt;list.tail;
<a name="l02017"></a>02017             <span class="keywordflow">if</span> (!value)
<a name="l02018"></a>02018                 <span class="keywordflow">return</span> 0;
<a name="l02019"></a>02019             value = p_term_deref_non_null(value);
<a name="l02020"></a>02020         } <span class="keywordflow">while</span> (value-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>);
<a name="l02021"></a>02021         <span class="keywordflow">if</span> (value-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>)
<a name="l02022"></a>02022             <span class="keywordflow">return</span> p_term_occurs_in(var, value);
<a name="l02023"></a>02023         <span class="keywordflow">break</span>;
<a name="l02024"></a>02024     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>:
<a name="l02025"></a>02025         <span class="comment">/* Scan the object&apos;s property values */</span>
<a name="l02026"></a>02026         <span class="keywordflow">do</span> {
<a name="l02027"></a>02027             <span class="keywordflow">for</span> (index = 0; index &lt; value-&gt;header.size; ++index) {
<a name="l02028"></a>02028                 <span class="keywordflow">if</span> (p_term_occurs_in
<a name="l02029"></a>02029                         (var, value-&gt;object.properties[index].value))
<a name="l02030"></a>02030                     <span class="keywordflow">return</span> 1;
<a name="l02031"></a>02031             }
<a name="l02032"></a>02032             value = value-&gt;object.next;
<a name="l02033"></a>02033         }
<a name="l02034"></a>02034         <span class="keywordflow">while</span> (value);
<a name="l02035"></a>02035         <span class="keywordflow">break</span>;
<a name="l02036"></a>02036     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l02037"></a>02037         <span class="keywordflow">return</span> p_term_occurs_in(var, value-&gt;member_var.object);
<a name="l02038"></a>02038     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l02039"></a>02039     }
<a name="l02040"></a>02040     <span class="keywordflow">return</span> 0;
<a name="l02041"></a>02041 }
<a name="l02042"></a>02042 
<a name="l02111"></a><a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620">02111</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gae57ac2b3a143aef55d00866eda241620" title="Binds the variable var to value.">p_term_bind_variable</a>(p_context *context, p_term *var, p_term *value, <span class="keywordtype">int</span> flags)
<a name="l02112"></a>02112 {
<a name="l02113"></a>02113     <span class="keywordflow">if</span> (!var)
<a name="l02114"></a>02114         <span class="keywordflow">return</span> 0;
<a name="l02115"></a>02115     var = p_term_deref_non_null(var);
<a name="l02116"></a>02116     <span class="keywordflow">if</span> ((var-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>) == 0)
<a name="l02117"></a>02117         <span class="keywordflow">return</span> 0;
<a name="l02118"></a>02118     <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7a1b97003b7e5a756907ed123993a6c8be">P_BIND_NO_OCCURS_CHECK</a>) == 0) {
<a name="l02119"></a>02119         <span class="keywordflow">if</span> (p_term_occurs_in(var, value))
<a name="l02120"></a>02120             <span class="keywordflow">return</span> 0;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122     <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7af391516c7209a944bd98d45c9db42ab9">P_BIND_NO_RECORD</a>) == 0) {
<a name="l02123"></a>02123         <span class="keywordflow">if</span> (!_p_context_record_in_trail(context, var))
<a name="l02124"></a>02124             <span class="keywordflow">return</span> 0;
<a name="l02125"></a>02125     }
<a name="l02126"></a>02126     var-&gt;var.value = value;
<a name="l02127"></a>02127     <span class="keywordflow">return</span> 1;
<a name="l02128"></a>02128 }
<a name="l02129"></a>02129 
<a name="l02130"></a>02130 <span class="comment">/* Internal variable binding where &quot;var&quot; is known to be unbound */</span>
<a name="l02131"></a>02131 P_INLINE <span class="keywordtype">int</span> p_term_bind_var(p_context *context, p_term *var, p_term *value, <span class="keywordtype">int</span> flags)
<a name="l02132"></a>02132 {
<a name="l02133"></a>02133     <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7a1b97003b7e5a756907ed123993a6c8be">P_BIND_NO_OCCURS_CHECK</a>) == 0) {
<a name="l02134"></a>02134         <span class="keywordflow">if</span> (p_term_occurs_in(var, value))
<a name="l02135"></a>02135             <span class="keywordflow">return</span> 0;
<a name="l02136"></a>02136     }
<a name="l02137"></a>02137     <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7af391516c7209a944bd98d45c9db42ab9">P_BIND_NO_RECORD</a>) == 0) {
<a name="l02138"></a>02138         <span class="keywordflow">if</span> (!_p_context_record_in_trail(context, var))
<a name="l02139"></a>02139             <span class="keywordflow">return</span> 0;
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141     var-&gt;var.value = value;
<a name="l02142"></a>02142     <span class="keywordflow">return</span> 1;
<a name="l02143"></a>02143 }
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="comment">/* Forward declaration */</span>
<a name="l02146"></a>02146 <span class="keyword">static</span> <span class="keywordtype">int</span> p_term_unify_inner(p_context *context, p_term *term1, p_term *term2, <span class="keywordtype">int</span> flags);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148 <span class="comment">/* Resolve a member variable reference */</span>
<a name="l02149"></a>02149 <span class="keyword">static</span> p_term *p_term_resolve_member(p_context *context, p_term *term, <span class="keywordtype">int</span> flags)
<a name="l02150"></a>02150 {
<a name="l02151"></a>02151     p_term *<span class="keywordtype">object</span> = term-&gt;member_var.object;
<a name="l02152"></a>02152     p_term *value;
<a name="l02153"></a>02153     <span class="keywordflow">if</span> (!<span class="keywordtype">object</span>)
<a name="l02154"></a>02154         <span class="keywordflow">return</span> 0;
<a name="l02155"></a>02155     <span class="keywordtype">object</span> = p_term_deref_non_null(<span class="keywordtype">object</span>);
<a name="l02156"></a>02156     <span class="keywordflow">if</span> (object-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>) {
<a name="l02157"></a>02157         <span class="comment">/* Resolve a nested member reference */</span>
<a name="l02158"></a>02158         <span class="keywordtype">object</span> = p_term_resolve_member(context, <span class="keywordtype">object</span>, flags);
<a name="l02159"></a>02159         <span class="keywordflow">if</span> (!<span class="keywordtype">object</span>)
<a name="l02160"></a>02160             <span class="keywordflow">return</span> 0;
<a name="l02161"></a>02161         <span class="keywordtype">object</span> = p_term_deref_non_null(<span class="keywordtype">object</span>);
<a name="l02162"></a>02162     }
<a name="l02163"></a>02163     <span class="keywordflow">if</span> (object-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>)
<a name="l02164"></a>02164         <span class="keywordflow">return</span> 0;
<a name="l02165"></a>02165     value = <a class="code" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property</a>(context, <span class="keywordtype">object</span>, term-&gt;member_var.name);
<a name="l02166"></a>02166     <span class="keywordflow">if</span> (!value &amp;&amp; term-&gt;header.size &amp;&amp; (flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7a8f12777e19fee1713ace4ed77f3531af">P_BIND_EQUALITY</a>) == 0) {
<a name="l02167"></a>02167         <span class="comment">/* Add a new property to the object */</span>
<a name="l02168"></a>02168         value = <a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(context);
<a name="l02169"></a>02169         <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#gab29419821fb3f557f9afad4aa633a137" title="Adds name and value as a property to term within context.">p_term_add_property</a>(context, <span class="keywordtype">object</span>,
<a name="l02170"></a>02170                                  term-&gt;member_var.name, value))
<a name="l02171"></a>02171             <span class="keywordflow">return</span> 0;
<a name="l02172"></a>02172     }
<a name="l02173"></a>02173     <span class="keywordflow">return</span> value;
<a name="l02174"></a>02174 }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176 <span class="comment">/* Unify an unbound variable against a term */</span>
<a name="l02177"></a>02177 <span class="keyword">static</span> <span class="keywordtype">int</span> p_term_unify_variable(p_context *context, p_term *term1, p_term *term2, <span class="keywordtype">int</span> flags)
<a name="l02178"></a>02178 {
<a name="l02179"></a>02179     <span class="comment">/* Resolve member variable references */</span>
<a name="l02180"></a>02180     <span class="keywordflow">if</span> (term1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>) {
<a name="l02181"></a>02181         term1 = p_term_resolve_member(context, term1, flags);
<a name="l02182"></a>02182         <span class="keywordflow">return</span> p_term_unify_inner(context, term1, term2, flags);
<a name="l02183"></a>02183     }
<a name="l02184"></a>02184     <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>) {
<a name="l02185"></a>02185         term2 = p_term_resolve_member(context, term2, flags);
<a name="l02186"></a>02186         <span class="keywordflow">return</span> p_term_unify_inner(context, term1, term2, flags);
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188 
<a name="l02189"></a>02189     <span class="comment">/* Bail out if unification is supposed to be non-destructive */</span>
<a name="l02190"></a>02190     <span class="keywordflow">if</span> (flags &amp; P_BIND_EQUALITY)
<a name="l02191"></a>02191         <span class="keywordflow">return</span> 0;
<a name="l02192"></a>02192 
<a name="l02193"></a>02193     <span class="comment">/* Bind the variable and return */</span>
<a name="l02194"></a>02194     <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aea634720ec46c87c4474abc404b736a2">P_BIND_RECORD_ONE_WAY</a>)
<a name="l02195"></a>02195         flags |= P_BIND_NO_RECORD;
<a name="l02196"></a>02196     <span class="keywordflow">return</span> p_term_bind_var(context, term1, term2, flags);
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="comment">/* Inner implementation of unification */</span>
<a name="l02200"></a>02200 <span class="keyword">static</span> <span class="keywordtype">int</span> p_term_unify_inner(p_context *context, p_term *term1, p_term *term2, <span class="keywordtype">int</span> flags)
<a name="l02201"></a>02201 {
<a name="l02202"></a>02202     <span class="keywordflow">if</span> (!term1 || !term2)
<a name="l02203"></a>02203         <span class="keywordflow">return</span> 0;
<a name="l02204"></a>02204     term1 = p_term_deref_non_null(term1);
<a name="l02205"></a>02205     term2 = p_term_deref_non_null(term2);
<a name="l02206"></a>02206     <span class="keywordflow">if</span> (term1 == term2)
<a name="l02207"></a>02207         <span class="keywordflow">return</span> 1;
<a name="l02208"></a>02208     <span class="keywordflow">if</span> (term1-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>)
<a name="l02209"></a>02209         <span class="keywordflow">return</span> p_term_unify_variable(context, term1, term2, flags);
<a name="l02210"></a>02210     <span class="keywordflow">if</span> (term2-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>) {
<a name="l02211"></a>02211         <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7af1a319cda712deef76d7c7a362b83c03">P_BIND_ONE_WAY</a>)
<a name="l02212"></a>02212             <span class="keywordflow">return</span> 0;
<a name="l02213"></a>02213         <span class="keywordflow">return</span> p_term_unify_variable
<a name="l02214"></a>02214             (context, term2, term1, flags &amp; ~<a class="code" href="group__term.html#gadf764cbdea00d65edcd07bb9953ad2b7aea634720ec46c87c4474abc404b736a2">P_BIND_RECORD_ONE_WAY</a>);
<a name="l02215"></a>02215     }
<a name="l02216"></a>02216     <span class="keywordflow">switch</span> (term1-&gt;header.type) {
<a name="l02217"></a>02217     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l02218"></a>02218         <span class="comment">/* Functor must have the same name and number of arguments */</span>
<a name="l02219"></a>02219         <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> &amp;&amp;
<a name="l02220"></a>02220                 term1-&gt;header.size == term2-&gt;header.size &amp;&amp;
<a name="l02221"></a>02221                 term1-&gt;functor.functor_name ==
<a name="l02222"></a>02222                         term2-&gt;functor.functor_name) {
<a name="l02223"></a>02223             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02224"></a>02224             <span class="keywordflow">for</span> (index = 0; index &lt; term1-&gt;header.size; ++index) {
<a name="l02225"></a>02225                 <span class="keywordflow">if</span> (!p_term_unify_inner
<a name="l02226"></a>02226                         (context, term1-&gt;functor.arg[index],
<a name="l02227"></a>02227                          term2-&gt;functor.arg[index], flags))
<a name="l02228"></a>02228                     <span class="keywordflow">return</span> 0;
<a name="l02229"></a>02229             }
<a name="l02230"></a>02230             <span class="keywordflow">return</span> 1;
<a name="l02231"></a>02231         }
<a name="l02232"></a>02232         <span class="keywordflow">break</span>;
<a name="l02233"></a>02233     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>:
<a name="l02234"></a>02234         <span class="comment">/* Unify the head and tail components of the list,</span>
<a name="l02235"></a>02235 <span class="comment">         * while trying to reduce recursion depth */</span>
<a name="l02236"></a>02236         <span class="keywordflow">if</span> (term2-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l02237"></a>02237             <span class="keywordflow">return</span> 0;
<a name="l02238"></a>02238         <span class="keywordflow">for</span> (;;) {
<a name="l02239"></a>02239             <span class="keywordflow">if</span> (!p_term_unify_inner(context, term1-&gt;list.head,
<a name="l02240"></a>02240                                     term2-&gt;list.head, flags))
<a name="l02241"></a>02241                 <span class="keywordflow">break</span>;
<a name="l02242"></a>02242             term1 = term1-&gt;list.tail;
<a name="l02243"></a>02243             term2 = term2-&gt;list.tail;
<a name="l02244"></a>02244             <span class="keywordflow">if</span> (!term1 || !term2)
<a name="l02245"></a>02245                 <span class="keywordflow">break</span>;
<a name="l02246"></a>02246             term1 = p_term_deref_non_null(term1);
<a name="l02247"></a>02247             term2 = p_term_deref_non_null(term2);
<a name="l02248"></a>02248             <span class="keywordflow">if</span> (term1-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a> ||
<a name="l02249"></a>02249                     term2-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>)
<a name="l02250"></a>02250                 <span class="keywordflow">return</span> p_term_unify_inner(context, term1, term2, flags);
<a name="l02251"></a>02251         }
<a name="l02252"></a>02252         <span class="keywordflow">break</span>;
<a name="l02253"></a>02253     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l02254"></a>02254         <span class="comment">/* Atoms can unify only if their pointers are identical.</span>
<a name="l02255"></a>02255 <span class="comment">         * Identity has already been checked, so fail */</span>
<a name="l02256"></a>02256         <span class="keywordflow">break</span>;
<a name="l02257"></a>02257     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l02258"></a>02258         <span class="comment">/* Compare two strings */</span>
<a name="l02259"></a>02259         <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a> &amp;&amp;
<a name="l02260"></a>02260                 term1-&gt;header.size == term2-&gt;header.size &amp;&amp;
<a name="l02261"></a>02261                 !memcmp(term1-&gt;string.name, term2-&gt;string.name,
<a name="l02262"></a>02262                         term1-&gt;header.size))
<a name="l02263"></a>02263             <span class="keywordflow">return</span> 1;
<a name="l02264"></a>02264         <span class="keywordflow">break</span>;
<a name="l02265"></a>02265     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>:
<a name="l02266"></a>02266         <span class="comment">/* Compare two integers */</span>
<a name="l02267"></a>02267         <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>) {
<a name="l02268"></a>02268 <span class="preprocessor">#if defined(P_TERM_64BIT)</span>
<a name="l02269"></a>02269 <span class="preprocessor"></span>            <span class="comment">/* Value is packed into the header, to save memory */</span>
<a name="l02270"></a>02270             <span class="keywordflow">return</span> term1-&gt;header.size == term2-&gt;header.size;
<a name="l02271"></a>02271 <span class="preprocessor">#else</span>
<a name="l02272"></a>02272 <span class="preprocessor"></span>            <span class="keywordflow">return</span> term1-&gt;integer.value == term2-&gt;integer.value;
<a name="l02273"></a>02273 <span class="preprocessor">#endif</span>
<a name="l02274"></a>02274 <span class="preprocessor"></span>        }
<a name="l02275"></a>02275         <span class="keywordflow">break</span>;
<a name="l02276"></a>02276     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>:
<a name="l02277"></a>02277         <span class="comment">/* Compare two reals */</span>
<a name="l02278"></a>02278         <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>)
<a name="l02279"></a>02279             <span class="keywordflow">return</span> term1-&gt;real.value == term2-&gt;real.value;
<a name="l02280"></a>02280         <span class="keywordflow">break</span>;
<a name="l02281"></a>02281     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>:
<a name="l02282"></a>02282     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l02283"></a>02283     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55badb8fcd6ce1379975862e21b90bf761c9">P_TERM_CLAUSE</a>:
<a name="l02284"></a>02284     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>:
<a name="l02285"></a>02285         <span class="comment">/* Objects and predicates can unify only if their</span>
<a name="l02286"></a>02286 <span class="comment">         * pointers are identical.  Identity has already been</span>
<a name="l02287"></a>02287 <span class="comment">         * checked, so fail */</span>
<a name="l02288"></a>02288         <span class="keywordflow">break</span>;
<a name="l02289"></a>02289     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l02290"></a>02290     }
<a name="l02291"></a>02291     <span class="keywordflow">return</span> 0;
<a name="l02292"></a>02292 }
<a name="l02293"></a>02293 
<a name="l02303"></a><a class="code" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5">02303</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gab4b9c1afcd3a2f29d451535f72dd71e5" title="Unifies term1 with term2 within context.">p_term_unify</a>(p_context *context, p_term *term1, p_term *term2, <span class="keywordtype">int</span> flags)
<a name="l02304"></a>02304 {
<a name="l02305"></a>02305     <span class="keywordtype">void</span> *marker = <a class="code" href="group__context.html#gac75be874ed6eb4ab5cded2f1146e9ff9" title="Marks the current position in the backtrack trail in context and returns a marker...">p_context_mark_trail</a>(context);
<a name="l02306"></a>02306     <span class="keywordtype">int</span> result = p_term_unify_inner(context, term1, term2, flags);
<a name="l02307"></a>02307     <span class="keywordflow">if</span> (!result &amp;&amp; (flags &amp; P_BIND_NO_RECORD) == 0)
<a name="l02308"></a>02308         <a class="code" href="group__context.html#gabec73eb41d877b21bb78c742d3b8afe2" title="Backtracks the trail in context, undoing variable bindings until marker is reached...">p_context_backtrack_trail</a>(context, marker);
<a name="l02309"></a>02309     <span class="keywordflow">return</span> result;
<a name="l02310"></a>02310 }
<a name="l02311"></a>02311 
<a name="l02330"></a><a class="code" href="group__term.html#ga44efb541f67a79075fb81f92e41b0e51">02330</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga44efb541f67a79075fb81f92e41b0e51" title="Prints formatted output according to format to the stdio FILE stream data.">p_term_stdio_print_func</a>(<span class="keywordtype">void</span> *data, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)
<a name="l02331"></a>02331 {
<a name="l02332"></a>02332     va_list va;
<a name="l02333"></a>02333     va_start(va, format);
<a name="l02334"></a>02334     vfprintf((FILE *)data, format, va);
<a name="l02335"></a>02335     va_end(va);
<a name="l02336"></a>02336 }
<a name="l02337"></a>02337 
<a name="l02338"></a>02338 <span class="comment">/* Limited dereference that avoids recursing too far */</span>
<a name="l02339"></a>02339 <span class="keyword">static</span> <span class="keyword">const</span> p_term *p_term_deref_limited(<span class="keyword">const</span> p_term *term)
<a name="l02340"></a>02340 {
<a name="l02341"></a>02341     <span class="keywordtype">int</span> count = 32;
<a name="l02342"></a>02342     <span class="keywordflow">if</span> (!term)
<a name="l02343"></a>02343         <span class="keywordflow">return</span> 0;
<a name="l02344"></a>02344     <span class="keywordflow">while</span> (count-- &gt; 0) {
<a name="l02345"></a>02345         <span class="keywordflow">if</span> (term-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>) {
<a name="l02346"></a>02346             <span class="keywordflow">if</span> (!term-&gt;var.value)
<a name="l02347"></a>02347                 <span class="keywordflow">break</span>;
<a name="l02348"></a>02348             term = term-&gt;var.value;
<a name="l02349"></a>02349         } <span class="keywordflow">else</span> {
<a name="l02350"></a>02350             <span class="keywordflow">break</span>;
<a name="l02351"></a>02351         }
<a name="l02352"></a>02352     }
<a name="l02353"></a>02353     <span class="keywordflow">return</span> term;
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="comment">/* Print a quoted atom or string */</span>
<a name="l02357"></a>02357 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_print_quoted(<span class="keyword">const</span> p_term *term, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data, <span class="keywordtype">int</span> quote)
<a name="l02358"></a>02358 {
<a name="l02359"></a>02359     <span class="keyword">const</span> <span class="keywordtype">char</span> *str = <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term);
<a name="l02360"></a>02360     <span class="keywordtype">size_t</span> len = <a class="code" href="group__term.html#ga55a861549e8b42db317a5acec3a7cefb" title="Returns the length of the name of the functor, predicate, atom, or variable contained...">p_term_name_length</a>(term);
<a name="l02361"></a>02361     <span class="keywordtype">int</span> ch;
<a name="l02362"></a>02362     (*print_func)(print_data, <span class="stringliteral">&quot;%c&quot;</span>, quote);
<a name="l02363"></a>02363     <span class="keywordflow">while</span> (len-- &gt; 0) {
<a name="l02364"></a>02364         ch = ((int)(*str++)) &amp; 0xFF;
<a name="l02365"></a>02365         <span class="keywordflow">if</span> (ch == quote || ch == <span class="charliteral">&apos;\\&apos;</span>)
<a name="l02366"></a>02366             (*print_func)(print_data, <span class="stringliteral">&quot;\\%c&quot;</span>, ch);
<a name="l02367"></a>02367         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt;= 0x20)
<a name="l02368"></a>02368             (*print_func)(print_data, <span class="stringliteral">&quot;%c&quot;</span>, ch);
<a name="l02369"></a>02369         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\t&apos;</span>)
<a name="l02370"></a>02370             (*print_func)(print_data, <span class="stringliteral">&quot;\\t&quot;</span>);
<a name="l02371"></a>02371         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\n&apos;</span>)
<a name="l02372"></a>02372             (*print_func)(print_data, <span class="stringliteral">&quot;\\n&quot;</span>);
<a name="l02373"></a>02373         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\r&apos;</span>)
<a name="l02374"></a>02374             (*print_func)(print_data, <span class="stringliteral">&quot;\\r&quot;</span>);
<a name="l02375"></a>02375         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\f&apos;</span>)
<a name="l02376"></a>02376             (*print_func)(print_data, <span class="stringliteral">&quot;\\f&quot;</span>);
<a name="l02377"></a>02377         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\v&apos;</span>)
<a name="l02378"></a>02378             (*print_func)(print_data, <span class="stringliteral">&quot;\\v&quot;</span>);
<a name="l02379"></a>02379         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&apos;\0&apos;</span>)
<a name="l02380"></a>02380             (*print_func)(print_data, <span class="stringliteral">&quot;\\0&quot;</span>);
<a name="l02381"></a>02381         <span class="keywordflow">else</span>
<a name="l02382"></a>02382             (*print_func)(print_data, <span class="stringliteral">&quot;\\x%02x&quot;</span>, ch);
<a name="l02383"></a>02383     }
<a name="l02384"></a>02384     (*print_func)(print_data, <span class="stringliteral">&quot;%c&quot;</span>, quote);
<a name="l02385"></a>02385 }
<a name="l02386"></a>02386 
<a name="l02387"></a>02387 <span class="comment">/* Print an atom name */</span>
<a name="l02388"></a>02388 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_print_atom(<span class="keyword">const</span> p_term *atom, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data)
<a name="l02389"></a>02389 {
<a name="l02390"></a>02390     <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(atom);
<a name="l02391"></a>02391     <span class="keywordtype">int</span> ok;
<a name="l02392"></a>02392     <span class="keywordflow">if</span> (!name)
<a name="l02393"></a>02393         <span class="keywordflow">return</span>;
<a name="l02394"></a>02394     <span class="keywordflow">if</span> (*name &gt;= <span class="charliteral">&apos;a&apos;</span> &amp;&amp; *name &lt;= <span class="charliteral">&apos;z&apos;</span>) {
<a name="l02395"></a>02395         ++name;
<a name="l02396"></a>02396         <span class="keywordflow">while</span> (*name != <span class="charliteral">&apos;\0&apos;</span>) {
<a name="l02397"></a>02397             <span class="keywordflow">if</span> (*name &gt;= <span class="charliteral">&apos;a&apos;</span> &amp;&amp; *name &lt;= <span class="charliteral">&apos;z&apos;</span>)
<a name="l02398"></a>02398                 ++name;
<a name="l02399"></a>02399             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name &gt;= <span class="charliteral">&apos;Z&apos;</span> &amp;&amp; *name &lt;= <span class="charliteral">&apos;Z&apos;</span>)
<a name="l02400"></a>02400                 ++name;
<a name="l02401"></a>02401             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name &gt;= <span class="charliteral">&apos;0&apos;</span> &amp;&amp; *name &lt;= <span class="charliteral">&apos;9&apos;</span>)
<a name="l02402"></a>02402                 ++name;
<a name="l02403"></a>02403             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">&apos;_&apos;</span>)
<a name="l02404"></a>02404                 ++name;
<a name="l02405"></a>02405             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">&apos;:&apos;</span> &amp;&amp; name[1] == <span class="charliteral">&apos;:&apos;</span>)
<a name="l02406"></a>02406                 name += 2;
<a name="l02407"></a>02407             <span class="keywordflow">else</span>
<a name="l02408"></a>02408                 <span class="keywordflow">break</span>;
<a name="l02409"></a>02409         }
<a name="l02410"></a>02410         ok = (name == (atom-&gt;atom.name + atom-&gt;header.size));
<a name="l02411"></a>02411     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*name == <span class="charliteral">&apos;[&apos;</span> &amp;&amp; name[1] == <span class="charliteral">&apos;]&apos;</span> &amp;&amp; name[2] == <span class="charliteral">&apos;\0&apos;</span> &amp;&amp;
<a name="l02412"></a>02412                atom-&gt;header.size == 2) {
<a name="l02413"></a>02413         ok = 1;
<a name="l02414"></a>02414     } <span class="keywordflow">else</span> {
<a name="l02415"></a>02415         ok = 0;
<a name="l02416"></a>02416     }
<a name="l02417"></a>02417     <span class="keywordflow">if</span> (ok)
<a name="l02418"></a>02418         (*print_func)(print_data, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(atom));
<a name="l02419"></a>02419     <span class="keywordflow">else</span>
<a name="l02420"></a>02420         p_term_print_quoted(atom, print_func, print_data, <span class="charliteral">&apos;\&apos;&apos;</span>);
<a name="l02421"></a>02421 }
<a name="l02422"></a>02422 
<a name="l02423"></a>02423 <span class="keyword">static</span> p_term *p_term_var_name(<span class="keyword">const</span> p_term *vars, <span class="keyword">const</span> p_term *var)
<a name="l02424"></a>02424 {
<a name="l02425"></a>02425     p_term *v;
<a name="l02426"></a>02426     vars = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(vars);
<a name="l02427"></a>02427     <span class="keywordflow">while</span> (vars &amp;&amp; vars-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>) {
<a name="l02428"></a>02428         v = <a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(vars-&gt;list.head, 1);
<a name="l02429"></a>02429         <span class="keywordflow">while</span> (v &amp;&amp; v != var) {
<a name="l02430"></a>02430             <span class="keywordflow">if</span> (v-&gt;header.type &amp; <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>)
<a name="l02431"></a>02431                 v = v-&gt;var.value;
<a name="l02432"></a>02432             <span class="keywordflow">else</span>
<a name="l02433"></a>02433                 <span class="keywordflow">break</span>;
<a name="l02434"></a>02434         }
<a name="l02435"></a>02435         <span class="keywordflow">if</span> (v == var) {
<a name="l02436"></a>02436             p_term *name = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(<a class="code" href="group__term.html#gafa650631563b752242f2026cbf7bbffb" title="Returns the argument at position index within the functor term, or null if term is...">p_term_arg</a>(vars-&gt;list.head, 0));
<a name="l02437"></a>02437             <span class="keywordflow">if</span> (name &amp;&amp; (name-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a> ||
<a name="l02438"></a>02438                          name-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>))
<a name="l02439"></a>02439                 <span class="keywordflow">return</span> name;
<a name="l02440"></a>02440             <span class="keywordflow">else</span>
<a name="l02441"></a>02441                 <span class="keywordflow">break</span>;
<a name="l02442"></a>02442         }
<a name="l02443"></a>02443         vars = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(vars-&gt;list.tail);
<a name="l02444"></a>02444     }
<a name="l02445"></a>02445     <span class="keywordflow">return</span> 0;
<a name="l02446"></a>02446 }
<a name="l02447"></a>02447 
<a name="l02448"></a>02448 <span class="keyword">static</span> <span class="keywordtype">void</span> p_term_print_inner(p_context *context, <span class="keyword">const</span> p_term *term, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> prec, <span class="keyword">const</span> p_term *vars)
<a name="l02449"></a>02449 {
<a name="l02450"></a>02450     <span class="comment">/* Bail out if we have exceeded the maximum recursion depth */</span>
<a name="l02451"></a>02451     <span class="keywordflow">if</span> (level &lt;= 0) {
<a name="l02452"></a>02452         (*print_func)(print_data, <span class="stringliteral">&quot;...&quot;</span>);
<a name="l02453"></a>02453         <span class="keywordflow">return</span>;
<a name="l02454"></a>02454     }
<a name="l02455"></a>02455 
<a name="l02456"></a>02456     <span class="comment">/* Bail out if the term is invalid */</span>
<a name="l02457"></a>02457     <span class="keywordflow">if</span> (!term) {
<a name="l02458"></a>02458         (*print_func)(print_data, <span class="stringliteral">&quot;NULL&quot;</span>);
<a name="l02459"></a>02459         <span class="keywordflow">return</span>;
<a name="l02460"></a>02460     }
<a name="l02461"></a>02461 
<a name="l02462"></a>02462     <span class="comment">/* Determine how to print this type of term */</span>
<a name="l02463"></a>02463     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l02464"></a>02464     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>: {
<a name="l02465"></a>02465         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02466"></a>02466         <a class="code" href="group__database.html#gacc700097b035c8c280d9ca83ddad1372">p_op_specifier</a> spec;
<a name="l02467"></a>02467         <span class="keywordtype">int</span> priority;
<a name="l02468"></a>02468         spec = <a class="code" href="group__database.html#gab80f7fac5dbef913542c4f45cb7e9b8f" title="Retrieves the operator details for the atom name and the specified arity (1 or 2)...">p_db_operator_info</a>
<a name="l02469"></a>02469             (term-&gt;functor.functor_name,
<a name="l02470"></a>02470              (<span class="keywordtype">int</span>)(term-&gt;header.size), &amp;priority);
<a name="l02471"></a>02471         <span class="keywordflow">if</span> (spec == <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a7f864b210c4f813b4a7dcab2dadd3acc">P_OP_NONE</a>) {
<a name="l02472"></a>02472             p_term_print_atom(term-&gt;functor.functor_name,
<a name="l02473"></a>02473                               print_func, print_data);
<a name="l02474"></a>02474             (*print_func)(print_data, <span class="stringliteral">&quot;(&quot;</span>);
<a name="l02475"></a>02475             <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l02476"></a>02476                 <span class="keywordflow">if</span> (index)
<a name="l02477"></a>02477                     (*print_func)(print_data, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l02478"></a>02478                 p_term_print_inner
<a name="l02479"></a>02479                     (context, term-&gt;functor.arg[index],
<a name="l02480"></a>02480                      print_func, print_data, level - 1, 950, vars);
<a name="l02481"></a>02481             }
<a name="l02482"></a>02482             (*print_func)(print_data, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l02483"></a>02483         } <span class="keywordflow">else</span> {
<a name="l02484"></a>02484             <span class="keywordtype">int</span> bracketed = (priority &gt; prec);
<a name="l02485"></a>02485             <span class="keywordflow">if</span> (bracketed) {
<a name="l02486"></a>02486                 (*print_func)(print_data, <span class="stringliteral">&quot;(&quot;</span>);
<a name="l02487"></a>02487                 priority = 1300;
<a name="l02488"></a>02488             }
<a name="l02489"></a>02489             <span class="keywordflow">switch</span> (spec) {
<a name="l02490"></a>02490             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a7f864b210c4f813b4a7dcab2dadd3acc">P_OP_NONE</a>: <span class="keywordflow">break</span>;
<a name="l02491"></a>02491             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a2cce64f989a77cd061895dc50eb025c2">P_OP_XF</a>:
<a name="l02492"></a>02492                 p_term_print_inner
<a name="l02493"></a>02493                     (context, term-&gt;functor.arg[0],
<a name="l02494"></a>02494                      print_func, print_data, level - 1,
<a name="l02495"></a>02495                      priority - 1, vars);
<a name="l02496"></a>02496                 (*print_func)(print_data, <span class="stringliteral">&quot; %s&quot;</span>,
<a name="l02497"></a>02497                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02498"></a>02498                 <span class="keywordflow">break</span>;
<a name="l02499"></a>02499             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372acd2ea9f7f33d5559245d58d31ae6b16b">P_OP_YF</a>:
<a name="l02500"></a>02500                 p_term_print_inner
<a name="l02501"></a>02501                     (context, term-&gt;functor.arg[0],
<a name="l02502"></a>02502                      print_func, print_data, level - 1, priority, vars);
<a name="l02503"></a>02503                 (*print_func)(print_data, <span class="stringliteral">&quot; %s&quot;</span>,
<a name="l02504"></a>02504                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02505"></a>02505                 <span class="keywordflow">break</span>;
<a name="l02506"></a>02506             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372ab229cf9d13f631bb804a32ccf5c66b6f">P_OP_XFX</a>:
<a name="l02507"></a>02507                 p_term_print_inner
<a name="l02508"></a>02508                     (context, term-&gt;functor.arg[0],
<a name="l02509"></a>02509                      print_func, print_data, level - 1,
<a name="l02510"></a>02510                      priority - 1, vars);
<a name="l02511"></a>02511                 (*print_func)(print_data, <span class="stringliteral">&quot; %s &quot;</span>,
<a name="l02512"></a>02512                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02513"></a>02513                 p_term_print_inner
<a name="l02514"></a>02514                     (context, term-&gt;functor.arg[1],
<a name="l02515"></a>02515                      print_func, print_data, level - 1,
<a name="l02516"></a>02516                      priority - 1, vars);
<a name="l02517"></a>02517                 <span class="keywordflow">break</span>;
<a name="l02518"></a>02518             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a25019266b1433a52c4548504204b9160">P_OP_XFY</a>:
<a name="l02519"></a>02519                 p_term_print_inner
<a name="l02520"></a>02520                     (context, term-&gt;functor.arg[0],
<a name="l02521"></a>02521                      print_func, print_data, level - 1,
<a name="l02522"></a>02522                      priority - 1, vars);
<a name="l02523"></a>02523                 (*print_func)(print_data, <span class="stringliteral">&quot; %s &quot;</span>,
<a name="l02524"></a>02524                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02525"></a>02525                 p_term_print_inner
<a name="l02526"></a>02526                     (context, term-&gt;functor.arg[1],
<a name="l02527"></a>02527                      print_func, print_data, level - 1,
<a name="l02528"></a>02528                      priority, vars);
<a name="l02529"></a>02529                 <span class="keywordflow">break</span>;
<a name="l02530"></a>02530             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a968f64ef2f425b10a2a85a40d99827c0">P_OP_YFX</a>:
<a name="l02531"></a>02531                 p_term_print_inner
<a name="l02532"></a>02532                     (context, term-&gt;functor.arg[0],
<a name="l02533"></a>02533                      print_func, print_data, level - 1, priority, vars);
<a name="l02534"></a>02534                 (*print_func)(print_data, <span class="stringliteral">&quot; %s &quot;</span>,
<a name="l02535"></a>02535                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02536"></a>02536                 p_term_print_inner
<a name="l02537"></a>02537                     (context, term-&gt;functor.arg[1],
<a name="l02538"></a>02538                      print_func, print_data, level - 1,
<a name="l02539"></a>02539                      priority - 1, vars);
<a name="l02540"></a>02540                 <span class="keywordflow">break</span>;
<a name="l02541"></a>02541             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a066e817d3c62efb458ba8f80ef00ef71">P_OP_FX</a>:
<a name="l02542"></a>02542                 (*print_func)(print_data, <span class="stringliteral">&quot;%s &quot;</span>,
<a name="l02543"></a>02543                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02544"></a>02544                 p_term_print_inner
<a name="l02545"></a>02545                     (context, term-&gt;functor.arg[0],
<a name="l02546"></a>02546                      print_func, print_data, level - 1,
<a name="l02547"></a>02547                      priority - 1, vars);
<a name="l02548"></a>02548                 <span class="keywordflow">break</span>;
<a name="l02549"></a>02549             <span class="keywordflow">case</span> <a class="code" href="group__database.html#ggacc700097b035c8c280d9ca83ddad1372a33af89ed55a5d17526739c62a8b7c4e2">P_OP_FY</a>:
<a name="l02550"></a>02550                 (*print_func)(print_data, <span class="stringliteral">&quot;%s &quot;</span>,
<a name="l02551"></a>02551                               <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term-&gt;functor.functor_name));
<a name="l02552"></a>02552                 p_term_print_inner
<a name="l02553"></a>02553                     (context, term-&gt;functor.arg[0],
<a name="l02554"></a>02554                      print_func, print_data, level - 1, priority, vars);
<a name="l02555"></a>02555                 <span class="keywordflow">break</span>;
<a name="l02556"></a>02556             }
<a name="l02557"></a>02557             <span class="keywordflow">if</span> (bracketed)
<a name="l02558"></a>02558                 (*print_func)(print_data, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l02559"></a>02559         }
<a name="l02560"></a>02560         <span class="keywordflow">break</span>; }
<a name="l02561"></a>02561     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>:
<a name="l02562"></a>02562         (*print_func)(print_data, <span class="stringliteral">&quot;[&quot;</span>);
<a name="l02563"></a>02563         p_term_print_inner(context, term-&gt;list.head,
<a name="l02564"></a>02564                            print_func, print_data,
<a name="l02565"></a>02565                            level - 1, 950, vars);
<a name="l02566"></a>02566         term = p_term_deref_limited(term-&gt;list.tail);
<a name="l02567"></a>02567         <span class="keywordflow">while</span> (term &amp;&amp; term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a> &amp;&amp; level &gt; 0) {
<a name="l02568"></a>02568             (*print_func)(print_data, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l02569"></a>02569             p_term_print_inner(context, term-&gt;list.head,
<a name="l02570"></a>02570                                print_func, print_data,
<a name="l02571"></a>02571                                level - 1, 950, vars);
<a name="l02572"></a>02572             term = p_term_deref_limited(term-&gt;list.tail);
<a name="l02573"></a>02573             --level;
<a name="l02574"></a>02574         }
<a name="l02575"></a>02575         <span class="keywordflow">if</span> (level &lt;= 0) {
<a name="l02576"></a>02576             (*print_func)(print_data, <span class="stringliteral">&quot;|...]&quot;</span>);
<a name="l02577"></a>02577             <span class="keywordflow">break</span>;
<a name="l02578"></a>02578         }
<a name="l02579"></a>02579         <span class="keywordflow">if</span> (term != context-&gt;nil_atom) {
<a name="l02580"></a>02580             (*print_func)(print_data, <span class="stringliteral">&quot;|&quot;</span>);
<a name="l02581"></a>02581             p_term_print_inner(context, term, print_func,
<a name="l02582"></a>02582                                print_data, level - 1, 950, vars);
<a name="l02583"></a>02583         }
<a name="l02584"></a>02584         (*print_func)(print_data, <span class="stringliteral">&quot;]&quot;</span>);
<a name="l02585"></a>02585         <span class="keywordflow">break</span>;
<a name="l02586"></a>02586     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l02587"></a>02587         p_term_print_atom(term, print_func, print_data);
<a name="l02588"></a>02588         <span class="keywordflow">break</span>;
<a name="l02589"></a>02589     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l02590"></a>02590         p_term_print_quoted(term, print_func, print_data, <span class="charliteral">&apos;&quot;&apos;</span>);
<a name="l02591"></a>02591         <span class="keywordflow">break</span>;
<a name="l02592"></a>02592     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>:
<a name="l02593"></a>02593         (*print_func)(print_data, <span class="stringliteral">&quot;%d&quot;</span>, <a class="code" href="group__term.html#ga78f1318137be1b1714f7c51f61fe139c" title="Returns the 32-bit signed integer value within term, or zero if term is not an integer...">p_term_integer_value</a>(term));
<a name="l02594"></a>02594         <span class="keywordflow">break</span>;
<a name="l02595"></a>02595     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>:
<a name="l02596"></a>02596         (*print_func)(print_data, <span class="stringliteral">&quot;%.10g&quot;</span>, <a class="code" href="group__term.html#ga995e38a5ad30ed0cb8b0c4e30028d39d" title="Returns the double-precision floating point value within term, or zero if term is...">p_term_real_value</a>(term));
<a name="l02597"></a>02597         <span class="keywordflow">break</span>;
<a name="l02598"></a>02598     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>: {
<a name="l02599"></a>02599         p_term *name = <a class="code" href="group__term.html#gad505c00c9f70ad0429f87fc58a189b73" title="Returns the value associated with the property name on term within context, or null...">p_term_property</a>
<a name="l02600"></a>02600             (context, term, context-&gt;class_name_atom);
<a name="l02601"></a>02601         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02602"></a>02602         <span class="keywordtype">int</span> first = 1;
<a name="l02603"></a>02603         <span class="keywordflow">if</span> (<a class="code" href="group__term.html#ga93b370531936bcd03ebb61cb17f884de" title="Returns non-zero if term is a class object within context, zero otherwise.">p_term_is_class_object</a>(context, term))
<a name="l02604"></a>02604             (*print_func)(print_data, <span class="stringliteral">&quot;class &quot;</span>);
<a name="l02605"></a>02605         <span class="keywordflow">if</span> (name)
<a name="l02606"></a>02606             (*print_func)(print_data, <span class="stringliteral">&quot;%s {&quot;</span>, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(name));
<a name="l02607"></a>02607         <span class="keywordflow">else</span>
<a name="l02608"></a>02608             (*print_func)(print_data, <span class="stringliteral">&quot;unknown_class {&quot;</span>);
<a name="l02609"></a>02609         <span class="keywordflow">do</span> {
<a name="l02610"></a>02610             <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l02611"></a>02611                 name = term-&gt;object.properties[index].name;
<a name="l02612"></a>02612                 <span class="keywordflow">if</span> (name == context-&gt;class_name_atom)
<a name="l02613"></a>02613                     <span class="keywordflow">continue</span>;
<a name="l02614"></a>02614                 <span class="keywordflow">if</span> (name == context-&gt;prototype_atom)
<a name="l02615"></a>02615                     <span class="keywordflow">continue</span>;
<a name="l02616"></a>02616                 <span class="keywordflow">if</span> (!first)
<a name="l02617"></a>02617                     (*print_func)(print_data, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l02618"></a>02618                 p_term_print_atom(name, print_func, print_data);
<a name="l02619"></a>02619                 (*print_func)(print_data, <span class="stringliteral">&quot;: &quot;</span>);
<a name="l02620"></a>02620                 p_term_print_inner
<a name="l02621"></a>02621                     (context, term-&gt;object.properties[index].value,
<a name="l02622"></a>02622                      print_func, print_data, level - 1, 950, vars);
<a name="l02623"></a>02623                 first = 0;
<a name="l02624"></a>02624             }
<a name="l02625"></a>02625             term = term-&gt;object.next;
<a name="l02626"></a>02626         } <span class="keywordflow">while</span> (term != 0);
<a name="l02627"></a>02627         (*print_func)(print_data, <span class="stringliteral">&quot;}&quot;</span>);
<a name="l02628"></a>02628         <span class="keywordflow">break</span>; }
<a name="l02629"></a>02629     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l02630"></a>02630         (*print_func)(print_data, <span class="stringliteral">&quot;predicate &quot;</span>);
<a name="l02631"></a>02631         p_term_print_atom(term-&gt;predicate.name, print_func, print_data);
<a name="l02632"></a>02632         (*print_func)(print_data, <span class="stringliteral">&quot;/%d&quot;</span>, (int)(term-&gt;header.size));
<a name="l02633"></a>02633         <span class="keywordflow">break</span>;
<a name="l02634"></a>02634     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55badb8fcd6ce1379975862e21b90bf761c9">P_TERM_CLAUSE</a>:
<a name="l02635"></a>02635         (*print_func)(print_data, <span class="stringliteral">&quot;clause %lx&quot;</span>, (long)term);
<a name="l02636"></a>02636         <span class="keywordflow">break</span>;
<a name="l02637"></a>02637     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>:
<a name="l02638"></a>02638         (*print_func)(print_data, <span class="stringliteral">&quot;database %lx&quot;</span>, (long)term);
<a name="l02639"></a>02639         <span class="keywordflow">break</span>;
<a name="l02640"></a>02640     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>: {
<a name="l02641"></a>02641         <span class="keywordflow">if</span> (term-&gt;var.value) {
<a name="l02642"></a>02642             p_term_print_inner(context, term-&gt;var.value, print_func,
<a name="l02643"></a>02643                                print_data, level - 1, prec, vars);
<a name="l02644"></a>02644         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vars) {
<a name="l02645"></a>02645             p_term *name = p_term_var_name(vars, term);
<a name="l02646"></a>02646             <span class="keywordflow">if</span> (name)
<a name="l02647"></a>02647                 (*print_func)(print_data, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(name));
<a name="l02648"></a>02648             <span class="keywordflow">else</span>
<a name="l02649"></a>02649                 (*print_func)(print_data, <span class="stringliteral">&quot;_%lx&quot;</span>, (long)term);
<a name="l02650"></a>02650         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;header.size &gt; 0) {
<a name="l02651"></a>02651             (*print_func)(print_data, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term));
<a name="l02652"></a>02652         } <span class="keywordflow">else</span> {
<a name="l02653"></a>02653             (*print_func)(print_data, <span class="stringliteral">&quot;_%lx&quot;</span>, (long)term);
<a name="l02654"></a>02654         }
<a name="l02655"></a>02655         <span class="keywordflow">break</span>; }
<a name="l02656"></a>02656     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l02657"></a>02657         <span class="keywordflow">if</span> (term-&gt;var.value) {
<a name="l02658"></a>02658             p_term_print_inner(context, term-&gt;var.value, print_func,
<a name="l02659"></a>02659                                print_data, level - 1, prec, vars);
<a name="l02660"></a>02660             <span class="keywordflow">break</span>;
<a name="l02661"></a>02661         }
<a name="l02662"></a>02662         p_term_print_inner(context, term-&gt;member_var.object, print_func,
<a name="l02663"></a>02663                            print_data, level - 1, 0, vars);
<a name="l02664"></a>02664         (*print_func)(print_data, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l02665"></a>02665         p_term_print_atom(term-&gt;member_var.name, print_func, print_data);
<a name="l02666"></a>02666         <span class="keywordflow">break</span>;
<a name="l02667"></a>02667     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l02668"></a>02668     }
<a name="l02669"></a>02669 }
<a name="l02670"></a>02670 
<a name="l02682"></a><a class="code" href="group__term.html#gae99be6acb41d73b3193125d854dde48b">02682</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#gae99be6acb41d73b3193125d854dde48b" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print</a>(p_context *context, <span class="keyword">const</span> p_term *term, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data)
<a name="l02683"></a>02683 {
<a name="l02684"></a>02684     p_term_print_inner(context, term, print_func, print_data, 1000, 1300, 0);
<a name="l02685"></a>02685 }
<a name="l02686"></a>02686 
<a name="l02701"></a><a class="code" href="group__term.html#gab2dee2140281b77c3ef3d435ae8b4b49">02701</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#gab2dee2140281b77c3ef3d435ae8b4b49" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_unquoted</a>(p_context *context, <span class="keyword">const</span> p_term *term, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data)
<a name="l02702"></a>02702 {
<a name="l02703"></a>02703     term = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(term);
<a name="l02704"></a>02704     <span class="keywordflow">if</span> (term) {
<a name="l02705"></a>02705         <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a> ||
<a name="l02706"></a>02706                 term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>) {
<a name="l02707"></a>02707             (*print_func)(print_data, <span class="stringliteral">&quot;%s&quot;</span>, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term));
<a name="l02708"></a>02708             <span class="keywordflow">return</span>;
<a name="l02709"></a>02709         }
<a name="l02710"></a>02710     }
<a name="l02711"></a>02711     p_term_print_inner(context, term, print_func, print_data, 1000, 1300, 0);
<a name="l02712"></a>02712 }
<a name="l02713"></a>02713 
<a name="l02726"></a><a class="code" href="group__term.html#ga700e9de8d736a8e0c1db26cbdba86db5">02726</a> <span class="keywordtype">void</span> <a class="code" href="group__term.html#ga700e9de8d736a8e0c1db26cbdba86db5" title="Prints term within context to the output stream defined by print_func and print_data...">p_term_print_with_vars</a>(p_context *context, <span class="keyword">const</span> p_term *term, <a class="code" href="group__term.html#ga83679468f179f7dfbaf22d781e855a7f">p_term_print_func</a> print_func, <span class="keywordtype">void</span> *print_data, <span class="keyword">const</span> p_term *vars)
<a name="l02727"></a>02727 {
<a name="l02728"></a>02728     <span class="keywordflow">if</span> (!vars)
<a name="l02729"></a>02729         vars = <a class="code" href="group__term.html#gacdd67ab1558d9c6756170fc550bb873c" title="Returns the special &amp;quot;nil&amp;quot; atom that represents the empty list within context...">p_term_nil_atom</a>(context);
<a name="l02730"></a>02730     p_term_print_inner(context, term, print_func, print_data, 1000, 1300, vars);
<a name="l02731"></a>02731 }
<a name="l02732"></a>02732 
<a name="l02751"></a><a class="code" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac">02751</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac" title="Returns -1, 0, or 1 depending upon whether term1 is less than, equal to, or greater...">p_term_precedes</a>(p_context *context, <span class="keyword">const</span> p_term *term1, <span class="keyword">const</span> p_term *term2)
<a name="l02752"></a>02752 {
<a name="l02753"></a>02753     <span class="keywordtype">int</span> group1, group2, cmp;
<a name="l02754"></a>02754     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keyword">const</span> precedes_ordering[] = {
<a name="l02755"></a>02755         0,  <span class="comment">/*  0: P_TERM_INVALID */</span>
<a name="l02756"></a>02756         6,  <span class="comment">/*  1: P_TERM_FUNCTOR */</span>
<a name="l02757"></a>02757         6,  <span class="comment">/*  2: P_TERM_LIST */</span>
<a name="l02758"></a>02758         5,  <span class="comment">/*  3: P_TERM_ATOM */</span>
<a name="l02759"></a>02759         4,  <span class="comment">/*  4: P_TERM_STRING */</span>
<a name="l02760"></a>02760         3,  <span class="comment">/*  5: P_TERM_INTEGER */</span>
<a name="l02761"></a>02761         2,  <span class="comment">/*  6: P_TERM_REAL */</span>
<a name="l02762"></a>02762         7,  <span class="comment">/*  7: P_TERM_OBJECT */</span>
<a name="l02763"></a>02763         8,  <span class="comment">/*  8: P_TERM_PREDICATE */</span>
<a name="l02764"></a>02764         9,  <span class="comment">/*  9: P_TERM_CLAUSE */</span>
<a name="l02765"></a>02765         10, <span class="comment">/* 10: P_TERM_DATABASE */</span>
<a name="l02766"></a>02766         0, 0, 0, 0, 0,
<a name="l02767"></a>02767         1,  <span class="comment">/* 16: P_TERM_VARIABLE */</span>
<a name="l02768"></a>02768         1   <span class="comment">/* 17: P_TERM_MEMBER_VARIABLE */</span>
<a name="l02769"></a>02769     };
<a name="l02770"></a>02770 
<a name="l02771"></a>02771     <span class="comment">/* Dereference the terms */</span>
<a name="l02772"></a>02772     <span class="keywordflow">if</span> (!term1)
<a name="l02773"></a>02773         <span class="keywordflow">return</span> term2 ? -1 : 0;
<a name="l02774"></a>02774     <span class="keywordflow">if</span> (!term2)
<a name="l02775"></a>02775         <span class="keywordflow">return</span> 1;
<a name="l02776"></a>02776     term1 = p_term_deref_non_null(term1);
<a name="l02777"></a>02777     term2 = p_term_deref_non_null(term2);
<a name="l02778"></a>02778     <span class="keywordflow">if</span> (term1 == term2)
<a name="l02779"></a>02779         <span class="keywordflow">return</span> 0;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781     <span class="comment">/* Determine which groups the terms fall within */</span>
<a name="l02782"></a>02782     group1 = precedes_ordering[term1-&gt;header.type];
<a name="l02783"></a>02783     group2 = precedes_ordering[term2-&gt;header.type];
<a name="l02784"></a>02784     <span class="keywordflow">if</span> (group1 &lt; group2)
<a name="l02785"></a>02785         <span class="keywordflow">return</span> -1;
<a name="l02786"></a>02786     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group1 &gt; group2)
<a name="l02787"></a>02787         <span class="keywordflow">return</span> 1;
<a name="l02788"></a>02788 
<a name="l02789"></a>02789     <span class="comment">/* Compare based on the term type */</span>
<a name="l02790"></a>02790     <span class="keywordflow">switch</span> (term1-&gt;header.type) {
<a name="l02791"></a>02791     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l02792"></a>02792     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>: {
<a name="l02793"></a>02793         p_term *name1;
<a name="l02794"></a>02794         p_term *name2;
<a name="l02795"></a>02795         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02796"></a>02796         <span class="keywordflow">if</span> (term1-&gt;header.size &lt; term2-&gt;header.size)
<a name="l02797"></a>02797             <span class="keywordflow">return</span> -1;
<a name="l02798"></a>02798         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term1-&gt;header.size &gt; term2-&gt;header.size)
<a name="l02799"></a>02799             <span class="keywordflow">return</span> 1;
<a name="l02800"></a>02800         <span class="keywordflow">if</span> (term1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>)
<a name="l02801"></a>02801             name1 = term1-&gt;functor.functor_name;
<a name="l02802"></a>02802         <span class="keywordflow">else</span>
<a name="l02803"></a>02803             name1 = context-&gt;dot_atom;
<a name="l02804"></a>02804         <span class="keywordflow">if</span> (term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>)
<a name="l02805"></a>02805             name2 = term2-&gt;functor.functor_name;
<a name="l02806"></a>02806         <span class="keywordflow">else</span>
<a name="l02807"></a>02807             name2 = context-&gt;dot_atom;
<a name="l02808"></a>02808         cmp = <a class="code" href="group__term.html#gac5ab644da0bd5f5d69d73721e38a838a" title="Compares str1 and str2 and returns a comparison code.">p_term_strcmp</a>(name1, name2);
<a name="l02809"></a>02809         <span class="keywordflow">if</span> (cmp &lt; 0)
<a name="l02810"></a>02810             <span class="keywordflow">return</span> -1;
<a name="l02811"></a>02811         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp &gt; 0)
<a name="l02812"></a>02812             <span class="keywordflow">return</span> 1;
<a name="l02813"></a>02813         <span class="keywordflow">if</span> (term1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> &amp;&amp;
<a name="l02814"></a>02814                 term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>) {
<a name="l02815"></a>02815             <span class="keywordflow">for</span> (index = 0; index &lt; term1-&gt;header.size; ++index) {
<a name="l02816"></a>02816                 cmp = <a class="code" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac" title="Returns -1, 0, or 1 depending upon whether term1 is less than, equal to, or greater...">p_term_precedes</a>(context,
<a name="l02817"></a>02817                                       term1-&gt;functor.arg[index],
<a name="l02818"></a>02818                                       term2-&gt;functor.arg[index]);
<a name="l02819"></a>02819                 <span class="keywordflow">if</span> (cmp != 0)
<a name="l02820"></a>02820                     <span class="keywordflow">return</span> cmp;
<a name="l02821"></a>02821             }
<a name="l02822"></a>02822         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a> &amp;&amp;
<a name="l02823"></a>02823                    term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>) {
<a name="l02824"></a>02824             <span class="keywordflow">do</span> {
<a name="l02825"></a>02825                 cmp = <a class="code" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac" title="Returns -1, 0, or 1 depending upon whether term1 is less than, equal to, or greater...">p_term_precedes</a>
<a name="l02826"></a>02826                     (context, term1-&gt;list.head, term2-&gt;list.head);
<a name="l02827"></a>02827                 <span class="keywordflow">if</span> (cmp != 0)
<a name="l02828"></a>02828                     <span class="keywordflow">return</span> cmp;
<a name="l02829"></a>02829                 term1 = term1-&gt;list.tail;
<a name="l02830"></a>02830                 term2 = term2-&gt;list.tail;
<a name="l02831"></a>02831                 <span class="keywordflow">if</span> (!term1 || !term2)
<a name="l02832"></a>02832                     <span class="keywordflow">break</span>;
<a name="l02833"></a>02833                 term1 = p_term_deref_non_null(term1);
<a name="l02834"></a>02834                 term2 = p_term_deref_non_null(term2);
<a name="l02835"></a>02835             } <span class="keywordflow">while</span> (term1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a> &amp;&amp;
<a name="l02836"></a>02836                      term2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>);
<a name="l02837"></a>02837             <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga6e764c6ab93287ce3a163b2947ca7cac" title="Returns -1, 0, or 1 depending upon whether term1 is less than, equal to, or greater...">p_term_precedes</a>(context, term1, term2);
<a name="l02838"></a>02838         } <span class="keywordflow">else</span> {
<a name="l02839"></a>02839             <span class="comment">/* Shouldn&apos;t get here, because parsers will normally</span>
<a name="l02840"></a>02840 <span class="comment">             * convert &apos;.&apos; functors into list terms.  Have to do</span>
<a name="l02841"></a>02841 <span class="comment">             * something, so order the terms on pointer */</span>
<a name="l02842"></a>02842             <span class="keywordflow">return</span> (term1 &lt; term2) ? -1 : 1;
<a name="l02843"></a>02843         }
<a name="l02844"></a>02844         <span class="keywordflow">break</span>; }
<a name="l02845"></a>02845     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l02846"></a>02846     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l02847"></a>02847         cmp = <a class="code" href="group__term.html#gac5ab644da0bd5f5d69d73721e38a838a" title="Compares str1 and str2 and returns a comparison code.">p_term_strcmp</a>(term1, term2);
<a name="l02848"></a>02848         <span class="keywordflow">if</span> (cmp &lt; 0)
<a name="l02849"></a>02849             <span class="keywordflow">return</span> -1;
<a name="l02850"></a>02850         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp &gt; 0)
<a name="l02851"></a>02851             <span class="keywordflow">return</span> 1;
<a name="l02852"></a>02852         <span class="keywordflow">break</span>;
<a name="l02853"></a>02853     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>:
<a name="l02854"></a>02854 <span class="preprocessor">#if defined(P_TERM_64BIT)</span>
<a name="l02855"></a>02855 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)(term1-&gt;header.size)) &lt; ((<span class="keywordtype">int</span>)(term2-&gt;header.size)))
<a name="l02856"></a>02856             <span class="keywordflow">return</span> -1;
<a name="l02857"></a>02857         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)(term1-&gt;header.size)) &gt; ((<span class="keywordtype">int</span>)(term2-&gt;header.size)))
<a name="l02858"></a>02858             <span class="keywordflow">return</span> 1;
<a name="l02859"></a>02859 <span class="preprocessor">#else</span>
<a name="l02860"></a>02860 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (term1-&gt;integer.value &lt; term2-&gt;integer.value)
<a name="l02861"></a>02861             <span class="keywordflow">return</span> -1;
<a name="l02862"></a>02862         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term1-&gt;integer.value &gt; term2-&gt;integer.value)
<a name="l02863"></a>02863             <span class="keywordflow">return</span> 1;
<a name="l02864"></a>02864 <span class="preprocessor">#endif</span>
<a name="l02865"></a>02865 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l02866"></a>02866     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>:
<a name="l02867"></a>02867         <span class="keywordflow">if</span> (term1-&gt;real.value &lt; term2-&gt;real.value)
<a name="l02868"></a>02868             <span class="keywordflow">return</span> -1;
<a name="l02869"></a>02869         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term1-&gt;real.value &gt; term2-&gt;real.value)
<a name="l02870"></a>02870             <span class="keywordflow">return</span> 1;
<a name="l02871"></a>02871         <span class="keywordflow">break</span>;
<a name="l02872"></a>02872     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>:
<a name="l02873"></a>02873     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l02874"></a>02874     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55badb8fcd6ce1379975862e21b90bf761c9">P_TERM_CLAUSE</a>:
<a name="l02875"></a>02875     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>:
<a name="l02876"></a>02876     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l02877"></a>02877     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l02878"></a>02878         <span class="keywordflow">return</span> (term1 &lt; term2) ? -1 : 1;
<a name="l02879"></a>02879     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l02880"></a>02880     }
<a name="l02881"></a>02881     <span class="keywordflow">return</span> 0;
<a name="l02882"></a>02882 }
<a name="l02883"></a>02883 
<a name="l02893"></a><a class="code" href="group__term.html#ga473a01257325779b7a0f33deea809325">02893</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#ga473a01257325779b7a0f33deea809325" title="Returns non-zero if term is a ground term without any unbound variables; zero otherwise...">p_term_is_ground</a>(<span class="keyword">const</span> p_term *term)
<a name="l02894"></a>02894 {
<a name="l02895"></a>02895     <span class="keywordflow">if</span> (!term)
<a name="l02896"></a>02896         <span class="keywordflow">return</span> 0;
<a name="l02897"></a>02897     term = p_term_deref_non_null(term);
<a name="l02898"></a>02898     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l02899"></a>02899     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>: {
<a name="l02900"></a>02900         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02901"></a>02901         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l02902"></a>02902             <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#ga473a01257325779b7a0f33deea809325" title="Returns non-zero if term is a ground term without any unbound variables; zero otherwise...">p_term_is_ground</a>(term-&gt;functor.arg[index]))
<a name="l02903"></a>02903                 <span class="keywordflow">return</span> 0;
<a name="l02904"></a>02904         }
<a name="l02905"></a>02905         <span class="keywordflow">return</span> 1; }
<a name="l02906"></a>02906     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>:
<a name="l02907"></a>02907         <span class="keywordflow">do</span> {
<a name="l02908"></a>02908             <span class="keywordflow">if</span> (!<a class="code" href="group__term.html#ga473a01257325779b7a0f33deea809325" title="Returns non-zero if term is a ground term without any unbound variables; zero otherwise...">p_term_is_ground</a>(term-&gt;list.head))
<a name="l02909"></a>02909                 <span class="keywordflow">return</span> 0;
<a name="l02910"></a>02910             term = term-&gt;list.tail;
<a name="l02911"></a>02911             <span class="keywordflow">if</span> (!term)
<a name="l02912"></a>02912                 <span class="keywordflow">return</span> 0;
<a name="l02913"></a>02913             term = p_term_deref_non_null(term);
<a name="l02914"></a>02914         }
<a name="l02915"></a>02915         <span class="keywordflow">while</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>);
<a name="l02916"></a>02916         <span class="keywordflow">return</span> <a class="code" href="group__term.html#ga473a01257325779b7a0f33deea809325" title="Returns non-zero if term is a ground term without any unbound variables; zero otherwise...">p_term_is_ground</a>(term);
<a name="l02917"></a>02917     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l02918"></a>02918     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l02919"></a>02919     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>:
<a name="l02920"></a>02920     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>:
<a name="l02921"></a>02921     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>:
<a name="l02922"></a>02922     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l02923"></a>02923     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55badb8fcd6ce1379975862e21b90bf761c9">P_TERM_CLAUSE</a>:
<a name="l02924"></a>02924     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>:
<a name="l02925"></a>02925         <span class="keywordflow">return</span> 1;
<a name="l02926"></a>02926     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l02927"></a>02927     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l02928"></a>02928     <span class="keywordflow">case</span> P_TERM_RENAME:
<a name="l02929"></a>02929         <span class="keywordflow">return</span> 0;
<a name="l02930"></a>02930     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l02931"></a>02931     }
<a name="l02932"></a>02932     <span class="keywordflow">return</span> 0;
<a name="l02933"></a>02933 }
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="keyword">static</span> p_term *p_term_clone_inner(p_context *context, p_term *term)
<a name="l02936"></a>02936 {
<a name="l02937"></a>02937     p_term *clone;
<a name="l02938"></a>02938     p_term *rename;
<a name="l02939"></a>02939     <span class="keywordflow">if</span> (!term)
<a name="l02940"></a>02940         <span class="keywordflow">return</span> 0;
<a name="l02941"></a>02941     term = p_term_deref_non_null(term);
<a name="l02942"></a>02942     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l02943"></a>02943     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>: {
<a name="l02944"></a>02944         <span class="comment">/* Clone a functor term */</span>
<a name="l02945"></a>02945         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l02946"></a>02946         clone = <a class="code" href="group__term.html#gaa2369f8488b027efed7a0aa7e8da73a7" title="Creates a functor term within ontext with the specified name and arg_count. Returns...">p_term_create_functor</a>
<a name="l02947"></a>02947             (context, term-&gt;functor.functor_name,
<a name="l02948"></a>02948              (<span class="keywordtype">int</span>)(term-&gt;header.size));
<a name="l02949"></a>02949         <span class="keywordflow">if</span> (!clone)
<a name="l02950"></a>02950             <span class="keywordflow">return</span> 0;
<a name="l02951"></a>02951         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l02952"></a>02952             p_term *arg = p_term_clone_inner
<a name="l02953"></a>02953                 (context, term-&gt;functor.arg[index]);
<a name="l02954"></a>02954             <span class="keywordflow">if</span> (!arg)
<a name="l02955"></a>02955                 <span class="keywordflow">return</span> 0;
<a name="l02956"></a>02956             <a class="code" href="group__term.html#gabb4aa77bf08b8bc3d0ef94442a017c2a" title="Binds the argument at index within the specified functor term to value.">p_term_bind_functor_arg</a>(clone, (<span class="keywordtype">int</span>)index, arg);
<a name="l02957"></a>02957         }
<a name="l02958"></a>02958         <span class="keywordflow">return</span> clone; }
<a name="l02959"></a>02959     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>: {
<a name="l02960"></a>02960         <span class="comment">/* Clone a list term */</span>
<a name="l02961"></a>02961         p_term *head;
<a name="l02962"></a>02962         p_term *tail = 0;
<a name="l02963"></a>02963         clone = 0;
<a name="l02964"></a>02964         <span class="keywordflow">do</span> {
<a name="l02965"></a>02965             head = p_term_clone_inner(context, term-&gt;list.head);
<a name="l02966"></a>02966             <span class="keywordflow">if</span> (!head)
<a name="l02967"></a>02967                 <span class="keywordflow">return</span> 0;
<a name="l02968"></a>02968             head = <a class="code" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list</a>(context, head, 0);
<a name="l02969"></a>02969             <span class="keywordflow">if</span> (tail)
<a name="l02970"></a>02970                 tail-&gt;list.tail = head;
<a name="l02971"></a>02971             <span class="keywordflow">else</span>
<a name="l02972"></a>02972                 clone = head;
<a name="l02973"></a>02973             tail = head;
<a name="l02974"></a>02974             term = term-&gt;list.tail;
<a name="l02975"></a>02975             <span class="keywordflow">if</span> (!term)
<a name="l02976"></a>02976                 <span class="keywordflow">return</span> 0;
<a name="l02977"></a>02977             term = p_term_deref_non_null(term);
<a name="l02978"></a>02978         }
<a name="l02979"></a>02979         <span class="keywordflow">while</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>);
<a name="l02980"></a>02980         head = p_term_clone_inner(context, term);
<a name="l02981"></a>02981         <span class="keywordflow">if</span> (!head)
<a name="l02982"></a>02982             <span class="keywordflow">return</span> 0;
<a name="l02983"></a>02983         tail-&gt;list.tail = head;
<a name="l02984"></a>02984         <span class="keywordflow">return</span> clone; }
<a name="l02985"></a>02985     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>:
<a name="l02986"></a>02986     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>:
<a name="l02987"></a>02987     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba388c88e6b984687017b3cfdd7ef6c120">P_TERM_INTEGER</a>:
<a name="l02988"></a>02988     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bafd7125ad4718fd333c31c8fb1e839c2b">P_TERM_REAL</a>:
<a name="l02989"></a>02989     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bacab01465979c5d8682c2a5ce894865b3">P_TERM_OBJECT</a>:
<a name="l02990"></a>02990     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba5a63da82836776849b68a1daa6a50e85">P_TERM_PREDICATE</a>:
<a name="l02991"></a>02991     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba8258fa199fce59fdb134637613798624">P_TERM_DATABASE</a>:
<a name="l02992"></a>02992         <span class="comment">/* Constant and object terms are cloned as themselves */</span>
<a name="l02993"></a>02993         <span class="keywordflow">break</span>;
<a name="l02994"></a>02994     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l02995"></a>02995         <span class="comment">/* Create a new variable and bind the current one</span>
<a name="l02996"></a>02996 <span class="comment">         * to a rename term so that future references can</span>
<a name="l02997"></a>02997 <span class="comment">         * quickly reuse the cloned variable */</span>
<a name="l02998"></a>02998         <span class="keywordflow">if</span> (term-&gt;header.size &gt; 0)
<a name="l02999"></a>02999             clone = <a class="code" href="group__term.html#ga899f47e78554cdb98491716cc3c5072c" title="Creates an unbound variable within context and associates it with name.">p_term_create_named_variable</a>(context, <a class="code" href="group__term.html#gacb7b346b3f8f4a9fa31c3285eb615777" title="Returns the name of the functor, predicate, atom, or variable contained in term,...">p_term_name</a>(term));
<a name="l03000"></a>03000         <span class="keywordflow">else</span>
<a name="l03001"></a>03001             clone = <a class="code" href="group__term.html#ga770a6d4e622f5e3c1487a7e151c11e96" title="Creates an unbound variable within context.">p_term_create_variable</a>(context);
<a name="l03002"></a>03002         <span class="keywordflow">if</span> (!clone)
<a name="l03003"></a>03003             <span class="keywordflow">return</span> 0;
<a name="l03004"></a>03004         _p_context_record_in_trail(context, term);
<a name="l03005"></a>03005         rename = p_term_malloc
<a name="l03006"></a>03006             (context, p_term, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_rename));
<a name="l03007"></a>03007         <span class="keywordflow">if</span> (!rename)
<a name="l03008"></a>03008             <span class="keywordflow">return</span> 0;
<a name="l03009"></a>03009         rename-&gt;header.type = P_TERM_RENAME;
<a name="l03010"></a>03010         rename-&gt;rename.var = clone;
<a name="l03011"></a>03011         term-&gt;var.value = rename;
<a name="l03012"></a>03012         <span class="keywordflow">return</span> clone;
<a name="l03013"></a>03013     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l03014"></a>03014         <span class="comment">/* Clone a member variable reference */</span>
<a name="l03015"></a>03015         clone = p_term_clone_inner(context, term-&gt;member_var.object);
<a name="l03016"></a>03016         <span class="keywordflow">if</span> (!clone)
<a name="l03017"></a>03017             <span class="keywordflow">return</span> 0;
<a name="l03018"></a>03018         clone = <a class="code" href="group__term.html#ga5b517baf3da998736bf7a07ab83004ea" title="Creates an unbound member variable within context that refers to the member name...">p_term_create_member_variable</a>
<a name="l03019"></a>03019             (context, clone, term-&gt;member_var.name,
<a name="l03020"></a>03020              (<span class="keywordtype">int</span>)(term-&gt;header.size));
<a name="l03021"></a>03021         <span class="keywordflow">if</span> (!clone)
<a name="l03022"></a>03022             <span class="keywordflow">return</span> 0;
<a name="l03023"></a>03023         _p_context_record_in_trail(context, term);
<a name="l03024"></a>03024         rename = p_term_malloc
<a name="l03025"></a>03025             (context, p_term, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_rename));
<a name="l03026"></a>03026         <span class="keywordflow">if</span> (!rename)
<a name="l03027"></a>03027             <span class="keywordflow">return</span> 0;
<a name="l03028"></a>03028         rename-&gt;header.type = P_TERM_RENAME;
<a name="l03029"></a>03029         rename-&gt;rename.var = clone;
<a name="l03030"></a>03030         term-&gt;var.value = rename;
<a name="l03031"></a>03031         <span class="keywordflow">return</span> clone;
<a name="l03032"></a>03032     <span class="keywordflow">case</span> P_TERM_RENAME:
<a name="l03033"></a>03033         <span class="comment">/* Variable that has already been renamed */</span>
<a name="l03034"></a>03034         <span class="keywordflow">return</span> term-&gt;rename.var;
<a name="l03035"></a>03035     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l03036"></a>03036     }
<a name="l03037"></a>03037     <span class="keywordflow">return</span> term;
<a name="l03038"></a>03038 }
<a name="l03039"></a>03039 
<a name="l03048"></a><a class="code" href="group__term.html#ga885481b7ff34aeb38b88c77aa7d96477">03048</a> p_term *<a class="code" href="group__term.html#ga885481b7ff34aeb38b88c77aa7d96477" title="Clones term within context to create a new term that has freshly renamed versions...">p_term_clone</a>(p_context *context, p_term *term)
<a name="l03049"></a>03049 {
<a name="l03050"></a>03050     <span class="comment">/* We use the trail to record temporary bindings of variables</span>
<a name="l03051"></a>03051 <span class="comment">     * to P_TERM_RENAME terms, and then back them out at the end.</span>
<a name="l03052"></a>03052 <span class="comment">     * This won&apos;t be safe in concurrent environments, so we will</span>
<a name="l03053"></a>03053 <span class="comment">     * need to come up with a better solution later */</span>
<a name="l03054"></a>03054     <span class="keywordtype">void</span> *marker = <a class="code" href="group__context.html#gac75be874ed6eb4ab5cded2f1146e9ff9" title="Marks the current position in the backtrack trail in context and returns a marker...">p_context_mark_trail</a>(context);
<a name="l03055"></a>03055     p_term *clone = p_term_clone_inner(context, term);
<a name="l03056"></a>03056     <a class="code" href="group__context.html#gabec73eb41d877b21bb78c742d3b8afe2" title="Backtracks the trail in context, undoing variable bindings until marker is reached...">p_context_backtrack_trail</a>(context, marker);
<a name="l03057"></a>03057     <span class="keywordflow">return</span> clone;
<a name="l03058"></a>03058 }
<a name="l03059"></a>03059 
<a name="l03076"></a><a class="code" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485">03076</a> p_term *<a class="code" href="group__term.html#ga58aa1d3f87e8a158158cf7639d9f5485" title="Unifies term with the renamed head of clause.">p_term_unify_clause</a>(p_context *context, p_term *term, p_term *clause)
<a name="l03077"></a>03077 {
<a name="l03078"></a>03078     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l03079"></a>03079     <a class="code" href="group__context.html#ga52e3fd878090e61233c8e96223fea7a0">p_goal_result</a> result;
<a name="l03080"></a>03080     p_term *body = 0;
<a name="l03081"></a>03081 
<a name="l03082"></a>03082     <span class="comment">/* Copy the arguments to the head term into X registers */</span>
<a name="l03083"></a>03083     term = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(term);
<a name="l03084"></a>03084     <span class="keywordflow">if</span> (!term)
<a name="l03085"></a>03085         <span class="keywordflow">return</span> 0;
<a name="l03086"></a>03086     <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>) {
<a name="l03087"></a>03087         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l03088"></a>03088             _p_code_set_xreg
<a name="l03089"></a>03089                 (context, (<span class="keywordtype">int</span>)index, term-&gt;functor.arg[index]);
<a name="l03090"></a>03090         }
<a name="l03091"></a>03091     }
<a name="l03092"></a>03092 
<a name="l03093"></a>03093     <span class="comment">/* Run the clause using the interpreter to obtain the body.</span>
<a name="l03094"></a>03094 <span class="comment">     * For dynamic clauses, only true, fail, or return are possible */</span>
<a name="l03095"></a>03095     result = _p_code_run(context, &amp;(clause-&gt;clause.clause_code), &amp;body);
<a name="l03096"></a>03096     <span class="keywordflow">if</span> (result == P_RESULT_RETURN_BODY)
<a name="l03097"></a>03097         <span class="keywordflow">return</span> body;
<a name="l03098"></a>03098     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == <a class="code" href="group__context.html#gga52e3fd878090e61233c8e96223fea7a0abd034ee80e2e27dd52bf3fc66cfcd215">P_RESULT_TRUE</a>)
<a name="l03099"></a>03099         <span class="keywordflow">return</span> context-&gt;true_atom;
<a name="l03100"></a>03100     <span class="keywordflow">else</span>
<a name="l03101"></a>03101         <span class="keywordflow">return</span> 0;
<a name="l03102"></a>03102 }
<a name="l03103"></a>03103 
<a name="l03117"></a><a class="code" href="group__term.html#gac5ab644da0bd5f5d69d73721e38a838a">03117</a> <span class="keywordtype">int</span> <a class="code" href="group__term.html#gac5ab644da0bd5f5d69d73721e38a838a" title="Compares str1 and str2 and returns a comparison code.">p_term_strcmp</a>(<span class="keyword">const</span> p_term *str1, <span class="keyword">const</span> p_term *str2)
<a name="l03118"></a>03118 {
<a name="l03119"></a>03119     <span class="keyword">const</span> <span class="keywordtype">char</span> *s1;
<a name="l03120"></a>03120     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s1len;
<a name="l03121"></a>03121     <span class="keyword">const</span> <span class="keywordtype">char</span> *s2;
<a name="l03122"></a>03122     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s2len;
<a name="l03123"></a>03123     <span class="keywordtype">int</span> cmp;
<a name="l03124"></a>03124     <span class="keywordflow">if</span> (!str1 || !str2)
<a name="l03125"></a>03125         <span class="keywordflow">return</span> 0;
<a name="l03126"></a>03126     str1 = p_term_deref_non_null(str1);
<a name="l03127"></a>03127     str2 = p_term_deref_non_null(str2);
<a name="l03128"></a>03128     <span class="keywordflow">if</span> (str1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>) {
<a name="l03129"></a>03129         s1 = str1-&gt;atom.name;
<a name="l03130"></a>03130         s1len = str1-&gt;header.size;
<a name="l03131"></a>03131     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str1-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>) {
<a name="l03132"></a>03132         s1 = str1-&gt;string.name;
<a name="l03133"></a>03133         s1len = str1-&gt;header.size;
<a name="l03134"></a>03134     } <span class="keywordflow">else</span> {
<a name="l03135"></a>03135         <span class="keywordflow">return</span> 0;
<a name="l03136"></a>03136     }
<a name="l03137"></a>03137     <span class="keywordflow">if</span> (str2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba0b7cb4365cfdc78651f6d6d3067bf552">P_TERM_ATOM</a>) {
<a name="l03138"></a>03138         s2 = str2-&gt;atom.name;
<a name="l03139"></a>03139         s2len = str2-&gt;header.size;
<a name="l03140"></a>03140     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str2-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>) {
<a name="l03141"></a>03141         s2 = str2-&gt;string.name;
<a name="l03142"></a>03142         s2len = str2-&gt;header.size;
<a name="l03143"></a>03143     } <span class="keywordflow">else</span> {
<a name="l03144"></a>03144         <span class="keywordflow">return</span> 0;
<a name="l03145"></a>03145     }
<a name="l03146"></a>03146     <span class="keywordflow">if</span> (!s1len)
<a name="l03147"></a>03147         <span class="keywordflow">return</span> s2len ? -1 : 0;
<a name="l03148"></a>03148     <span class="keywordflow">if</span> (!s2len)
<a name="l03149"></a>03149         <span class="keywordflow">return</span> s1len ? 1 : 0;
<a name="l03150"></a>03150     <span class="keywordflow">if</span> (s1len == s2len) {
<a name="l03151"></a>03151         <span class="keywordflow">return</span> memcmp(s1, s2, s1len);
<a name="l03152"></a>03152     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s1len &lt; s2len) {
<a name="l03153"></a>03153         cmp = memcmp(s1, s2, s1len);
<a name="l03154"></a>03154         <span class="keywordflow">if</span> (cmp != 0)
<a name="l03155"></a>03155             <span class="keywordflow">return</span> cmp;
<a name="l03156"></a>03156         <span class="keywordflow">else</span>
<a name="l03157"></a>03157             <span class="keywordflow">return</span> -1;
<a name="l03158"></a>03158     } <span class="keywordflow">else</span> {
<a name="l03159"></a>03159         cmp = memcmp(s1, s2, s2len);
<a name="l03160"></a>03160         <span class="keywordflow">if</span> (cmp != 0)
<a name="l03161"></a>03161             <span class="keywordflow">return</span> cmp;
<a name="l03162"></a>03162         <span class="keywordflow">else</span>
<a name="l03163"></a>03163             <span class="keywordflow">return</span> 1;
<a name="l03164"></a>03164     }
<a name="l03165"></a>03165 }
<a name="l03166"></a>03166 
<a name="l03176"></a><a class="code" href="group__term.html#gaefa85ee27db354f5e5f4d0b213fde9cf">03176</a> p_term *<a class="code" href="group__term.html#gaefa85ee27db354f5e5f4d0b213fde9cf" title="Concatenates str1 and str2 to create a new string.">p_term_concat_string</a>(p_context *context, p_term *str1, p_term *str2)
<a name="l03177"></a>03177 {
<a name="l03178"></a>03178     <span class="keywordtype">size_t</span> len;
<a name="l03179"></a>03179     <span class="keyword">struct </span>p_term_string *term;
<a name="l03180"></a>03180     str1 = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(str1);
<a name="l03181"></a>03181     str2 = <a class="code" href="group__term.html#ga3632325e60de70357ababa97655195e0" title="Dereferences term to resolve bound variables.">p_term_deref</a>(str2);
<a name="l03182"></a>03182     <span class="keywordflow">if</span> (!str1 || str1-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>)
<a name="l03183"></a>03183         <span class="keywordflow">return</span> 0;
<a name="l03184"></a>03184     <span class="keywordflow">if</span> (!str2 || str2-&gt;header.type != <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>)
<a name="l03185"></a>03185         <span class="keywordflow">return</span> 0;
<a name="l03186"></a>03186     <span class="keywordflow">if</span> (str1-&gt;header.size == 0)
<a name="l03187"></a>03187         <span class="keywordflow">return</span> str2;
<a name="l03188"></a>03188     <span class="keywordflow">if</span> (str2-&gt;header.size == 0)
<a name="l03189"></a>03189         <span class="keywordflow">return</span> str1;
<a name="l03190"></a>03190     len = str1-&gt;header.size + str2-&gt;header.size;
<a name="l03191"></a>03191     term = p_term_malloc
<a name="l03192"></a>03192         (context, <span class="keyword">struct</span> p_term_string, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> p_term_string) + len);
<a name="l03193"></a>03193     <span class="keywordflow">if</span> (!term)
<a name="l03194"></a>03194         <span class="keywordflow">return</span> 0;
<a name="l03195"></a>03195     term-&gt;header.type = <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55baf4d3e8fa837de36d81c47851e2c9ac60">P_TERM_STRING</a>;
<a name="l03196"></a>03196     term-&gt;header.size = (<span class="keywordtype">unsigned</span> int)len;
<a name="l03197"></a>03197     memcpy(term-&gt;name, str1-&gt;string.name, str1-&gt;header.size);
<a name="l03198"></a>03198     memcpy(term-&gt;name + str1-&gt;header.size, str2-&gt;string.name, str2-&gt;header.size);
<a name="l03199"></a>03199     <span class="keywordflow">return</span> (p_term *)term;
<a name="l03200"></a>03200 }
<a name="l03201"></a>03201 
<a name="l03202"></a>03202 <span class="comment">/* Inner implementation of p_term_witness */</span>
<a name="l03203"></a>03203 <span class="keyword">static</span> p_term *p_term_witness_inner
<a name="l03204"></a>03204     (p_context *context, p_term *term, p_term *list)
<a name="l03205"></a>03205 {
<a name="l03206"></a>03206     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l03207"></a>03207     <span class="keywordflow">if</span> (!term)
<a name="l03208"></a>03208         <span class="keywordflow">return</span> list;
<a name="l03209"></a>03209     term = p_term_deref_non_null(term);
<a name="l03210"></a>03210     <span class="keywordflow">switch</span> (term-&gt;header.type) {
<a name="l03211"></a>03211     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a>:
<a name="l03212"></a>03212         <span class="comment">/* Fetch the witness of the arguments */</span>
<a name="l03213"></a>03213         <span class="keywordflow">for</span> (index = 0; index &lt; term-&gt;header.size; ++index) {
<a name="l03214"></a>03214             list = p_term_witness_inner
<a name="l03215"></a>03215                 (context, term-&gt;functor.arg[index], list);
<a name="l03216"></a>03216         }
<a name="l03217"></a>03217         <span class="keywordflow">break</span>;
<a name="l03218"></a>03218     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>:
<a name="l03219"></a>03219         <span class="comment">/* Fetch the witness of the list members */</span>
<a name="l03220"></a>03220         <span class="keywordflow">do</span> {
<a name="l03221"></a>03221             list = p_term_witness_inner(context, term-&gt;list.head, list);
<a name="l03222"></a>03222             term = term-&gt;list.tail;
<a name="l03223"></a>03223             <span class="keywordflow">if</span> (!term)
<a name="l03224"></a>03224                 <span class="keywordflow">break</span>;
<a name="l03225"></a>03225             term = p_term_deref_non_null(term);
<a name="l03226"></a>03226         } <span class="keywordflow">while</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55bad71b188e3501ed4c3a485ea9df3a8532">P_TERM_LIST</a>);
<a name="l03227"></a>03227         <span class="keywordflow">return</span> p_term_witness_inner(context, term, list);
<a name="l03228"></a>03228     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba2f45a5e0025d6d9b131699527dbb3ac6">P_TERM_VARIABLE</a>:
<a name="l03229"></a>03229         <span class="comment">/* Add the variable to the list, and then bind it to an</span>
<a name="l03230"></a>03230 <span class="comment">         * atom to prevent it being added to the list again if</span>
<a name="l03231"></a>03231 <span class="comment">         * we see it during subsequent traversal.  We don&apos;t update</span>
<a name="l03232"></a>03232 <span class="comment">         * the list if it is null, because that happens when</span>
<a name="l03233"></a>03233 <span class="comment">         * traversing the left-hand side of a ^ term */</span>
<a name="l03234"></a>03234         <span class="keywordflow">if</span> (list)
<a name="l03235"></a>03235             list = <a class="code" href="group__term.html#ga17481776d0fda576367bae90263f7fe5" title="Creates a list term from head and tail within context. Returns the new list.">p_term_create_list</a>(context, term, list);
<a name="l03236"></a>03236         <span class="keywordflow">if</span> (_p_context_record_in_trail(context, term))
<a name="l03237"></a>03237             term-&gt;var.value = context-&gt;true_atom;
<a name="l03238"></a>03238         <span class="keywordflow">break</span>;
<a name="l03239"></a>03239     <span class="keywordflow">case</span> <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba448d3383a6d126407bfd5c00e651888b">P_TERM_MEMBER_VARIABLE</a>:
<a name="l03240"></a>03240         <span class="comment">/* Fetch the witness for the object term */</span>
<a name="l03241"></a>03241         <span class="keywordflow">return</span> p_term_witness_inner
<a name="l03242"></a>03242             (context, term-&gt;member_var.object, list);
<a name="l03243"></a>03243     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l03244"></a>03244     }
<a name="l03245"></a>03245     <span class="keywordflow">return</span> list;
<a name="l03246"></a>03246 }
<a name="l03247"></a>03247 
<a name="l03260"></a><a class="code" href="group__term.html#ga146e5df50fb750f07ae1a2c71e852086">03260</a> p_term *<a class="code" href="group__term.html#ga146e5df50fb750f07ae1a2c71e852086" title="Returns a list of the free variables in term, where each free variable occurs only...">p_term_witness</a>(p_context *context, p_term *term, p_term **subgoal)
<a name="l03261"></a>03261 {
<a name="l03262"></a>03262     p_term *caret = <a class="code" href="group__term.html#ga45ca0be88d01bae8971186c2b048aff8" title="Creates an atom within context with the specified name.">p_term_create_atom</a>(context, <span class="stringliteral">&quot;^&quot;</span>);
<a name="l03263"></a>03263     p_term *list;
<a name="l03264"></a>03264     <span class="keywordtype">void</span> *marker = <a class="code" href="group__context.html#gac75be874ed6eb4ab5cded2f1146e9ff9" title="Marks the current position in the backtrack trail in context and returns a marker...">p_context_mark_trail</a>(context);
<a name="l03265"></a>03265     <span class="keywordflow">while</span> (term) {
<a name="l03266"></a>03266         term = p_term_deref_non_null(term);
<a name="l03267"></a>03267         <span class="keywordflow">if</span> (term-&gt;header.type == <a class="code" href="group__term.html#ga06fc87d81c62e9abb8790b6e5713c55ba1eff9c0ce4d3a0c040c7b1002d23978f">P_TERM_FUNCTOR</a> &amp;&amp;
<a name="l03268"></a>03268                 term-&gt;header.size == 2 &amp;&amp;
<a name="l03269"></a>03269                 term-&gt;functor.functor_name == caret) {
<a name="l03270"></a>03270             p_term_witness_inner(context, term-&gt;functor.arg[0], 0);
<a name="l03271"></a>03271             term = term-&gt;functor.arg[1];
<a name="l03272"></a>03272         } <span class="keywordflow">else</span> {
<a name="l03273"></a>03273             <span class="keywordflow">break</span>;
<a name="l03274"></a>03274         }
<a name="l03275"></a>03275     }
<a name="l03276"></a>03276     *subgoal = term;
<a name="l03277"></a>03277     list = p_term_witness_inner(context, term, context-&gt;nil_atom);
<a name="l03278"></a>03278     <a class="code" href="group__context.html#gabec73eb41d877b21bb78c742d3b8afe2" title="Backtracks the trail in context, undoing variable bindings until marker is reached...">p_context_backtrack_trail</a>(context, marker);
<a name="l03279"></a>03279     <span class="keywordflow">return</span> list;
<a name="l03280"></a>03280 }
<a name="l03281"></a>03281 
<a name="l03282"></a>03282 <span class="comment">/*\@}*/</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
