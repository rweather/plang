<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plang: Builtin predicates - Arithmetic and string operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Builtin predicates - Arithmetic and string operations</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Predicates and functions in this group are used to perform arithmetic and string operations. String operations are further subdivided into operations on UTF-8 character strings, and operations on strings of raw bytes.</p>
<p>Predicates: <a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a>, <a class="el" href="group__arithmetic.html#atom_name_2">atom_name/2</a>, <a class="el" href="group__arithmetic.html#fperror_1">fperror/1</a>, <a class="el" href="group__arithmetic.html#isnan_1">isnan/1</a>, <a class="el" href="group__arithmetic.html#isinf_1">isinf/1</a>, <a class="el" href="group__arithmetic.html#randomize_0">randomize/0</a>, <a class="el" href="group__arithmetic.html#randomize_1">randomize/1</a></p>
<p>Mathematical operators: <a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a>, <a class="el" href="group__arithmetic.html#func_pow_2">(**)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">mod/2</a>, <a class="el" href="group__arithmetic.html#func_rem_2">rem/2</a></p>
<p>Mathematical functions: <a class="el" href="group__arithmetic.html#func_abs_1">abs/1</a>, <a class="el" href="group__arithmetic.html#func_ceil_1">ceil/1</a>, <a class="el" href="group__arithmetic.html#func_exp_1">exp/1</a>, <a class="el" href="group__arithmetic.html#func_float_fractional_part_1">float_fractional_part/1</a>, <a class="el" href="group__arithmetic.html#func_float_integer_part_1">float_integer_part/1</a>, <a class="el" href="group__arithmetic.html#func_floor_1">floor/1</a>, <a class="el" href="group__arithmetic.html#func_log_1">log/1</a>, <a class="el" href="group__arithmetic.html#func_pow_2">pow/2</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a>, <a class="el" href="group__arithmetic.html#func_sign_1">sign/1</a>, <a class="el" href="group__arithmetic.html#func_sqrt_1">sqrt/1</a>, <a class="el" href="group__arithmetic.html#func_truncate_1">truncate/1</a></p>
<p>Mathematical constants: <a class="el" href="group__arithmetic.html#func_e_0">e/0</a>, <a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>, <a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></p>
<p>Trigonometric functions: <a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a></p>
<p>Bitwise operators: <a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/2</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></p>
<p>Type conversion functions: <a class="el" href="group__arithmetic.html#func_float_1">float/1</a>, <a class="el" href="group__arithmetic.html#func_integer_1">integer/1</a>, <a class="el" href="group__arithmetic.html#func_string_1">string/1</a>, <a class="el" href="group__arithmetic.html#func_string_2">string/2</a></p>
<p>UTF-8 string functions: <a class="el" href="group__arithmetic.html#func_char_2">char/2</a>, <a class="el" href="group__arithmetic.html#func_char_to_string_1">char_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_left_2">left/2</a>, <a class="el" href="group__arithmetic.html#func_length_1">length/1</a>, <a class="el" href="group__arithmetic.html#func_mid_2">mid/2</a>, <a class="el" href="group__arithmetic.html#func_mid_3">mid/3</a>, <a class="el" href="group__arithmetic.html#func_right_2">right/2</a></p>
<p>Byte string functions: <a class="el" href="group__arithmetic.html#func_byte_2">byte/2</a>, <a class="el" href="group__arithmetic.html#func_byte_to_string_1">byte_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_left_bytes_2">left_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_length_bytes_1">length_bytes/1</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_2">mid_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_3">mid_bytes/3</a>, <a class="el" href="group__arithmetic.html#func_right_bytes_2">right_bytes/2</a></p>
<p>Random number generation: <a class="el" href="group__arithmetic.html#func_random_0">random/0</a></p>
<hr/>
 <a class="anchor" id="is_2"></a> <b>is/2</b> - unifies the result of an arithmetic expression with a variable.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr</em> is evaluated as an arithmetic expression and the result is unified with <em>Var</em>. Expressions are evaluated as follows:</dd></dl>
<ul>
<li>Integer, real, and string terms evaluate to themselves. </li>
<li>An atom will cause a call to an internal function that returns a constant value if there is an arithmatic constant associated with the atom; for example <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a>. </li>
<li>A compound functor term will evaluate each of the arguments as arithmetic expressions and then call the corresponding arithmetic function.</li>
</ul>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - An unbound variable was encountered in a subexpression. </li>
<li><code>type_error(evaluable, <em>Expr</em>)</code> - <em>Expr</em> is not an integer constant, floating-point constant, string constant, or defined arithmetic function. </li>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number but it was used as an argument to an arithmetic function that requires a number. </li>
<li><code>type_error(integer, <em>Expr</em>)</code> - <em>Expr</em> is not an integer but it was used as an argument to an arithmetic function that requires an integer. </li>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string but it was used as an argument to an arithmetic function that requires a string. </li>
<li><code>evaluation_error(zero_divisor)</code> - <em>Expr</em> attempted to divide by zero. </li>
<li><code>evaluation_error(int_overflow)</code> - a conversion to the integer type resulted in an overflow because the incoming value was too large. Note: ordinary mathematical and bitwise operators on integers like <a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, etc do not report overflow.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is Y + 1
 S is sin(Angle * pi / 180)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>Evaluation and error reporting are mostly compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. Floating-point exceptions such as overflow and divide-by-zero are not reported as thrown errors; use <a class="el" href="group__arithmetic.html#fperror_1">fperror/1</a> instead.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__assignment.html#num_assign_2">(::=)/2</a>, <a class="el" href="group__arithmetic.html#fperror_1">fperror/1</a></dd></dl>
<hr/>
 <a class="anchor" id="num_eq_2"></a> <b>(=:=)/2</b> - arithmetic equality.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>=</em>:=</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the two values are identical, then <em>Expr1</em> <b>=:=</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>=:=</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings are compared for identity.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 4 =:= 6
 1.5 =:= 3.0 / 2
 <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;bar&quot;</span> =:= <span class="stringliteral">&quot;foobar&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>Compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a> for integer and floating-point comparisons. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="num_ne_2"></a> <b>(=!=)/2</b>, <b>(=\=)/2</b> - arithmetic inequality.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>=!=</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em><em>Expr1</em> <b>=\=</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the two values are not identical, then <em>Expr1</em> <b>=!=</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>=!=</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings are compared for non-identity.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 2 =!= 5
 1.5 =!= 3.0 * 2
 <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;ba&quot;</span> =!= <span class="stringliteral">&quot;foobar&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(=\=)/2</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>(=!=)/2</b> is the recommended spelling. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="num_lt_2"></a> <b>(&lt;)/2</b> - arithmetic less than comparison.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>&lt;</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr1</em> is less than the value of <em>Expr2</em>, then <em>Expr1</em> <b>&lt;</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>&lt;</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings, which may contain embedded NUL's, are compared using the C function memcmp().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 2 &lt; 5
 1.5 &lt; 3.0 * 2
 <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;ba&quot;</span> &lt; <span class="stringliteral">&quot;foobar&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>Compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a> for integer and floating-point comparisons. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="num_le_2"></a> <b>(&lt;=)/2</b>, <b>(=&lt;)/2</b> - arithmetic less than or equal comparison.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>&lt;=</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em><em>Expr1</em> <b>=&lt;</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr1</em> is less than or equal to the value of <em>Expr2</em>, then <em>Expr1</em> <b>&lt;=</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>&lt;=</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings, which may contain embedded NUL's, are compared using the C function memcmp().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 2 &lt;= 4
 1.5 &lt;= 3.0 * 2
 1.5 &lt;= 3.0 * 0.5
 <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;ba&quot;</span> &lt;= <span class="stringliteral">&quot;foobar&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(=&lt;)/2</b> predicate is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>(&lt;=)/2</b> is the recommended spelling. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="num_gt_2"></a> <b>(&gt;)/2</b> - arithmetic greater than comparison.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>&gt;</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr1</em> is greater than the value of <em>Expr2</em>, then <em>Expr1</em> <b>&gt;</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>&gt;</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings, which may contain embedded NUL's, are compared using the C function memcmp().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 2 &gt; 3
 3.0 * 2 &gt; 1.5
 <span class="stringliteral">&quot;foobar&quot;</span> &gt; <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;ba&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>Compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a> for integer and floating-point comparisons. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_ge_2">(&gt;=)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="num_ge_2"></a> <b>(&gt;=)/2</b> - arithmetic greater than or equal comparison.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em><em>Expr1</em> <b>&gt;=</b></em> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr1</em> and <em>Expr2</em> are evaluated as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr1</em> is greater than or equal to the value of <em>Expr2</em>, then <em>Expr1</em> <b>&gt;=</b> <em>Expr2</em> succeeds. Otherwise, <em>Expr1</em> <b>&gt;=</b> <em>Expr2</em> fails. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If one of <em>Expr1</em> or <em>Expr2</em> evaluates to an integer and the other evaluates to a floating-point value, then both will be converted into floating-point values prior to comparison. Strings, which may contain embedded NUL's, are compared using the C function memcmp().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> 2 + 2 &gt;= 4
 3.0 * 0.5 &gt;= 1.5
 <span class="stringliteral">&quot;foobar&quot;</span> &gt;= <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;ba&quot;</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>Compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a> for integer and floating-point comparisons. String comparisons are a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#num_eq_2">(=:=)/2</a>, <a class="el" href="group__arithmetic.html#num_ne_2">(=!=)/2</a>, <a class="el" href="group__arithmetic.html#num_lt_2">(&lt;)/2</a>, <a class="el" href="group__arithmetic.html#num_le_2">(&lt;=)/2</a>, <a class="el" href="group__arithmetic.html#num_gt_2">(&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="atom_name_2"></a> <b>atom_name/2</b> - converts between atoms and strings.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>atom_name</b>(<em>Atom</em>, <em>String</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Atom</em> is an atom, then unifies <em>String</em> with the name of <em>Atom</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Atom</em> is a variable and <em>String</em> is a string, then unifies <em>Atom</em> with the atom whose name is <em>String</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - both <em>Atom</em> and <em>String</em> are variables. </li>
<li><code>type_error(atom, <em>Atom</em>)</code> - <em>Atom</em> is not an atom or variable. </li>
<li><code>type_error(string, <em>String</em>)</code> - <em>Atom</em> is a variable and <em>String</em> is not a string.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> atom_name(foobar, S)         sets S to &quot;foobar&quot;
 atom_name(&apos;hi there!&apos;, S)    sets S to &quot;hi there!&quot;
 atom_name(A, &quot;foobar&quot;)       sets A to foobar
 atom_name(A, &quot;&quot;)             sets A to &apos;&apos;
 atom_name(foobar, &quot;barfoo&quot;)  fails
 atom_name(A, S)              instantiation_error
 atom_name(1.5, S)            type_error(atom, 1.5)
 atom_name(A, foobar)         type_error(<span class="keywordtype">string</span>, foobar)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_char_2">char/2</a></dd></dl>
<hr/>
 <a class="anchor" id="fperror_1"></a> <b>fperror/1</b> - floating-point exception handling.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>fperror</b>(<em>Type</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>If <em>Type</em> is the atom <code>clear</code>, then clear all of the floating-point exception flags in the system and succeed. Otherwise, test for a specific floating-point exception and succeed if it is present. If <em>Type</em> is not recognized, or the exception has not been raised, then <b>fperror</b>(<em>Type</em>) fails.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li><code>inexact</code> - result could not be represented exactly. </li>
<li><code>overflow</code> - overflow occurred. </li>
<li><code>undefined</code> - result was undefined (not-a-number). </li>
<li><code>underflow</code> - underflow occurred. </li>
<li><code>zero_divisor</code> - division by zero.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note: <b>fperror/1</b> relies upon the presence of the C99 floating-point exception functions feclearexcept() and fetestexcept(). If these functions are not present, then <b>fperror/1</b> will succeed for <code>clear</code> and fail for all other arguments. The <a class="el" href="group__arithmetic.html#isnan_1">isnan/1</a> and <a class="el" href="group__arithmetic.html#isinf_1">isinf/1</a> predicates may be used to detect certain error conditions.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Type</em> is a variable. </li>
<li><code>type_error(atom, <em>Type</em>)</code> - <em>Type</em> is not an atom.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> fperror(clear);
 X is Y / Z;
 <span class="keywordflow">if</span> (fperror(zero_divisor))
     stderr::writeln(<span class="stringliteral">&quot;division by zero occurred&quot;</span>);
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#isnan_1">isnan/1</a>, <a class="el" href="group__arithmetic.html#isinf_1">isinf/1</a></dd></dl>
<hr/>
 <a class="anchor" id="isnan_1"></a> <b>isnan/1</b> - test an arithmetic value for not-a-number.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>isnan</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr</em> is as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr</em> is the IEEE not-a-number indicator, then <b>isnan</b>(<em>Expr</em>) succeeds. Otherwise, <b>isnan</b>(<em>Expr</em>) fails.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> isnan(nan)               succeeds
 isnan(<span class="keywordtype">float</span>(&quot;nan&quot;))      succeeds
 isnan(3)                 fails
 isnan(inf)               fails
 isnan(&quot;nan&quot;)             type_error(number, &quot;nan&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#isinf_1">isinf/1</a>, <a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>, <a class="el" href="group__arithmetic.html#fperror_1">fperror/1</a></dd></dl>
<hr/>
 <a class="anchor" id="isinf_1"></a> <b>isinf/1</b> - test an arithmetic value for infinity.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>isinf</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd><em>Expr</em> is as described in the documentation for <a class="el" href="group__arithmetic.html#is_2">is/2</a>. If the value of <em>Expr</em> is an IEEE infinity indicator, then <b>isinf</b>(<em>Expr</em>) succeeds. Otherwise, <b>isinf</b>(<em>Expr</em>) fails.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> isinf(inf)               succeeds
 isinf(-inf)              succeeds
 isinf(<span class="keywordtype">float</span>(&quot;inf&quot;))      succeeds
 isinf(<span class="keywordtype">float</span>(&quot;-inf&quot;))     succeeds
 isinf(3)                 fails
 isinf(nan)               fails
 isinf(&quot;inf&quot;)             type_error(number, &quot;inf&quot;)
 isinf(X); X &lt; 0          checks for negative infinity
 isinf(X); X &gt; 0          checks for positive infinity
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#isnan_1">isnan/1</a>, <a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>, <a class="el" href="group__arithmetic.html#fperror_1">fperror/1</a></dd></dl>
<hr/>
 <a class="anchor" id="randomize_0"></a> <a class="anchor" id="randomize_1"></a> <b>randomize/0</b>, <b>randomize/1</b> - seed the random number generator.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><b>randomize</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>randomize</b>(<em>Value</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>The <b>randomize/0</b> predicate seeds the random number generator with indeterminate information from the operating system environment (e.g. current time of day). This version should be used if different results are desired each time the application is run. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <b>randomize/1</b> predicate seeds the random number generator based on the specified integer or floating-point <em>Value</em>. This version should be used to generate a repeatable sequence of random numbers each time the application is run.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>instantiation_error</code> - <em>Value</em> is a variable. </li>
<li><code>type_error(number, <em>Value</em>)</code> - <em>Value</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> randomize
 randomize(42)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_random_0">random/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_add_2"></a> <b>(+)/2</b> - addition of two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>+</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> + <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value <em>Expr1</em> + <em>Expr2</em>. If both are strings, then the result is the concatenation of <em>Expr1</em> and <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr1</em> is a number, but <em>Expr2</em> is not. </li>
<li><code>type_error(string, <em>Expr2</em>)</code> - <em>Expr1</em> is a string, but <em>Expr2</em> is not.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 + 2               sets X to the integer value 4
 X is 1.5 + 3             sets X to the floating-point value 4.5
 X is <span class="stringliteral">&quot;foo&quot;</span> + <span class="stringliteral">&quot;bar&quot;</span>       sets X to the <span class="keywordtype">string</span> <span class="stringliteral">&quot;foobar&quot;</span>
 X is 1 + <span class="stringliteral">&quot;foo&quot;</span>           type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; + 1           type_error(<span class="keywordtype">string</span>, 1)
 X is &quot;foo&quot; + <span class="keywordtype">string</span>(1)   sets X to the <span class="keywordtype">string</span> &quot;foo1&quot;
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(+)/2</b> function is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a> for integer and floating-point arguments. String concatenation is a Plang extension.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_neg_1"></a> <b>(-)/1</b> - negation of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>-</b> <em>Expr</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em>. If the result is an integer, then the result is the integer value - <em>Expr</em>. If the result is a floating-point number, then the result is the floating-point value - <em>Expr</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note: integer and floating-point constants that start with "-" will be recognized as negative numbers by the parser if there is no space between the "-" and the digits. If there is a space, then a term with <b>(-)/1</b> as its functor will be created. Thus, <code>-2 == - 2</code> will fail, but <code>-2 =:= - 2</code> will succeed.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is - 2                 sets X to the integer value -2
 X is - 1.5               sets X to the floating-point value -1.5
 X is - <span class="stringliteral">&quot;foo&quot;</span>             type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is --2                 sets X to the integer value 2
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a>, <a class="el" href="group__arithmetic.html#func_abs_1">abs/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_sub_2"></a> <b>(-)/2</b> - subtraction of two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>-</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> - <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value <em>Expr1</em> - <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 - 2               sets X to the integer value 0
 X is 1.5 - 3             sets X to the floating-point value -1.5
 X is 1 - <span class="stringliteral">&quot;foo&quot;</span>           type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; - 1           type_error(number, &quot;foo&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_mul_2"></a> <b>(*)/2</b> - multiplication of two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>*</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> * <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value <em>Expr1</em> * <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 * 2               sets X to the integer value 4
 X is 1.5 * 3             sets X to the floating-point value 4.5
 X is 1 * <span class="stringliteral">&quot;foo&quot;</span>           type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; * 1           type_error(number, &quot;foo&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_div_2"></a> <b>(/)/2</b> - division of two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>/</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> / <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value <em>Expr1</em> / <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number. </li>
<li><code>evaluation_error(zero_divisor)</code> - <em>Expr2</em> is zero and an integer division is being performed. Floating-point division will produce not-a number (<a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>) or an infinity (<a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>) if <em>Expr2</em> is zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 / 2               sets X to the integer value 1
 X is 1.5 / 3             sets X to the floating-point value 0.5
 X is 1 / <span class="stringliteral">&quot;foo&quot;</span>           type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; / 1           type_error(number, &quot;foo&quot;)
 X is 42 / 0              evaluation_error(zero_divisor)
 X is 42 / 0.0            sets X to positive infinity
 X is 0.0 / 0.0           sets X to not-a-number
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(/)/2</b> function is part of <a class="el" href="group__predicates.html#standard">Standard Prolog</a>, but it has a slightly different interpretation when mixing integer and floating-point values. In Standard Prolog, <b>(/)/2</b> always produces a floating-point result, even if both arguments are integers. Standard Prolog has a separate <b>(//)/2</b> function for integer division. The Standard Prolog forms can be translated into Plang using explicit type conversions: <div class="fragment"><pre class="fragment"> X is Y / Z               X is float(Y) / float(Z)
 X is Y <span class="comment">// Z              X is integer(Y) / integer(Z)</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_mod_2"></a> <b>(%)/2</b>, <b>mod/2</b> - modulus of dividing two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>%</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>mod</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> % <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value fmod(<em>Expr1</em>, <em>Expr2</em>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The floating-point modulus uses the C function fmod(). For the IEEE remainder, use <a class="el" href="group__arithmetic.html#func_rem_2">remainder/2</a>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number. </li>
<li><code>evaluation_error(zero_divisor)</code> - <em>Expr2</em> is zero and an integer division is being performed. Floating-point remainder will produce not-a number (<a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>) if <em>Expr2</em> is zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 % 2               sets X to the integer value 0
 X is 3 % 2               sets X to the integer value 1
 X is 1.5 % 3             sets X to the floating-point value 1.5
 X is 1 % <span class="stringliteral">&quot;foo&quot;</span>           type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; % 1           type_error(number, &quot;foo&quot;)
 X is 42 % 0              evaluation_error(zero_divisor)
 X is 42 % 0.0            sets X to not-a-number
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>mod/2</b> function is from <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>(%)/2</b> is the recommended spelling. In Standard Prolog, <b>mod/2</b> only works on integer values. Plang extends the definition to floating-point.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_rem_2">remainder/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_rem_2"></a> <b>rem/2</b> - IEEE remainder of dividing two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>rem</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value <em>Expr1</em> % <em>Expr2</em>. If both are numbers (integers or floating-point), then the result is the floating-point value remainder(<em>Expr1</em>, <em>Expr2</em>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The floating-point remainder uses the C function remainder(). For the C function fmod(), use <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number. </li>
<li><code>evaluation_error(zero_divisor)</code> - <em>Expr2</em> is zero and an integer division is being performed. Floating-point remainder will produce not-a number (<a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>) if <em>Expr2</em> is zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 2 rem 2             sets X to the integer value 0
 X is 3 rem 2             sets X to the integer value 1
 X is 1.5 rem 3           sets X to the floating-point value 1.5
 X is 1 rem <span class="stringliteral">&quot;foo&quot;</span>         type_error(number, <span class="stringliteral">&quot;foo&quot;</span>)
 X is &quot;foo&quot; rem 1         type_error(number, &quot;foo&quot;)
 X is 42 rem 0            evaluation_error(zero_divisor)
 X is 42 rem 0.0          sets X to not-a-number
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>rem/2</b> function is from <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>remainder/2</b> is the recommended spelling. In Standard Prolog, <b>rem/2</b> only works on integer values. Plang extends the definition to floating-point.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_add_2">(+)/2</a>, <a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sub_2">(-)/2</a>, <a class="el" href="group__arithmetic.html#func_mul_2">(*)/2</a>, <a class="el" href="group__arithmetic.html#func_div_2">(/)/2</a>, <a class="el" href="group__arithmetic.html#func_mod_2">(%)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_and_2"></a> <b>(/\)/2</b> - bitwise-and of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <code>/\</code> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing a bitwise-and of <em>Expr1</em> and <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 /\\ 5            X is <span class="keyword">set</span> to 4
 X is 22.0 /\\ 5          type_error(integer, 22.0)
 X is 22 /\\ 5.0          type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_or_2"></a> <b>(\/)/2</b> - bitwise-or of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <code>\/</code> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing a bitwise-or of <em>Expr1</em> and <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 \\/ 5            X is <span class="keyword">set</span> to 23
 X is 22.0 \\/ 5          type_error(integer, 22.0)
 X is 22 \\/ 5.0          type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_xor_2"></a> <b>(^)/2</b> - bitwise-xor of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <code>^</code> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing a bitwise-xor of <em>Expr1</em> and <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 ^ 5              X is <span class="keyword">set</span> to 19
 X is 22.0 ^ 5            type_error(integer, 22.0)
 X is 22 ^ 5.0            type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_not_1"></a> <b>(~)/1</b>, <b>(\)/1</b> - bitwise-not of an integer value.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <code>~</code> <em>Expr</em> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <code>\</code> <em>Expr</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em>. If it is an integers, then the result is the integer value of performing a bitwise-not on <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr</em>)</code> - <em>Expr</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is ~22                 X is <span class="keyword">set</span> to -23
 X is ~22.0               type_error(integer, 22.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(\)/1</b> function is from <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>(~)/1</b> is the recommended spelling.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_lshift_2"></a> <b>(&lt;&lt;)/2</b> - bitwise shift left of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>&lt;&lt;</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing a left shift of <em>Expr1</em> by the value in the bottom 5 bits of <em>Expr2</em>. The top bits of <em>Expr2</em> are ignored.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 &lt;&lt; 5             X is <span class="keyword">set</span> to 704
 X is 22.0 &lt;&lt; 5           type_error(integer, 22.0)
 X is 22 &lt;&lt; 5.0           type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_rshift_2"></a> <b>(&gt;&gt;)/2</b> - bitwise signed shift right of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>&gt;&gt;</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing a signed left shift of <em>Expr1</em> by the value in the bottom 5 bits of <em>Expr2</em>. The top bits of <em>Expr2</em> are ignored.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 &gt;&gt; 5             X is <span class="keyword">set</span> to 0
 X is -22 &gt;&gt; 5            X is <span class="keyword">set</span> to -1
 X is 22.0 &gt;&gt; 5           type_error(integer, 22.0)
 X is 22 &gt;&gt; 5.0           type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a> leaves it unspecified whether <b>(&gt;&gt;)/2</b> is signed or unsigned. In Plang, <b>(&gt;&gt;)/2</b> is defined as signed, with <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a> provided for the unsigned case.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rushift_2">(&gt;&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_rushift_2"></a> <b>(&gt;&gt;&gt;)/2</b> - bitwise unsigned shift right of two integer values.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>&gt;&gt;&gt;</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em>. If both are integers, then the result is the integer value of performing an unsigned left shift of <em>Expr1</em> by the value in the bottom 5 bits of <em>Expr2</em>. The top bits of <em>Expr2</em> are ignored.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr1</em>)</code> - <em>Expr1</em> is not an integer. </li>
<li><code>type_error(integer, <em>Expr2</em>)</code> - <em>Expr2</em> is not an integer.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is 22 &gt;&gt;&gt; 5            X is <span class="keyword">set</span> to 0
 X is -22 &gt;&gt;&gt; 5           X is <span class="keyword">set</span> to 134217727 (0x07ffffff)
 X is 22.0 &gt;&gt;&gt; 5          type_error(integer, 22.0)
 X is 22 &gt;&gt;&gt; 5.0          type_error(integer, 5.0)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_and_2">(/\)/2</a>, <a class="el" href="group__arithmetic.html#func_or_2">(\/)/2</a>, <a class="el" href="group__arithmetic.html#func_xor_2">(^)/2</a>, <a class="el" href="group__arithmetic.html#func_not_1">(~)/1</a>, <a class="el" href="group__arithmetic.html#func_lshift_2">(&lt;&lt;)/2</a>, <a class="el" href="group__arithmetic.html#func_rshift_2">(&gt;&gt;)/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_abs_1"></a> <b>abs/1</b> - absolute value of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>abs</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and produces its absolute value as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number. </li>
<li><code>evaluation_error(int_overflow)</code> - <em>Expr</em> is the integer -2147483648, which cannot be negated to produce a positive integer value.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is abs(3)              X is set to 3
 X is abs(-35.125)        X is set to 35.125
 X is abs(-inf)           X is set to inf
 X is abs(nan)            X is set to nan
 X is abs(&quot;-35&quot;)          type_error(number, &quot;-35&quot;)
 X is abs(-2147483648)    evaluation_error(int_overflow)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_sign_1">sign/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_acos_1"></a> <b>acos/1</b> - arc cosine of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>acos</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and produces its arc cosine as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is acos(1)             sets X to 0.0
 X is acos(0.0)           sets X to pi / 2
 X is acos(inf)           sets X to nan
 X is acos(nan)           sets X to nan
 X is acos(&quot;1.0&quot;)         type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_asin_1"></a> <b>asin/1</b> - arc sine of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>asin</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and produces its arc sine as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is asin(0)             sets X to 0.0
 X is asin(1.0)           sets X to pi / 2
 X is asin(inf)           sets X to nan
 X is asin(nan)           sets X to nan
 X is asin(&quot;1.0&quot;)         type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_atan_1"></a> <b>atan/1</b> - arc tangent of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>atan</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and produces its arc tangent as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is atan(1.0)           sets X to pi / 4
 X is atan(0)             sets X to 0.0
 X is atan(inf)           sets X to pi / 2
 X is atan(nan)           sets X to nan
 X is atan(&quot;1.0&quot;)         type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_atan2_2"></a> <b>atan2/2</b> - arc tangent of two arithmetic terms.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>atan2</b>(<em>Expr1</em>, <em>Expr2</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em> and produces the arc tangent of <em>Expr1</em> / <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is atan2(1.0, 1.0)     sets X to pi / 4
 X is atan2(0, 1)         sets X to 0.0
 X is atan2(0, -1)        sets X to pi
 X is atan2(inf, 2)       sets X to pi / 2
 X is atan2(nan, 1)       sets X to nan
 X is atan2(1, nan)       sets X to nan
 X is atan2(&quot;2.0&quot;, 1.0)   type_error(number, &quot;2.0&quot;)
 X is atan2(2.0, &quot;1.0&quot;)   type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_ceil_1"></a> <b>ceil/1</b>, <b>ceiling/1</b> - smallest integer not smaller than an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>ceil</b>(<em>Expr</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <b>ceiling</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and rounds the smallest integer that is not smaller than <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is ceil(3)             X is set to 3
 X is ceil(35.125)        X is set to 36.0
 X is ceil(-35.125)       X is set to -35.0
 X is ceil(0.0)           X is set to 0.0
 X is ceil(-inf)          X is set to -inf
 X is ceil(nan)           X is set to nan
 X is ceil(&quot;-35&quot;)         type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>ceiling/1</b> function is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>ceil/1</b> is the recommended spelling.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_floor_1">floor/1</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a>, <a class="el" href="group__arithmetic.html#func_float_integer_part_1">float_integer_part/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_byte_2"></a> <b>byte/2</b> - integer value of a specific byte in a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>byte</b>(<em>Expr</em>, <em>Index</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Index</em> and returns the integer value of the byte at position <em>Index</em> within the string <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Index</em>)</code> - <em>Index</em> is not an integer. </li>
<li><code>domain_error(string_index, <em>Index</em>)</code> - <em>Index</em> is out of range for <em>Expr</em>.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is byte(<span class="stringliteral">&quot;foobar&quot;</span>, 3)       X is set to 98 (character code of &apos;b&apos;)
 X is byte(1.5, 2)            type_error(<span class="keywordtype">string</span>, 1.5)
 X is byte(&quot;foobar&quot;, 3.0)     type_error(integer, 3.0)
 X is byte(&quot;foobar&quot;, -1)      domain_error(string_index, -1)
 X is byte(&quot;foobar&quot;, 6)       domain_error(string_index, 6)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#atom_name_2">atom_name/2</a>, <a class="el" href="group__arithmetic.html#func_byte_to_string_1">byte_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_char_2">char/2</a>, <a class="el" href="group__arithmetic.html#func_length_bytes_1">length_bytes/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_byte_to_string_1"></a> <b>byte_to_string/1</b> - convert an integer byte code into a single-byte string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>byte_to_string</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the single-byte string that corresponds to the integer value of <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr</em>)</code> - <em>Expr</em> is not an integer. </li>
<li><code>type_error(byte, <em>Expr</em>)</code> - <em>Expr</em> is an integer that is not within the range 0 to 255.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is byte_to_string(98)      X is set to &quot;b&quot;
 X is byte_to_string(0xC1)    X is set to &quot;\xC1&quot;
 X is byte_to_string(1.5)     type_error(integer, 1.5)
 X is byte_to_string(-1)      type_error(byte, -1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_byte_2">byte/2</a>, <a class="el" href="group__arithmetic.html#func_char_to_string_1">char_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_length_bytes_1">length_bytes/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_char_2"></a> <b>char/2</b> - integer value of a specific character in a UTF-8 string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>char</b>(<em>Expr</em>, <em>Index</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Index</em> and returns the Unicode integer value of the UTF-8 character at position <em>Index</em> within the string <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Index</em>)</code> - <em>Index</em> is not an integer. </li>
<li><code>domain_error(string_index, <em>Index</em>)</code> - <em>Index</em> is out of range for <em>Expr</em>.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is char(<span class="stringliteral">&quot;foobar&quot;</span>, 3)       X is set to 98 (character code of &apos;b&apos;)
 X is <span class="keywordtype">char</span>(&quot;\u00AF&quot;, 0)       X is set to 0x00AF
 X is <span class="keywordtype">char</span>(1.5, 2)            type_error(<span class="keywordtype">string</span>, 1.5)
 X is <span class="keywordtype">char</span>(&quot;foobar&quot;, 3.0)     type_error(integer, 3.0)
 X is <span class="keywordtype">char</span>(&quot;foobar&quot;, -1)      domain_error(string_index, -1)
 X is <span class="keywordtype">char</span>(&quot;foobar&quot;, 6)       domain_error(string_index, 6)
 X is <span class="keywordtype">char</span>(&quot;\u00AF&quot;, 1)       domain_error(string_index, 1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#atom_name_2">atom_name/2</a>, <a class="el" href="group__arithmetic.html#func_byte_2">byte/2</a>, <a class="el" href="group__arithmetic.html#func_char_to_string_1">char_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_length_1">length/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_char_to_string_1"></a> <b>char_to_string/1</b> - convert a Unicode integer character code into a single-character UTF-8 string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>char_to_string</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the single-character UTF-8 string that corresponds to the integer character code of <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(integer, <em>Expr</em>)</code> - <em>Expr</em> is not an integer. </li>
<li><code>representation_error(character_code)</code> - <em>Expr</em> is an integer that does not correspond to a valid character code.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is char_to_string(98)      X is set to &quot;b&quot;
 X is char_to_string(0x00AF)  X is set to &quot;\u00AF&quot;
 X is char_to_string(1.5)     type_error(integer, 1.5)
 X is char_to_string(-1)      representation_error(character_code)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_byte_to_string_1">byte_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_char_2">char/2</a>, <a class="el" href="group__arithmetic.html#func_length_1">length/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_cos_1"></a> <b>cos/1</b> - cosine of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>cos</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> as a value in radians and produces its cosine as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is cos(0)              sets X to 1.0
 X is cos(pi / 2)         sets X to 0.0
 X is cos(inf)            sets X to nan
 X is cos(nan)            sets X to nan
 X is cos(&quot;1.0&quot;)          type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_exp_1"></a> <b>exp/1</b> - base-<em>e</em> exponential of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>exp</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and computes the base-<em>e</em> exponential of <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is exp(1)              X is set to e
 X is exp(0)              X is set to 1.0
 X is exp(2.0)            X is set to e * e
 X is exp(-2.0)           X is set to 1 / (e * e)
 X is exp(inf)            X is set to inf
 X is exp(-inf)           X is set to 0.0
 X is exp(nan)            X is set to nan
 X is exp(&quot;2.0&quot;)          type_error(number, &quot;2.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_log_1">log/1</a>, <a class="el" href="group__arithmetic.html#func_pow_2">pow/2</a>, <a class="el" href="group__arithmetic.html#func_sqrt_1">sqrt/1</a>, <a class="el" href="group__arithmetic.html#func_e_0">e/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_e_0"></a> <b>e/0</b> - mathematical constant for <em>e</em>.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>e</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>This function evaluates to the floating-point mathematical constant for <em>e</em>, 2.7182818284590452354.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> E2 is e * 2
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>, <a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_float_1"></a> <b>float/1</b> - conversion to floating-point.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>float</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and converts it into a floating-point value. Strings are converted using the C function strtod().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> F is float(3)            F is set to 3.0
 F is <span class="keywordtype">float</span>(3.5)          F is set to 3.5 (no change)
 F is <span class="keywordtype">float</span>(2 + 6)        F is set to 8.0
 F is <span class="keywordtype">float</span>(&quot;-3.5e02&quot;)    F is set to -350.0 (<span class="keywordtype">string</span> conversion)
 F is <span class="keywordtype">float</span>(&quot;foo&quot;)        type_error(number, &quot;foo&quot;)
 F is <span class="keywordtype">float</span>(&apos;3.5&apos;)        type_error(evaluable, &apos;3.5&apos;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#func_integer_1">integer/1</a>, <a class="el" href="group__arithmetic.html#func_string_1">string/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_float_fractional_part_1"></a> <b>float_fractional_part/1</b> - fractional part of a floating-point arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>float_fractional_part</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the fractional part of the value.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is float_fractional_part(3)        X is set to 0
 X is float_fractional_part(35.125)   X is set to 0.125
 X is float_fractional_part(-35.125)  X is set to -0.125
 X is float_fractional_part(0.0)      X is set to 0.0
 X is float_fractional_part(-inf)     X is set to 0.0
 X is float_fractional_part(nan)      X is set to nan
 X is float_fractional_part(&quot;-35&quot;)    type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_float_integer_part_1">float_integer_part/1</a>, <a class="el" href="group__arithmetic.html#func_floor_1">floor/1</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_float_integer_part_1"></a> <b>float_integer_part/1</b> - integer part of a floating-point arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>float_integer_part</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the integer part of the value.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is float_integer_part(3)           X is set to 3
 X is float_integer_part(35.125)      X is set to 35.0
 X is float_integer_part(-35.125)     X is set to -35.0
 X is float_integer_part(0.0)         X is set to 0.0
 X is float_integer_part(-inf)        X is set to -inf
 X is float_integer_part(nan)         X is set to nan
 X is float_integer_part(&quot;-35&quot;)       type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_float_fractional_part_1">float_fractional_part/1</a>, <a class="el" href="group__arithmetic.html#func_floor_1">floor/1</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_floor_1"></a> <b>floor/1</b> - largest integer not greater than an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>floor</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the largest integer that is not larger than <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is floor(3)            X is set to 3
 X is floor(35.125)       X is set to 35.0
 X is floor(-35.125)      X is set to -36.0
 X is floor(0.0)          X is set to 0.0
 X is floor(-inf)         X is set to -inf
 X is floor(nan)          X is set to nan
 X is floor(&quot;-35&quot;)        type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_ceil_1">ceil/1</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a>, <a class="el" href="group__arithmetic.html#func_float_integer_part_1">float_integer_part/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_inf_0"></a> <b>inf/0</b> - mathematical constant for positive infinity.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>inf</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>This function evaluates to the floating-point mathematical constant for positive infinity.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> Inf is inf
 NegInf is -inf
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_e_0">e/0</a>, <a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a>, <a class="el" href="group__arithmetic.html#isinf_1">isinf/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_integer_1"></a> <a class="anchor" id="func_truncate_1"></a> <b>integer/1</b>, <b>truncate/1</b> - conversion to integer.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>integer</b>(<em>Expr</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <b>truncate</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and converts it into an integer value by truncating the fractional part. Strings are converted using the C function strtol().</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>evaluation_error(int_overflow)</code> - a conversion to the integer type resulted in an overflow because the incoming floating-point or string value was too large.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> I is integer(3)              I is set to 3 (no change)
 I is integer(3.5)            I is set to 3
 I is integer(2.0 + 6.0)      I is set to 8
 I is integer(&quot;-35&quot;)          I is set to -35 (<span class="keywordtype">string</span> conversion)
 I is integer(&quot;foo&quot;)          type_error(integer, &quot;foo&quot;)
 I is integer(&apos;3&apos;)            type_error(evaluable, &apos;3&apos;)
 I is integer(2147483648.0)   evaluation_error(int_overflow)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>truncate/1</b> function is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>integer/1</b> is the recommended spelling.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#func_float_1">float/1</a>, <a class="el" href="group__arithmetic.html#func_round_1">round/1</a>, <a class="el" href="group__arithmetic.html#func_string_1">string/1</a>, <a class="el" href="group__arithmetic.html#func_float_integer_part_1">float_integer_part/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_left_2"></a> <b>left/2</b> - extract the left portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>left</b>(<em>Expr</em>, <em>Length</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Length</em>. Returns the <em>Length</em> UTF-8 characters at the beginning of the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is greater than the length of <em>Expr</em>, then the whole string is returned.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is left(<span class="stringliteral">&quot;foobar&quot;</span>, 3)       X is set to &quot;foo&quot;
 X is left(&quot;foobar&quot;, 10)      X is set to &quot;foobar&quot;
 X is left(&quot;foobar&quot;, 0)       X is set to &quot;&quot;
 X is left(1.5, 1)            type_error(<span class="keywordtype">string</span>, 1.5)
 X is left(&quot;foobar&quot;, 1.0)     type_error(integer, 1.0)
 X is left(&quot;foobar&quot;, -1)      domain_error(not_less_than_zero, -1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_bytes_2">left_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_2">mid/2</a>, <a class="el" href="group__arithmetic.html#func_mid_3">mid/3</a>, <a class="el" href="group__arithmetic.html#func_right_2">right/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_left_bytes_2"></a> <b>left_bytes/2</b> - extract the left portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>left_bytes</b>(<em>Expr</em>, <em>Length</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Length</em>. Returns the <em>Length</em> bytes at the beginning of the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is greater than the length of <em>Expr</em>, then the whole string is returned.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is left_bytes(<span class="stringliteral">&quot;foobar&quot;</span>, 3)     X is set to &quot;foo&quot;
 X is left_bytes(&quot;foobar&quot;, 10)    X is set to &quot;foobar&quot;
 X is left_bytes(&quot;foobar&quot;, 0)     X is set to &quot;&quot;
 X is left_bytes(1.5, 1)          type_error(<span class="keywordtype">string</span>, 1.5)
 X is left_bytes(&quot;foobar&quot;, 1.0)   type_error(integer, 1.0)
 X is left_bytes(&quot;foobar&quot;, -1)    domain_error(not_less_than_zero, -1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_2">left/2</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_2">mid_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_3">mid_bytes/3</a>, <a class="el" href="group__arithmetic.html#func_right_bytes_2">right_bytes/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_length_1"></a> <b>length/1</b> - length of a string in UTF-8 characters.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>length</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the length of the string in UTF-8 characters.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is length(<span class="stringliteral">&quot;foobar&quot;</span>)        X is set to 6
 X is length(&quot;foo&quot; + &quot;bar&quot;)   X is set to 6
 X is length(&quot;&quot;)              X is set to 0
 X is length(&quot;\u00AF&quot;)        X is set to 1
 X is length(1.5)             type_error(<span class="keywordtype">string</span>, 1.5)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_char_2">char/2</a>, <a class="el" href="group__arithmetic.html#func_char_to_string_1">char_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_length_bytes_1">length_bytes/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_length_bytes_1"></a> <b>length_bytes/1</b> - length of a string in bytes.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>length</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and returns the length of the string in bytes.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is length_bytes(<span class="stringliteral">&quot;foobar&quot;</span>)          X is set to 6
 X is length_bytes(&quot;foo&quot; + &quot;bar&quot;)     X is set to 6
 X is length_bytes(&quot;&quot;)                X is set to 0
 X is length_bytes(&quot;\u00AF&quot;)          X is set to 2
 X is length_bytes(1.5)               type_error(<span class="keywordtype">string</span>, 1.5)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_byte_2">byte/2</a>, <a class="el" href="group__arithmetic.html#func_byte_to_string_1">byte_to_string/1</a>, <a class="el" href="group__arithmetic.html#func_length_1">length/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_log_1"></a> <b>log/1</b> - base-<em>e</em> logarithm of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>log</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and computes the base-<em>e</em> logarithm of <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is log(e)              X is set to 1
 X is log(1)              X is set to 0.0
 X is log(e * e)          X is set to 2.0
 X is log(1 / (e * e))    X is set to -2.0
 X is log(0.0)            X is set to -inf
 X is log(inf)            X is set to inf
 X is log(-inf)           X is set to nan
 X is log(nan)            X is set to nan
 X is log(&quot;2.0&quot;)          type_error(number, &quot;2.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_exp_1">exp/1</a>, <a class="el" href="group__arithmetic.html#func_pow_2">pow/2</a>, <a class="el" href="group__arithmetic.html#func_sqrt_1">sqrt/1</a>, <a class="el" href="group__arithmetic.html#func_e_0">e/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_mid_2"></a> <a class="anchor" id="func_mid_3"></a> <b>mid/2</b>, <b>mid/3</b> - extract the middle portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>mid</b>(<em>Expr</em>, <em>Start</em>, <em>Length</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <b>mid</b>(<em>Expr</em>, <em>Start</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em>, <em>Start</em>, and <em>Length</em>. Returns the <em>Length</em> UTF-8 characters starting at index <em>Start</em> within <em>Expr</em>. The first character is at index 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is omited, then the returned string starts at <em>Start</em> and extends to the end of <em>Expr</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Start</em> is beyond the end of <em>Expr</em>, then the empty string is returned. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If (<em>Start</em> + <em>Length</em>) is greater than the length of <em>Expr</em>, then as many characters as are available are returned, starting at <em>Start</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Start</em>)</code> - <em>Start</em> is not an integer. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Start</em>)</code> - <em>Start</em> is an integer that is less than zero. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is mid(<span class="stringliteral">&quot;foobar&quot;</span>, 1, 4)     X is set to &quot;ooba&quot;
 X is mid(&quot;foobar&quot;, 1, 0)     X is set to &quot;&quot;
 X is mid(&quot;foobar&quot;, 10, 3)    X is set to &quot;&quot;
 X is mid(&quot;foobar&quot;, 4, 3)     X is set to &quot;ar&quot;
 X is mid(&quot;foobar&quot;, 4)        X is set to &quot;ar&quot;
 X is mid(1.5, 1)             type_error(<span class="keywordtype">string</span>, 1.5)
 X is mid(&quot;foobar&quot;, 1.0, 4)   type_error(integer, 1.0)
 X is mid(&quot;foobar&quot;, 1, 4.0)   type_error(integer, 4.0)
 X is mid(&quot;foobar&quot;, -1)       domain_error(not_less_than_zero, -1)
 X is mid(&quot;foobar&quot;, 1, -4)    domain_error(not_less_than_zero, -4)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_2">left/2</a>, <a class="el" href="group__arithmetic.html#func_right_2">right/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_mid_bytes_2"></a> <a class="anchor" id="func_mid_bytes_3"></a> <b>mid_bytes/2</b>, <b>mid_bytes/3</b> - extract the middle portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>mid_bytes</b>(<em>Expr</em>, <em>Start</em>, <em>Length</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <b>mid_bytes</b>(<em>Expr</em>, <em>Start</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em>, <em>Start</em>, and <em>Length</em>. Returns the <em>Length</em> bytes starting at index <em>Start</em> within <em>Expr</em>. The first byte is at index 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is omited, then the returned string starts at <em>Start</em> and extends to the end of <em>Expr</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Start</em> is beyond the end of <em>Expr</em>, then the empty string is returned. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If (<em>Start</em> + <em>Length</em>) is greater than the length of <em>Expr</em>, then as many bytes as are available are returned, starting at <em>Start</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Start</em>)</code> - <em>Start</em> is not an integer. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Start</em>)</code> - <em>Start</em> is an integer that is less than zero. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is mid_bytes(<span class="stringliteral">&quot;foobar&quot;</span>, 1, 4)   X is set to &quot;ooba&quot;
 X is mid_bytes(&quot;foobar&quot;, 1, 0)   X is set to &quot;&quot;
 X is mid_bytes(&quot;foobar&quot;, 10, 3)  X is set to &quot;&quot;
 X is mid_bytes(&quot;foobar&quot;, 4, 3)   X is set to &quot;ar&quot;
 X is mid_bytes(&quot;foobar&quot;, 4)      X is set to &quot;ar&quot;
 X is mid_bytes(1.5, 1)           type_error(<span class="keywordtype">string</span>, 1.5)
 X is mid_bytes(&quot;foobar&quot;, 1.0, 4) type_error(integer, 1.0)
 X is mid_bytes(&quot;foobar&quot;, 1, 4.0) type_error(integer, 4.0)
 X is mid_bytes(&quot;foobar&quot;, -1)     domain_error(not_less_than_zero, -1)
 X is mid_bytes(&quot;foobar&quot;, 1, -4)  domain_error(not_less_than_zero, -4)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_bytes_2">left_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_2">mid/2</a>, <a class="el" href="group__arithmetic.html#func_mid_3">mid/3</a>, <a class="el" href="group__arithmetic.html#func_right_bytes_2">right_bytes/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_nan_0"></a> <b>nan/0</b> - mathematical constant for the IEEE not-a-number indication.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>nan</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>This function evaluates to the floating-point mathematical constant for the IEEE not-a-number indication.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> NaN is nan
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_e_0">e/0</a>, <a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a>, <a class="el" href="group__arithmetic.html#isnan_1">isnan/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_pi_0"></a> <b>pi/0</b> - mathematical constant for <em>pi</em>.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>pi</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>This function evaluates to the floating-point mathematical constant for <em>pi</em>, 3.14159265358979323846.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> PIOver2 is pi / 2
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_e_0">e/0</a>, <a class="el" href="group__arithmetic.html#func_inf_0">inf/0</a>, <a class="el" href="group__arithmetic.html#func_nan_0">nan/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_pow_2"></a> <b>pow/2</b>, <b>(**)/2</b> - raises one arithmetic term to the power of another.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>pow</b>(<em>Expr1</em>, <em>Expr2</em>) </dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>Var</em> <b>is</b> <em>Expr1</em> <b>**</b> <em>Expr2</em> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr1</em> and <em>Expr2</em> and computes the result of raising <em>Expr1</em> to the power of <em>Expr2</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr1</em>)</code> - <em>Expr1</em> is not a number. </li>
<li><code>type_error(number, <em>Expr2</em>)</code> - <em>Expr2</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is pow(2, 3)           X is set to 8
 X is pow(3.5, 0)         X is set to 1.0
 X is pow(9, 0.5)         X is set to 3.0
 X is pow(1.0, 43)        X is set to 1.0
 X is pow(1.0, nan)       X is set to 1.0
 X is pow(nan, 0)         X is set to 1.0
 X is pow(0.0, 20)        X is set to 0.0
 X is pow(-1, inf)        X is set to 1.0
 X is pow(-1, -inf)       X is set to 1.0
 X is pow(0.5, -inf)      X is set to inf
 X is pow(1.5, -inf)      X is set to 0.0
 X is pow(1.5, inf)       X is set to inf
 X is pow(-inf, -3)       X is set to 0.0
 X is pow(-inf, 3)        X is set to -inf
 X is pow(-inf, 4)        X is set to inf
 X is pow(inf, -2)        X is set to 0.0
 X is pow(inf, 2)         X is set to inf
 X is pow(0.0, -2)        X is set to inf
 X is pow(nan, nan)       X is set to nan
 X is pow(&quot;2.0&quot;, 2)       type_error(number, &quot;2.0&quot;)
 X is pow(2, &quot;2.0&quot;)       type_error(number, &quot;2.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>(**)/2</b> function is compatible with <a class="el" href="group__predicates.html#standard">Standard Prolog</a>. The new name <b>pow/2</b> is the recommended spelling.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_exp_1">exp/1</a>, <a class="el" href="group__arithmetic.html#func_log_1">log/2</a>, <a class="el" href="group__arithmetic.html#func_sqrt_1">sqrt/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_random_0"></a> <b>random/0</b> - generate a random number between 0 and 1.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>random</b> </dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Generates a random number between 0 and 1, but not including 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note: the random number generator uses a simple linear congruential algorithm. The generated values are not suitable for use in high security applications.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is random                  generates a <span class="keywordtype">float</span> between 0.0 and 1.0
 X is integer(random * 20)    generates an integer between 0 and 19
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#randomize_1">randomize/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_right_2"></a> <b>right/2</b> - extract the right portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>right</b>(<em>Expr</em>, <em>Length</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Length</em>. Returns the <em>Length</em> characters at the end of the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is greater than the length of <em>Expr</em>, then the whole string is returned.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is right(<span class="stringliteral">&quot;foobar&quot;</span>, 3)      X is set to &quot;bar&quot;
 X is right(&quot;foobar&quot;, 10)     X is set to &quot;foobar&quot;
 X is right(&quot;foobar&quot;, 0)      X is set to &quot;&quot;
 X is right(1.5, 1)           type_error(<span class="keywordtype">string</span>, 1.5)
 X is right(&quot;foobar&quot;, 1.0)    type_error(integer, 1.0)
 X is right(&quot;foobar&quot;, -1)     domain_error(not_less_than_zero, -1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_2">left/2</a>, <a class="el" href="group__arithmetic.html#func_mid_2">mid/2</a>, <a class="el" href="group__arithmetic.html#func_mid_3">mid/3</a>, <a class="el" href="group__arithmetic.html#func_right_bytes_2">right_bytes/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_right_bytes_2"></a> <b>right_bytes/2</b> - extract the right portion of a string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>right_bytes</b>(<em>Expr</em>, <em>Length</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and <em>Length</em>. Returns the <em>Length</em> bytes at the end of the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <em>Length</em> is greater than the length of <em>Expr</em>, then the whole string is returned.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(string, <em>Expr</em>)</code> - <em>Expr</em> is not a string. </li>
<li><code>type_error(integer, <em>Length</em>)</code> - <em>Length</em> is not an integer. </li>
<li><code>domain_error(not_less_than_zero, <em>Length</em>)</code> - <em>Start</em> is an integer that is less than zero.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is right_bytes(<span class="stringliteral">&quot;foobar&quot;</span>, 3)    X is set to &quot;bar&quot;
 X is right_bytes(&quot;foobar&quot;, 10)   X is set to &quot;foobar&quot;
 X is right_bytes(&quot;foobar&quot;, 0)    X is set to &quot;&quot;
 X is right_bytes(1.5, 1)         type_error(<span class="keywordtype">string</span>, 1.5)
 X is right_bytes(&quot;foobar&quot;, 1.0)  type_error(integer, 1.0)
 X is right_bytes(&quot;foobar&quot;, -1)   domain_error(not_less_than_zero, -1)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_left_bytes_2">left_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_2">mid_bytes/2</a>, <a class="el" href="group__arithmetic.html#func_mid_bytes_3">mid_bytes/3</a>, <a class="el" href="group__arithmetic.html#func_right_2">right/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_round_1"></a> <b>round/1</b> - rounds an arithmetic term to the nearest integer.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>round</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and rounds the value to the nearest integer. If <em>Expr</em> is halfway between two integers (at 0.5), then <b>round/1</b> will round away from zero.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is round(3)            X is set to 3
 X is round(35.125)       X is set to 35.0
 X is round(35.5)         X is set to 36.0
 X is round(35.625)       X is set to 36.0
 X is round(-35.125)      X is set to -35.0
 X is round(-35.5)        X is set to -36.0
 X is round(-35.625)      X is set to -36.0
 X is round(0.0)          X is set to 0.0
 X is round(-inf)         X is set to -inf
 X is round(nan)          X is set to nan
 X is round(&quot;-35&quot;)        type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The <b>round/1</b> function in <a class="el" href="group__predicates.html#standard">Standard Prolog</a> produces an integer result, which means it does not work on large floating-point values. Use <b>integer</b>(<b>round</b>(<em>Expr</em>)) to achieve the Standard Prolog behavior.</dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_integer_1">integer/1</a>, <a class="el" href="group__arithmetic.html#func_ceil_1">ceil/1</a>, <a class="el" href="group__arithmetic.html#func_floor_1">floor/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_sign_1"></a> <b>sign/1</b> - calculate the sign (-1, 0, or 1) of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>sign</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and produces the integer values -1, 0, or 1 dependening upon whether <em>Expr</em> is negative, zero, or positive.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is sign(3)             X is set to 1
 X is sign(-35.125)       X is set to -1
 X is sign(0.0)           X is set to 0
 X is sign(-0.0)          X is set to 0
 X is sign(-inf)          X is set to -1
 X is sign(nan)           X is set to 0
 X is sign(&quot;-35&quot;)         type_error(number, &quot;-35&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_neg_1">(-)/1</a>, <a class="el" href="group__arithmetic.html#func_abs_1">abs/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_sin_1"></a> <b>sin/1</b> - sine of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>sin</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> as a value in radians and produces its sine as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is sin(0)              sets X to 0.0
 X is sin(pi / 2)         sets X to 1.0
 X is sin(inf)            sets X to nan
 X is sin(nan)            sets X to nan
 X is sin(&quot;1.0&quot;)          type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_tan_1">tan/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a></dd></dl>
<hr/>
 <a class="anchor" id="func_sqrt_1"></a> <b>sqrt/1</b> - square root of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>sqrt</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and computes the square root of <em>Expr</em>.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is sqrt(1)             X is set to 1.0
 X is sqrt(0.0)           X is set to 0.0
 X is sqrt(2.0)           X is set to 1.41421...
 X is sqrt(256)           X is set to 16.0
 X is sqrt(inf)           X is set to inf
 X is sqrt(-2.0)          X is set to nan
 X is sqrt(-inf)          X is set to nan
 X is sqrt(nan)           X is set to nan
 X is sqrt(&quot;2.0&quot;)         type_error(number, &quot;2.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>Compatibility</b></dt><dd><a class="el" href="group__predicates.html#standard">Standard Prolog</a></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_exp_1">exp/1</a>, <a class="el" href="group__arithmetic.html#func_log_1">log/1</a>, <a class="el" href="group__arithmetic.html#func_pow_2">pow/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_string_1"></a> <b>string/1</b> - conversion to string.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>string</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and converts it into a string value using the C function snprintf(). Floating point values use the format "&lt;tt&gt;%.10g&lt;/tt&gt;", adding a trailing "&lt;tt&gt;.0&lt;/tt&gt;" if necessary to make the value a valid Plang floating-point constant. Use <a class="el" href="group__arithmetic.html#func_string_2">string/2</a> to specify a different precision from 10.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> S is string(3)           S is set to &quot;3&quot;
 S is <span class="keywordtype">string</span>(3.5)         S is set to &quot;3.5&quot;
 S is <span class="keywordtype">string</span>(2.0 + 6.0)   S is set to &quot;8.0&quot;
 S is <span class="keywordtype">string</span>(&quot;foo&quot;)       S is set to &quot;foo&quot; (no change)
 S is <span class="keywordtype">string</span>(2.0e35)      S is set to &quot;2e+35&quot;
 S is <span class="keywordtype">string</span>(&apos;3&apos;)         type_error(evaluable, &apos;3&apos;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#func_float_1">float/1</a>, <a class="el" href="group__arithmetic.html#func_integer_1">integer/1</a>, <a class="el" href="group__arithmetic.html#func_string_2">string/2</a></dd></dl>
<hr/>
 <a class="anchor" id="func_string_2"></a> <b>string/2</b> - conversion to string with specified floating-point precision.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>string</b>(<em>Expr</em>, <em>Precision</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> and converts it into a string value using the C function snprintf(). Floating point values use the format "&lt;tt&gt;%.Pg&lt;/tt&gt;" where <code>P</code> is the result of evaluating <em>Precision</em>. A trailing "&lt;tt&gt;.0&lt;/tt&gt;" will be added if necessary to make the value a valid Plang floating-point constant.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>Same as for <a class="el" href="group__arithmetic.html#is_2">is/2</a>.</dd></dl>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> S is string(3, 2)        S is set to &quot;3&quot;
 S is <span class="keywordtype">string</span>(3.5, 2)      S is set to &quot;3.5&quot;
 S is <span class="keywordtype">string</span>(3.125, 2)    S is set to &quot;3.1&quot;
 S is <span class="keywordtype">string</span>(&quot;foo&quot;, 2)    S is set to &quot;foo&quot; (no change)
 S is <span class="keywordtype">string</span>(&apos;3&apos;)         type_error(evaluable, &apos;3&apos;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#is_2">is/2</a>, <a class="el" href="group__arithmetic.html#func_float_1">float/1</a>, <a class="el" href="group__arithmetic.html#func_integer_1">integer/1</a>, <a class="el" href="group__arithmetic.html#func_string_1">string/1</a></dd></dl>
<hr/>
 <a class="anchor" id="func_tan_1"></a> <b>tan/1</b> - tangent of an arithmetic term.</p>
<dl class="user"><dt><b>Usage</b></dt><dd><em>Var</em> <b>is</b> <b>tan</b>(<em>Expr</em>)</dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>Evaluates <em>Expr</em> as a value in radians and produces its tangent as the result.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd></dd></dl>
<ul>
<li><code>type_error(number, <em>Expr</em>)</code> - <em>Expr</em> is not a number.</li>
</ul>
<dl class="user"><dt><b>Examples</b></dt><dd><div class="fragment"><pre class="fragment"> X is tan(0)              sets X to 0.0
 X is tan(1.0)            sets X to 1.557407...
 X is tan(inf)            sets X to nan
 X is tan(nan)            sets X to nan
 X is tan(&quot;1.0&quot;)          type_error(number, &quot;1.0&quot;)
</pre></div></dd></dl>
<dl class="user"><dt><b>See Also</b></dt><dd><a class="el" href="group__arithmetic.html#func_acos_1">acos/1</a>, <a class="el" href="group__arithmetic.html#func_asin_1">asin/1</a>, <a class="el" href="group__arithmetic.html#func_atan_1">atan/1</a>, <a class="el" href="group__arithmetic.html#func_atan2_2">atan2/2</a>, <a class="el" href="group__arithmetic.html#func_cos_1">cos/1</a>, <a class="el" href="group__arithmetic.html#func_sin_1">sin/1</a>, <a class="el" href="group__arithmetic.html#func_pi_0">pi/0</a> </dd></dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2011 for plang by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
